<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="多去尝试你从未尝试的。">
<meta property="og:type" content="website">
<meta property="og:title" content="雪晟">
<meta property="og:url" content="liuxinixn.github.io/index.html">
<meta property="og:site_name" content="雪晟">
<meta property="og:description" content="多去尝试你从未尝试的。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雪晟">
<meta name="twitter:description" content="多去尝试你从未尝试的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxinixn.github.io/"/>





  <title>雪晟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雪晟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">十年饮冰，难凉热血。我是雪晟。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation视觉效果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation视觉效果/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>嗯，圆和椭圆还不错，但如果是带圆角的矩形呢<br>我们现在能做到那样了么？<br>史蒂芬·乔布斯</p>
</blockquote>
<p>我们在第三章『图层几何学』中讨论了图层的frame，第二章『寄宿图』则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。</p>
<ul>
<li>####<strong>圆角</strong></li>
</ul>
<p>圆角矩形是<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角举行的方法。恭喜你，猜对了。<br>CALayer有一个叫做conrnerRadius的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把masksToBounds设置成YES的话，图层里面的所有东西都会被截取。</p>
<p>我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-07f645d5d7004552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1.png"></p>
<p>然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果</p>
<p>#####清单4.1 设置cornerRadius和masksToBounds<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;￼￼￼</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //set the corner radius on our layers</div><div class="line">        self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">        self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">        </div><div class="line">        //enable clipping on the second layer</div><div class="line">        self.layerView2.layer.masksToBounds = YES;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-3a0579b2db95b743.png" alt="4.2.png"><br>如你所见，右边的子视图沿边界被裁剪了。<br>单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者CAShapeLayer（见第六章『专用图层』）。</p>
<ul>
<li>####<strong>图层边框</strong></li>
</ul>
<p> CALayer另外两个非常有用属性就是borderWidth和borderColor。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的bounds绘制，同时也包含图层的角。</p>
<p>borderWidth是以点为单位的定义边框粗细的浮点数，默认为0.borderColor定义了边框的颜色，默认为黑色。</p>
<p>borderColor是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了borderColor，虽然属性声明并不能证明这一点。CGColorRef在引用/释放时候的行为表现得与NSObject极其相似。但是Objective-C语法并不支持这一做法，所以CGColorRef属性即便是强引用也只能通过assign关键字来声明。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.</p>
<p>#####清单4.2 加上边框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       </div><div class="line">       //set the corner radius on our layers</div><div class="line">       self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">       self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">       </div><div class="line">       //add a border to our layers</div><div class="line">       self.layerView1.layer.borderWidth = 5.0f;</div><div class="line">       self.layerView2.layer.borderWidth = 5.0f;</div><div class="line">       </div><div class="line">       //enable clipping on the second layer</div><div class="line">       self.layerView2.layer.masksToBounds = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c76368bfcc883724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.3.png"><br>仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-767f323d4a8bcdb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.4.png"></p>
<ul>
<li>####<strong>contentsScale属性</strong></li>
</ul>
<p> iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。</p>
<p>给shadowOpacity属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：shadowColor，shadowOffset和shadowRadius。</p>
<p>显而易见，shadowColor属性控制着阴影的颜色，和borderColor和backgroundColor一样，它的类型也是CGColorRef。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。</p>
<p>shadowOffset属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。shadowOffset的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p>为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，shadowOffset的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-209274f1478b34a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.5.png"></p>
<p>苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。</p>
<p>shadowRadius属性控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。</p>
<p>通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给shadowRadius<br>设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-be8052dd45ee1287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.6.png"></p>
<ul>
<li>####<strong>阴影裁剪</strong></li>
</ul>
<p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-55db4a5ddd630e6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.7.png"></p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d6faa3736b29968d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.8.png"></p>
<p> 从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用masksToBounds裁剪内容的内图层。</p>
<p>如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-4c8e77c6cf05751f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.9.png"></p>
<p>我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。</p>
<p>#####清单4.3 用一个额外的视图来解决阴影裁切的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *shadowView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   ￼</div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       </div><div class="line">       //set the corner radius on our layers</div><div class="line">       self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">       self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">       </div><div class="line">       //add a border to our layers</div><div class="line">       self.layerView1.layer.borderWidth = 5.0f;</div><div class="line">       self.layerView2.layer.borderWidth = 5.0f;</div><div class="line">       </div><div class="line">       //add a shadow to layerView1</div><div class="line">       self.layerView1.layer.shadowOpacity = 0.5f;</div><div class="line">       self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);</div><div class="line">       self.layerView1.layer.shadowRadius = 5.0f;</div><div class="line">       </div><div class="line">       //add same shadow to shadowView (not layerView2)</div><div class="line">       self.shadowView.layer.shadowOpacity = 0.5f;</div><div class="line">       self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);</div><div class="line">       self.shadowView.layer.shadowRadius = 5.0f;</div><div class="line">       </div><div class="line">       //enable clipping on the second layer</div><div class="line">       self.layerView2.layer.masksToBounds = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-fd2670824eb2870b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.10.png"></p>
<ul>
<li><p>####<strong>shadowPath属性</strong></p>
<p>我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</p>
</li>
</ul>
<p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个shadowPath来提高性能。shadowPath是一个CGPathRef类型（一个指向CGPath的指针）。CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</p>
<p>图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。</p>
<p>#####清单4.4 创建简单的阴影形状<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //enable layer shadows</div><div class="line">    self.layerView1.layer.shadowOpacity = 0.5f;</div><div class="line">    self.layerView2.layer.shadowOpacity = 0.5f;</div><div class="line">    </div><div class="line">    //create a square shadow</div><div class="line">    CGMutablePathRef squarePath = CGPathCreateMutable();</div><div class="line">    CGPathAddRect(squarePath, NULL, self.layerView1.bounds);</div><div class="line">    self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);</div><div class="line">    </div><div class="line">    ￼//create a circular shadow</div><div class="line">    CGMutablePathRef circlePath = CGPathCreateMutable();</div><div class="line">    CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);</div><div class="line">    self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-eb06f611b0a94d9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.11.png"></p>
<p>如果是一个矩形或者是圆，用CGPath会相当简单明了。但是如果是更加复杂一点的图形，UIBezierPath类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<ul>
<li>####<strong>图层蒙板</strong></li>
</ul>
<p> 通过masksToBounds属性，我们可以沿边界裁剪图形；通过cornerRadius属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>
<p>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</p>
<p>CALayer有一个属性叫做mask可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，mask图层定义了父图层的部分可见区域。</p>
<p>mask图层的Color属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）</p>
<p>如果mask图层比父图层要小，只有在mask图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-15fab782b87c7c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.12.png"><br>我们将代码演示一下这个过程，创建一个简单的项目，通过图层的mask属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。</p>
<p>#####清单4.5 应用蒙板图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *imageView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //create mask layer</div><div class="line">    CALayer *maskLayer = [CALayer layer];</div><div class="line">    maskLayer.frame = self.layerView.bounds;</div><div class="line">    UIImage *maskImage = [UIImage imageNamed:@&quot;Cone.png&quot;];</div><div class="line">    maskLayer.contents = (__bridge id)maskImage.CGImage;</div><div class="line">    </div><div class="line">    //apply mask to image layer￼</div><div class="line">    self.imageView.layer.mask = maskLayer;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-260195fb443dc625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.13.png"><br>CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为mask属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。</p>
<ul>
<li>####<strong>拉伸过滤</strong></li>
</ul>
<p>最后我们再来谈谈minificationFilter和magnificationFilter<br>属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：</p>
<ul>
<li>能够显示最好的画质，像素既没有被压缩也没有被拉伸。</li>
<li>能更好的使用内存，因为这就是所有你要存储的东西。</li>
<li>最好的性能表现，CPU不需要为此额外的计算。</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。<br>当图片需要显示不同的大小的时候，有一种叫做拉伸过滤的<a href="http://lib.csdn.net/base/31" target="_blank" rel="noopener">算法</a>就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。<br>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。CALayer为此提供了三种拉伸过滤方法，他们是：</p>
<ul>
<li>kCAFilterLinear</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>
<p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。<br>kCAFilterTrilinear和kCAFilterLinear非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-627fcecfb98c98cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.14.png"></p>
<p>kCAFilterNearest是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重<br><img src="http://upload-images.jianshu.io/upload_images/1694376-14ccad89e4e169b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.15.png"></p>
<pre><code>图4.15 对于没有斜线的小图来说，最近过滤算法要好很多
</code></pre><p> 总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。</p>
<p>让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-abd590ea7cc36114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.16.png"></p>
<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个IBOutletCollection对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。</p>
<p>####清单4.6 显示一个LCD风格的时钟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;</div><div class="line">   @property (nonatomic, weak) NSTimer *timer;</div><div class="line">   ￼￼</div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad]; //get spritesheet image</div><div class="line">       UIImage *digits = [UIImage imageNamed:@&quot;Digits.png&quot;];</div><div class="line">       </div><div class="line">       //set up digit views</div><div class="line">       for (UIView *view in self.digitViews) &#123;</div><div class="line">           //set contents</div><div class="line">           view.layer.contents = (__bridge id)digits.CGImage;</div><div class="line">           view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);</div><div class="line">           view.layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       //start timer</div><div class="line">       self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">       </div><div class="line">       //set initial clock time</div><div class="line">       [self tick];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)setDigit:(NSInteger)digit forView:(UIView *)view</div><div class="line">   &#123;</div><div class="line">       //adjust contentsRect to select correct digit</div><div class="line">       view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)tick</div><div class="line">   &#123;</div><div class="line">       //convert time to hours, minutes and seconds</div><div class="line">       NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];</div><div class="line">       NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">       ￼</div><div class="line">       NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">       </div><div class="line">       //set hours</div><div class="line">       [self setDigit:components.hour / 10 forView:self.digitViews[0]];</div><div class="line">       [self setDigit:components.hour % 10 forView:self.digitViews[1]];</div><div class="line">       </div><div class="line">       //set minutes</div><div class="line">       [self setDigit:components.minute / 10 forView:self.digitViews[2]];</div><div class="line">       [self setDigit:components.minute % 10 forView:self.digitViews[3]];</div><div class="line">       </div><div class="line">       //set seconds</div><div class="line">       [self setDigit:components.second / 10 forView:self.digitViews[4]];</div><div class="line">       [self setDigit:components.second % 10 forView:self.digitViews[5]];</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-7dbef1a2760e625b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.18.png"></p>
<p>为了能像图4.19中那样，我们需要在for循环中加入如下代码：<br><code>view.layer.magnificationFilter = kCAFilterNearest;</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-43f21dbace80a1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.19.png"></p>
<ul>
<li>####<strong>组透明</strong></li>
</ul>
<p> UIView有一个叫做alpha的属性来确定视图的透明度。CALayer有一个等同的属性叫做opacity，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
<p>iOS常见的做法是把一个空间的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-8828828bb87444dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.20.png"></p>
<p> 这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>
<p>在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。</p>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的UIViewGroupOpacity为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果UIViewGroupOpacity并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。</p>
<p>另一个方法就是，你可以设置CALayer的一个叫做shouldRasterize属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。</p>
<p>为了启用shouldRasterize属性，我们设置了图层的rasterizationScale属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了shouldRasterize属性，你就要确保你设置了rasterizationScale属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>
<p>当shouldRasterize和UIViewGroupOpacity一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。</p>
<p>#####清单4.7 使用shouldRasterize属性解决组透明问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">    @interface ViewController ()</div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (UIButton *)customButton</div><div class="line">    &#123;</div><div class="line">        //create button</div><div class="line">        CGRect frame = CGRectMake(0, 0, 150, 50);</div><div class="line">        UIButton *button = [[UIButton alloc] initWithFrame:frame];</div><div class="line">        button.backgroundColor = [UIColor whiteColor];</div><div class="line">        button.layer.cornerRadius = 10;</div><div class="line">        </div><div class="line">        //add label</div><div class="line">        frame = CGRectMake(20, 10, 110, 30);</div><div class="line">        UILabel *label = [[UILabel alloc] initWithFrame:frame];</div><div class="line">        label.text = @&quot;Hello World&quot;;</div><div class="line">        label.textAlignment = NSTextAlignmentCenter;</div><div class="line">        [button addSubview:label];</div><div class="line">        return button;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //create opaque button</div><div class="line">        UIButton *button1 = [self customButton];</div><div class="line">        button1.center = CGPointMake(50, 150);</div><div class="line">        [self.containerView addSubview:button1];</div><div class="line">        </div><div class="line">        //create translucent button</div><div class="line">        UIButton *button2 = [self customButton];</div><div class="line">        ￼</div><div class="line">        button2.center = CGPointMake(250, 150);</div><div class="line">        button2.alpha = 0.5;</div><div class="line">        [self.containerView addSubview:button2];</div><div class="line">        </div><div class="line">        //enable rasterization for the translucent button</div><div class="line">        button2.layer.shouldRasterize = YES;</div><div class="line">        button2.layer.rasterizationScale = [UIScreen mainScreen].scale;</div><div class="line">    &#125;</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-006797526c30dcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.21.png"></p>
<p>#####总结<br> 这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。</p>
<p>在第五章，『变换』中，我们将会研究图层变化和3D转换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/iOS-计算富文本，检索网址，号码，表情，并且计算高度，设置最大行数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/iOS-计算富文本，检索网址，号码，表情，并且计算高度，设置最大行数/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1694376-55adea48bcb5ed75.gif?imageMogr2/auto-orient/strip" alt="fuwb.gif"></p>
<blockquote>
<p>前言：项目中用到检索表情，网址与号码，但是看了TTTAttributeLabel，emojyLabel，奈何都不太满意，plist格式不太符合，而且这两个第三方用到检索都是系统自带的检索，检测网址方面不准确， 所以就需要自己使用正则进行检索。</p>
</blockquote>
<p>关于以上两个三方检索不准确的可以参考：<a href="http://www.jianshu.com/p/72ab332f87e5" target="_blank" rel="noopener">检索网址</a></p>
<blockquote>
<p>接下来写一下实现的过程， 没有高度封装，仅供参考</p>
</blockquote>
<p>关于网址与号码的正则再说明下：<br><code>网址：KURlREGULAR @&quot;((http[s]{0,1}|ftp)://[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]{2,4})(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(www.[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]{2,4})(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(((http[s]{0,1}|ftp)://|)((?:(?:25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(?:25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d))))(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)&quot;</code><br><code>号码： KPHONENUMBERREGLAR @&quot;\\d{3}-\\d{8}|\\d{4}-\\d{7}|\\d{11}&quot;</code><br>比如我要转的字符串为<br><code>@&quot;简书：http://jianshu.com哈哈哈[调皮][流汗][偷笑][再见][可爱][色][害羞][委屈][委屈][抓狂][酷][酷][嘘][嘘][龇牙][大哭][大哭][大哭][龇牙][嘘][嘘][调皮][调皮]哈哈哈哈[嘘][调皮][调皮]18637963241他大舅他二舅都是舅，高桌子地板头都是木头&quot;</code></p>
<p>#####我需要做的是检索网址并且替换为和微博一样的链接，号码和链接有选中状态，因为UITextview有检测url 的方法可以添加点击事件，所以就采用UITextview进行封装。主要采取正则表达式与<code>RegexKitLite</code>配合做检索</p>
<p>1 . 首先建立一个模型，把文字检索为富文本，检索出 表情，网址以及号码。中间需要使用一个模型存储检索出来的结果。对于特殊符号的表情建立一个模型。其实富文本的都是逐个检索，然后处理，最后拼接为一个NSMutableAttributedString。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@interface ZLStatus : NSObject</div><div class="line">//源内容</div><div class="line">@property (nonatomic, copy) NSString *text;</div><div class="line"></div><div class="line">/**	string	信息内容 -- 带有属性的(特殊文字会高亮显示\显示表情)*/</div><div class="line">@property (nonatomic, copy) NSAttributedString *attributedText;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div></pre></td><td class="code"><pre><div class="line">#import &quot;ZLStatus.h&quot;</div><div class="line">#import &quot;ZLSpecial.h&quot;</div><div class="line">#import &quot;ZLTextPart.h&quot;</div><div class="line">#import &quot;RegexKitLite.h&quot;</div><div class="line">@implementation ZLStatus</div><div class="line">- (void)setText:(NSString *)text</div><div class="line">&#123;</div><div class="line">    _text = [text copy];</div><div class="line">    </div><div class="line">    // 利用text生成attributedText</div><div class="line">    self.attributedText = [self attributedTextWithText:text];</div><div class="line">&#125;</div><div class="line">/**</div><div class="line"> *  普通文字 --&gt; 属性文字</div><div class="line"> *</div><div class="line"> *  @param text 普通文字</div><div class="line"> *</div><div class="line"> *  @return 属性文字</div><div class="line"> */</div><div class="line">- (NSAttributedString *)attributedTextWithText:(NSString *)text</div><div class="line">&#123;</div><div class="line">    NSMutableAttributedString *attributedText = [[NSMutableAttributedString alloc] init];</div><div class="line">    </div><div class="line">    // 表情的规则</div><div class="line">    NSString *emotionPattern = @&quot;\\[[0-9a-zA-Z\\u4e00-\\u9fa5]+\\]&quot;;</div><div class="line">    // @的规则</div><div class="line">    NSString *atPattern = @&quot;@[0-9a-zA-Z\\u4e00-\\u9fa5-_]+&quot;;</div><div class="line">    // #话题#的规则</div><div class="line">    NSString *topicPattern = @&quot;#[0-9a-zA-Z\\u4e00-\\u9fa5]+#&quot;;</div><div class="line">    // url链接的规则</div><div class="line">    NSString *urlPattern = @&quot;((http[s]&#123;0,1&#125;|ftp)://[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]&#123;2,4&#125;)(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(www.[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]&#123;2,4&#125;)(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(((http[s]&#123;0,1&#125;|ftp)://|)((?:(?:25[0-5]|2[0-4]\\d|((1\\d&#123;2&#125;)|([1-9]?\\d)))\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|((1\\d&#123;2&#125;)|([1-9]?\\d))))(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)&quot;;</div><div class="line">    NSString *phoneNumber =@&quot;\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;3&#125;-\\d&#123;7&#125;|\\d&#123;4&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;|1+[3578]+\\d&#123;9&#125;|\\d&#123;8&#125;|\\d&#123;7&#125;&quot;</div><div class="line">    ;</div><div class="line">    NSString *pattern = [NSString stringWithFormat:@&quot;%@|%@|%@|%@|%@&quot;, emotionPattern, atPattern, topicPattern, urlPattern,phoneNumber];</div><div class="line">    </div><div class="line">    // 遍历所有的特殊字符串</div><div class="line">    NSMutableArray *parts = [NSMutableArray array];</div><div class="line">    [text enumerateStringsMatchedByRegex:pattern usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) &#123;</div><div class="line">        if ((*capturedRanges).length == 0) return;</div><div class="line">        </div><div class="line">        ZLTextPart *part = [[ZLTextPart alloc] init];</div><div class="line">        part.special = YES;</div><div class="line">        part.text = *capturedStrings;</div><div class="line">        part.emotion = [part.text hasPrefix:@&quot;[&quot;] &amp;&amp; [part.text hasSuffix:@&quot;]&quot;];</div><div class="line">        part.range = *capturedRanges;</div><div class="line">        [parts addObject:part];</div><div class="line">    &#125;];</div><div class="line">    // 遍历所有的非特殊字符</div><div class="line">    [text enumerateStringsSeparatedByRegex:pattern usingBlock:^(NSInteger captureCount, NSString *const __unsafe_unretained *capturedStrings, const NSRange *capturedRanges, volatile BOOL *const stop) &#123;</div><div class="line">        if ((*capturedRanges).length == 0) return;</div><div class="line">        </div><div class="line">        ZLTextPart *part = [[ZLTextPart alloc] init];</div><div class="line">        part.text = *capturedStrings;</div><div class="line">        part.range = *capturedRanges;</div><div class="line">        [parts addObject:part];</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    // 排序</div><div class="line">    // 系统是按照从小 -&gt; 大的顺序排列对象</div><div class="line">    [parts sortUsingComparator:^NSComparisonResult(ZLTextPart *part1, ZLTextPart *part2) &#123;</div><div class="line">        // NSOrderedAscending = -1L, NSOrderedSame, NSOrderedDescending</div><div class="line">        // 返回NSOrderedSame:两个一样大</div><div class="line">        // NSOrderedAscending(升序):part2&gt;part1</div><div class="line">        // NSOrderedDescending(降序):part1&gt;part2</div><div class="line">        if (part1.range.location &gt; part2.range.location) &#123;</div><div class="line">            // part1&gt;part2</div><div class="line">            // part1放后面, part2放前面</div><div class="line">            return NSOrderedDescending;</div><div class="line">        &#125;</div><div class="line">        // part1&lt;part2</div><div class="line">        // part1放前面, part2放后面</div><div class="line">        return NSOrderedAscending;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    UIFont *font = [UIFont systemFontOfSize:15];</div><div class="line">    NSMutableArray *specials = [NSMutableArray array];</div><div class="line">    NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;face.plist&quot; ofType:nil];</div><div class="line">    NSArray  *face = [NSArray arrayWithContentsOfFile:filePath];</div><div class="line">    // 按顺序拼接每一段文字</div><div class="line">    for (ZLTextPart *part in parts) &#123;</div><div class="line">        // 等会需要拼接的子串</div><div class="line">        NSAttributedString *substr = nil;</div><div class="line">        if (part.isEmotion) &#123; // 表情  表情处理的时候，需要根据你自己的plist进行单独处理，像一些第三方里自定义的plist，格式要是也是很严格的</div><div class="line">            NSString *str = [text substringWithRange:part.range];</div><div class="line">            for (int i = 0; i &lt; face.count; i ++) &#123;</div><div class="line">                if ([face[i][@&quot;face_name&quot;] isEqualToString:str]) &#123;</div><div class="line">                    //face[i][@&quot;png&quot;]就是我们要加载的图片</div><div class="line">                    //新建文字附件来存放我们的图片,iOS7才新加的对象</div><div class="line">                    NSTextAttachment *textAttachment = [[NSTextAttachment alloc] init];</div><div class="line">                    //给附件添加图片</div><div class="line">                    textAttachment.image = [UIImage imageNamed:face[i][@&quot;face_image_name&quot;]];</div><div class="line">                    //调整一下图片的位置,如果你的图片偏上或者偏下，调整一下bounds的y值即可</div><div class="line">                    textAttachment.bounds = CGRectMake(0, -6, 25, 25);</div><div class="line">                    //把附件转换成可变字符串，用于替换掉源字符串中的表情文字</div><div class="line">                   substr = [NSAttributedString attributedStringWithAttachment:textAttachment];</div><div class="line"></div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        &#125; else if (part.special) &#123; // 非表情的特殊文字</div><div class="line">            NSURL *url =[NSURL URLWithString:part.text];</div><div class="line">            if (url.scheme) &#123;</div><div class="line">                substr = [[NSAttributedString alloc] initWithString:part.text attributes:@&#123;</div><div class="line">                                                                                           NSForegroundColorAttributeName : [UIColor redColor]</div><div class="line">                                                                                           &#125;];</div><div class="line"></div><div class="line">               NSString *string =@&quot;网页链接&quot;;</div><div class="line">                            NSTextAttachment *textAttachment = [[NSTextAttachment alloc] init];</div><div class="line">                                //给附件添加图片</div><div class="line">                                textAttachment.image = [UIImage imageNamed:@&quot;链接&quot;];</div><div class="line">                                //调整一下图片的位置,如果你的图片偏上或者偏下，调整一下bounds的y值即可</div><div class="line">                                textAttachment.bounds = CGRectMake(0, -6, 25, 25);</div><div class="line">                NSMutableAttributedString *tempAttribute = [[NSMutableAttributedString alloc]initWithAttributedString:[NSAttributedString attributedStringWithAttachment:textAttachment]];</div><div class="line">                 NSMutableAttributedString *tempAttribute2 = [[NSMutableAttributedString alloc]initWithAttributedString:[NSAttributedString attributedStringWithAttachment:textAttachment]];</div><div class="line">                NSAttributedString *text =[[NSAttributedString alloc]initWithString:string attributes:@&#123;NSForegroundColorAttributeName:[UIColor blueColor]&#125;];</div><div class="line">                [tempAttribute appendAttributedString:text];</div><div class="line">                substr = [[NSAttributedString alloc]initWithAttributedString:tempAttribute];</div><div class="line">                // 创建特殊对象</div><div class="line">                </div><div class="line">                ZLSpecial *s = [[ZLSpecial alloc] init];</div><div class="line">                s.text = string;</div><div class="line">              //需要添加附属图片的长度，负责点击范围会变化</div><div class="line">                NSUInteger loc = attributedText.length+tempAttribute2.length;</div><div class="line">                NSUInteger len = string.length;</div><div class="line">                s.range = NSMakeRange(loc, len);</div><div class="line">                s.urlString = part.text;</div><div class="line">                [specials addObject:s];</div><div class="line">            &#125;else&#123;</div><div class="line">                </div><div class="line">                NSLog(@&quot;%@&quot;,part.text);</div><div class="line">                substr = [[NSAttributedString alloc] initWithString:part.text attributes:@&#123;</div><div class="line">                                                                                           NSForegroundColorAttributeName : [UIColor redColor]</div><div class="line">                                                                                           &#125;];</div><div class="line">                // 创建特殊对象</div><div class="line">                ZLSpecial *s = [[ZLSpecial alloc] init];</div><div class="line">                s.text = part.text;</div><div class="line">                NSUInteger loc = attributedText.length;</div><div class="line">                NSUInteger len = part.text.length;</div><div class="line">                s.range = NSMakeRange(loc, len);</div><div class="line">                s.urlString = part.text;</div><div class="line">                [specials addObject:s];</div><div class="line">            &#125;</div><div class="line">           </div><div class="line">            </div><div class="line">           </div><div class="line">        &#125; else &#123; // 非特殊文字</div><div class="line">            substr = [[NSAttributedString alloc] initWithString:part.text];</div><div class="line">        &#125;</div><div class="line">        [attributedText appendAttributedString:substr];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 一定要设置字体,保证计算出来的尺寸是正确的</div><div class="line">    [attributedText addAttribute:NSFontAttributeName value:font range:NSMakeRange(0, attributedText.length)];</div><div class="line">    [attributedText addAttribute:@&quot;specials&quot; value:specials range:NSMakeRange(0, 1)];</div><div class="line">    </div><div class="line">    return attributedText;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####中间存储检索结果与特殊字符的model：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface ZLTextPart : NSObject</div><div class="line">/** 这段文字的内容 */</div><div class="line">@property (nonatomic, copy) NSString *text;</div><div class="line">/** 这段文字的范围 */</div><div class="line">@property (nonatomic, assign) NSRange range;</div><div class="line">/** 是否为特殊文字 */</div><div class="line">@property (nonatomic, assign, getter = isSpecical) BOOL special;</div><div class="line">/** 是否为表情 */</div><div class="line">@property (nonatomic, assign, getter = isEmotion) BOOL emotion;</div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line"></div><div class="line">@interface ZLSpecial : NSObject</div><div class="line">/** 这段特殊文字的内容 */</div><div class="line">@property (nonatomic, copy) NSString *text;</div><div class="line">/** 这段特殊文字的范围 */</div><div class="line">@property (nonatomic, assign) NSRange range;</div><div class="line">@property(nonatomic,copy)NSString *urlString;</div></pre></td></tr></table></figure>
<p>######设置完内容后我们需要计算内容高度，然后复制给Textview,建立一个Frame模型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &quot;ZLStatus.h&quot;</div><div class="line">@interface ZLFrame : NSObject</div><div class="line"></div><div class="line">//设置</div><div class="line"></div><div class="line">/** 限制最大行数  这一步必须在设置完contentLabelF之后设置*/</div><div class="line">@property(nonatomic,assign)int  maxNumLine;</div><div class="line">@property(nonatomic,strong)ZLStatus *status;</div><div class="line">@property(nonatomic,assign)CGFloat frameX;</div><div class="line">@property(nonatomic,assign)CGFloat frameY;</div><div class="line">@property(nonatomic,assign)CGFloat maxWidth;</div><div class="line">//取值</div><div class="line">/**   */</div><div class="line">/** 正文 */</div><div class="line">@property (nonatomic, assign) CGRect contentLabelF;</div><div class="line">@property(nonatomic,assign)CGRect   maxNumLabelF;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#import &quot;ZLFrame.h&quot;</div><div class="line">@interface ZLFrame()</div><div class="line">//检测高度的label;</div><div class="line">@property(nonatomic,strong)UILabel *templateLabel;</div><div class="line">@end</div><div class="line">@implementation ZLFrame</div><div class="line">-(void)setStatus:(ZLStatus *)status&#123;</div><div class="line">    _status = status;</div><div class="line">    CGSize contentSize = [status.attributedText boundingRectWithSize:CGSizeMake(self.maxWidth, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin context:nil].size;</div><div class="line">    self.contentLabelF = (CGRect)&#123;&#123;self.frameX , self.frameY&#125;, contentSize&#125;;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)setMaxNumLine:(int)maxNumLine&#123;</div><div class="line">    _maxNumLine = maxNumLine;</div><div class="line">    </div><div class="line">    self.templateLabel.frame =CGRectMake(self.frameX, self.frameY, self.maxWidth, 0);</div><div class="line">    self.templateLabel.attributedText = self.status.attributedText;</div><div class="line">    self.templateLabel.numberOfLines = maxNumLine;</div><div class="line">    [self.templateLabel sizeToFit];</div><div class="line">    self.maxNumLabelF = self.templateLabel.frame;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)setFrameX:(CGFloat)frameX&#123;</div><div class="line">    _frameX = frameX;</div><div class="line">&#125;</div><div class="line">-(void)setFrameY:(CGFloat)frameY&#123;</div><div class="line">    _frameY = frameY;</div><div class="line">&#125;</div><div class="line">-(void)setMaxWidth:(CGFloat)maxWidth&#123;</div><div class="line">    _maxWidth = maxWidth;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(UILabel *)templateLabel&#123;</div><div class="line">    if (!_templateLabel) &#123;</div><div class="line">        _templateLabel =[[UILabel alloc]init];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return _templateLabel;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>####最后自定义Textview，引入Frame模型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">#import &quot;ZLFrame.h&quot;</div><div class="line">@interface ZLStatusTextView : UITextView</div><div class="line">/** 所有的特殊字符串(里面存放着HWSpecial) */</div><div class="line">@property (nonatomic, strong) NSArray *specials;</div><div class="line">@property(nonatomic,strong)ZLFrame *zlFrame;</div><div class="line">@property(nonatomic,assign)int maxLine;</div><div class="line">@property(nonatomic,assign)BOOL isShowAll;//是否全部显示</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line">#import &quot;ZLStatusTextView.h&quot;</div><div class="line">#import &quot;ZLSpecial.h&quot;</div><div class="line">#define ZLStatusTextViewCoverTag 999</div><div class="line">@implementation ZLStatusTextView</div><div class="line">- (id)initWithFrame:(CGRect)frame</div><div class="line">&#123;</div><div class="line">    self = [super initWithFrame:frame];</div><div class="line">    if (self) &#123;</div><div class="line">        self.backgroundColor = [UIColor clearColor];</div><div class="line">        self.editable = NO;</div><div class="line">        self.textContainerInset = UIEdgeInsetsMake(0, -5, 0, -5);</div><div class="line">        // 禁止滚动, 让文字完全显示出来</div><div class="line">        self.scrollEnabled = NO;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    // 触摸对象</div><div class="line">    UITouch *touch = [touches anyObject];</div><div class="line">    </div><div class="line">    // 触摸点</div><div class="line">    CGPoint point = [touch locationInView:self];</div><div class="line">    </div><div class="line">    NSArray *specials = [self.attributedText attribute:@&quot;specials&quot; atIndex:0 effectiveRange:NULL];</div><div class="line">    BOOL contains = NO;</div><div class="line">    </div><div class="line">    for (ZLSpecial *special in specials) &#123;</div><div class="line">        self.selectedRange = special.range;</div><div class="line">        // self.selectedRange --影响--&gt; self.selectedTextRange</div><div class="line">        // 获得选中范围的矩形框</div><div class="line">        NSArray *rects = [self selectionRectsForRange:self.selectedTextRange];</div><div class="line">        // 清空选中范围</div><div class="line">        self.selectedRange = NSMakeRange(0, 0);</div><div class="line">        </div><div class="line">        for (UITextSelectionRect *selectionRect in rects) &#123;</div><div class="line">            CGRect rect = selectionRect.rect;</div><div class="line">            if (rect.size.width == 0 || rect.size.height == 0) continue;</div><div class="line">            </div><div class="line">            if (CGRectContainsPoint(rect, point)) &#123; // 点中了某个特殊字符串</div><div class="line">                contains = YES;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        if (contains) &#123;</div><div class="line">            for (UITextSelectionRect *selectionRect in rects) &#123;</div><div class="line">                CGRect rect = selectionRect.rect;</div><div class="line">                if (rect.size.width == 0 || rect.size.height == 0) continue;</div><div class="line">                </div><div class="line">                UIView *cover = [[UIView alloc] init];</div><div class="line">                cover.backgroundColor = [UIColor greenColor];</div><div class="line">                cover.frame = rect;</div><div class="line">                cover.tag = ZLStatusTextViewCoverTag;</div><div class="line">                cover.layer.cornerRadius = 5;</div><div class="line">                [self insertSubview:cover atIndex:0];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 在被触摸的特殊字符串后面显示一段高亮的背景</div><div class="line">&#125;</div><div class="line">- (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(0.25 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</div><div class="line">        // 触摸对象</div><div class="line">        UITouch *touch = [touches anyObject];</div><div class="line">        </div><div class="line">        // 触摸点</div><div class="line">        CGPoint point = [touch locationInView:self];</div><div class="line">        </div><div class="line">        NSArray *specials = [self.attributedText attribute:@&quot;specials&quot; atIndex:0 effectiveRange:NULL];</div><div class="line">        BOOL contains = NO;</div><div class="line">        </div><div class="line">        for (ZLSpecial *special in specials) &#123;</div><div class="line">            self.selectedRange = special.range;</div><div class="line">            // self.selectedRange --影响--&gt; self.selectedTextRange</div><div class="line">            // 获得选中范围的矩形框</div><div class="line">            NSArray *rects = [self selectionRectsForRange:self.selectedTextRange];</div><div class="line">            // 清空选中范围</div><div class="line">            self.selectedRange = NSMakeRange(0, 0);</div><div class="line">            </div><div class="line">            for (UITextSelectionRect *selectionRect in rects) &#123;</div><div class="line">                CGRect rect = selectionRect.rect;</div><div class="line">                if (rect.size.width == 0 || rect.size.height == 0) continue;</div><div class="line">                </div><div class="line">                if (CGRectContainsPoint(rect, point)) &#123; // 点中了某个特殊字符串</div><div class="line">                    contains = YES;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            if (contains) &#123;</div><div class="line">                for (UITextSelectionRect *selectionRect in rects) &#123;</div><div class="line">                    CGRect rect = selectionRect.rect;</div><div class="line">                    if (rect.size.width == 0 || rect.size.height == 0) continue;</div><div class="line">                    </div><div class="line">                    if (special.urlString) &#123;</div><div class="line">                        NSString *urlStr = special.urlString;</div><div class="line">                        NSURL *url =[NSURL URLWithString:urlStr];</div><div class="line">                        if (url.scheme) &#123;</div><div class="line">                            [[UIApplication sharedApplication]openURL:url];</div><div class="line">                        &#125;else&#123;</div><div class="line">                            NSMutableString *str=[[NSMutableString alloc] initWithFormat:@&quot;tel:%@&quot;,special.text];</div><div class="line">                            UIWebView *callWebview = [[UIWebView alloc] init];</div><div class="line">                            [callWebview loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:str]]];</div><div class="line">                            [self addSubview:callWebview];</div><div class="line">                    &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        [self touchesCancelled:touches withEvent:event];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    // 去掉特殊字符串后面的高亮背景</div><div class="line">    for (UIView *child in self.subviews) &#123;</div><div class="line">        if (child.tag == ZLStatusTextViewCoverTag) [child removeFromSuperview];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">-(void)setZlFrame:(ZLFrame *)zlFrame&#123;</div><div class="line">    _zlFrame = zlFrame;</div><div class="line">    self.attributedText = zlFrame.status.attributedText;</div><div class="line">    self.frame = zlFrame.contentLabelF;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)setMaxLine:(int)maxLine&#123;</div><div class="line">    _maxLine = maxLine;</div><div class="line">    [self.zlFrame setMaxNumLine:maxLine];</div><div class="line">    self.frame = self.zlFrame.maxNumLabelF;</div><div class="line">&#125;</div><div class="line">-(void)setIsShowAll:(BOOL)isShowAll&#123;</div><div class="line">    _isShowAll = isShowAll;</div><div class="line">    if (isShowAll) &#123;</div><div class="line">        self.frame = self.zlFrame.contentLabelF;</div><div class="line"></div><div class="line">    &#125;else&#123;</div><div class="line">        [self setMaxLine:3];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<blockquote>
<p>最后在ViewController里引入即可：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &quot;ZLStatusTextView.h&quot;</div><div class="line">#define kTempText  @&quot;简书：http://jianshu.com哈哈哈[调皮][流汗][偷笑][再见][可爱][色][害羞][委屈][委屈][抓狂][酷][酷][嘘][嘘][龇牙][大哭][大哭][大哭][龇牙][嘘][嘘][调皮][调皮]哈哈哈哈[嘘][调皮][调皮]18637963241他大舅他二舅都是舅，高桌子地板头都是木头&quot;</div><div class="line">#define  KURlREGULAR @&quot;((http[s]&#123;0,1&#125;|ftp)://[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]&#123;2,4&#125;)(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(www.[a-zA-Z0-9\\.\\-]+\\.([a-zA-Z]&#123;2,4&#125;)(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)|(((http[s]&#123;0,1&#125;|ftp)://|)((?:(?:25[0-5]|2[0-4]\\d|((1\\d&#123;2&#125;)|([1-9]?\\d)))\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|((1\\d&#123;2&#125;)|([1-9]?\\d))))(:\\d+)?(/[a-zA-Z0-9\\.\\-~!@#$%^&amp;*+?:_/=&lt;&gt;]*)?)&quot;</div><div class="line">#define KPHONENUMBERREGLAR @&quot;\\d&#123;3&#125;-\\d&#123;8&#125;|\\d&#123;3&#125;-\\d&#123;7&#125;|\\d&#123;4&#125;-\\d&#123;8&#125;|\\d&#123;4&#125;-\\d&#123;7&#125;|1+[3578]+\\d&#123;9&#125;|\\d&#123;8&#125;|\\d&#123;7&#125;&quot;</div><div class="line">#import &quot;ZLStatus.h&quot;</div><div class="line">#import &quot;ZLFrame.h&quot;</div><div class="line">#import &quot;LxButton.h&quot;</div><div class="line">@interface ViewController ()&lt;UITextViewDelegate&gt;</div><div class="line">@property(nonatomic,strong)ZLStatusTextView *textview;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // Do any additional setup after loading the view, typically from a nib.</div><div class="line">    </div><div class="line">    self.textview =[[ZLStatusTextView alloc]initWithFrame:CGRectMake(20, 100, 250, 200)];</div><div class="line">    ZLStatus *status = [[ZLStatus alloc]init];</div><div class="line">    status.text = kTempText;</div><div class="line">   </div><div class="line">   </div><div class="line">    ZLFrame *zlFrame =[[ZLFrame alloc]init];</div><div class="line">    zlFrame.frameX = self.textview.frame.origin.x;</div><div class="line">    zlFrame.frameY = self.textview.frame.origin.y;</div><div class="line">    zlFrame.maxWidth = self.textview.frame.size.width;</div><div class="line">    zlFrame.status = status;</div><div class="line">    </div><div class="line">    self.textview.zlFrame = zlFrame;</div><div class="line">    //设置最大行数用于展开</div><div class="line">    self.textview.maxLine = 3;</div><div class="line">    self.textview.isShowAll = YES;</div><div class="line">    [self.view addSubview:self.textview];</div><div class="line">    self.textview.backgroundColor =[UIColor lightGrayColor];</div><div class="line">   </div><div class="line">  </div><div class="line">    LxButton *button =[LxButton LXButtonWithTitle:@&quot;限制最大行数&quot; titleFont:[UIFont systemFontOfSize:15] Image:nil backgroundImage:nil backgroundColor:[UIColor brownColor] titleColor:[UIColor blueColor] frame:CGRectMake(20, 40, 150, 40)];</div><div class="line">    </div><div class="line">    [self.view addSubview:button];</div><div class="line">    __weak ViewController *weakSelf = self;</div><div class="line">    [button addClickBlock:^(UIButton *button) &#123;</div><div class="line">       </div><div class="line">        weakSelf.textview.isShowAll =!weakSelf.textview.isShowAll;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
<p>demo地址：<a href="https://github.com/liuxinixn/LXRegularTextview/tree/master" target="_blank" rel="noopener">富文本检索表情，网址，替换链接，限制最大输入行</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之CAEmitterLayer(粒子破碎动画)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之CAEmitterLayer(粒子破碎动画)/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。<br>CAEmitterLayer看上去像是许多CAEmitterCell的容器，这些CAEmitierCell定义了一个例子效果。你将会为不同的例子效果定义一个或多个CAEmitterCell作为模版，同时CAEmitterLayer负责基于这些模版实例化一个粒子流。一个CAEmitterCell类似于一个CALayer：它有一个contents属性可以定义为一个CGImage，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在CAEmitterCell类的头文件中找到。</p>
<blockquote>
<p><strong> CAEmitterLayer类提供了一个粒子发射器系统为核心的动画。这些粒子是由CAEmitterCell组成的实例，它相当于一个管理者，来管理 CAEmitterCell的发射的一些细节，比如发射的位置，发射形状等等</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">emitterPosition</td>
<td style="text-align:center">发射位置</td>
</tr>
<tr>
<td style="text-align:center">emitterSize</td>
<td style="text-align:center">发射源的大小</td>
</tr>
<tr>
<td style="text-align:center">emitterMode</td>
<td style="text-align:center">发射模式</td>
</tr>
<tr>
<td style="text-align:center">emitterShape</td>
<td style="text-align:center">发射源的形状</td>
</tr>
<tr>
<td style="text-align:center">renderMode</td>
<td style="text-align:center">渲染模式</td>
</tr>
<tr>
<td style="text-align:center">birthRate</td>
<td style="text-align:center">粒子产生系数，默认1.0</td>
</tr>
<tr>
<td style="text-align:center">emitterCells</td>
<td style="text-align:center">装着CAEmitterCell对象的数组，被用于把粒子投放到layer上</td>
</tr>
<tr>
<td style="text-align:center">emitterDepth</td>
<td style="text-align:center">决定粒子形状的深度联系</td>
</tr>
<tr>
<td style="text-align:center">emitterZposition</td>
<td style="text-align:center">发射源的z坐标位置</td>
</tr>
<tr>
<td style="text-align:center">lifetime</td>
<td style="text-align:center">粒子生命周期</td>
</tr>
<tr>
<td style="text-align:center">scale</td>
<td style="text-align:center">粒子的缩放比例</td>
</tr>
<tr>
<td style="text-align:center">seed</td>
<td style="text-align:center">用于初始化随机数产生的种子</td>
</tr>
<tr>
<td style="text-align:center">spin</td>
<td style="text-align:center">自旋转速度</td>
</tr>
<tr>
<td style="text-align:center">velocity</td>
<td style="text-align:center">粒子速度</td>
</tr>
</tbody>
</table>
<blockquote>
<p>CAEmitterCell属性 </p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">alphaRange</td>
<td style="text-align:center">一个粒子的颜色alpha能改变的范围</td>
</tr>
<tr>
<td style="text-align:center">alphaSpeed</td>
<td style="text-align:center">粒子透明度在生命周期内的改变速度</td>
</tr>
<tr>
<td style="text-align:center">birthrate</td>
<td style="text-align:center">每秒发射的粒子数量</td>
</tr>
<tr>
<td style="text-align:center">blueRange     一个粒子的颜色blue 能改变的范围</td>
</tr>
<tr>
<td style="text-align:center">blueSpeed</td>
<td style="text-align:center">粒子blue在生命周期内的改变速度</td>
</tr>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">粒子的颜色</td>
</tr>
<tr>
<td style="text-align:center">contents</td>
<td style="text-align:center">是个CGImageRef的对象,既粒子要展现的图片</td>
</tr>
<tr>
<td style="text-align:center">contentsRect</td>
<td style="text-align:center">应该画在contents里的子rectangle</td>
</tr>
<tr>
<td style="text-align:center">emissionLatitude</td>
<td style="text-align:center">发射的z轴方向的角度</td>
</tr>
<tr>
<td style="text-align:center">emissionLongitude</td>
<td style="text-align:center">x-y平面的发射方向</td>
</tr>
<tr>
<td style="text-align:center">emissionRange</td>
<td style="text-align:center">周围发射角度</td>
</tr>
<tr>
<td style="text-align:center">emitterCells</td>
<td style="text-align:center">粒子发射的粒子的数组</td>
</tr>
<tr>
<td style="text-align:center">enabled</td>
<td style="text-align:center">粒子是否被渲染</td>
</tr>
<tr>
<td style="text-align:center">greenrange</td>
<td style="text-align:center">一个粒子的颜色green 能改变的范围</td>
</tr>
<tr>
<td style="text-align:center">greenSpeed</td>
<td style="text-align:center">粒子green在生命周期内的改变速度</td>
</tr>
<tr>
<td style="text-align:center">lifetime</td>
<td style="text-align:center">生命周期</td>
</tr>
<tr>
<td style="text-align:center">lifetimeRange</td>
<td style="text-align:center">生命周期范围 lifetime= lifetime(+/-) lifetimeRange</td>
</tr>
<tr>
<td style="text-align:center">magnificationFilter</td>
<td style="text-align:center">增加自己的大小</td>
</tr>
<tr>
<td style="text-align:center">minificatonFilter</td>
<td style="text-align:center">减小自己的大小</td>
</tr>
<tr>
<td style="text-align:center">minificationFilterBias</td>
<td style="text-align:center">减小大小的因子</td>
</tr>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">粒子的名字</td>
</tr>
<tr>
<td style="text-align:center">redRange</td>
<td style="text-align:center">一个粒子的颜色red 能改变的范围</td>
</tr>
<tr>
<td style="text-align:center">redSpeed</td>
<td style="text-align:center">粒子red在生命周期内的改变速度</td>
</tr>
<tr>
<td style="text-align:center">scale</td>
<td style="text-align:center">缩放比例</td>
</tr>
<tr>
<td style="text-align:center">scaleRange</td>
<td style="text-align:center">缩放比例范围</td>
</tr>
<tr>
<td style="text-align:center">scaleSpeed</td>
<td style="text-align:center">缩放比例速度</td>
</tr>
<tr>
<td style="text-align:center">spin</td>
<td style="text-align:center">子旋转角度</td>
</tr>
<tr>
<td style="text-align:center">spinrange</td>
<td style="text-align:center">子旋转角度范围</td>
</tr>
<tr>
<td style="text-align:center">velocity</td>
<td style="text-align:center">速度</td>
</tr>
<tr>
<td style="text-align:center">velocityRange</td>
<td style="text-align:center">速度范围</td>
</tr>
<tr>
<td style="text-align:center">xAcceleration</td>
<td style="text-align:center">粒子x方向的加速度分量</td>
</tr>
<tr>
<td style="text-align:center">yAcceleration</td>
<td style="text-align:center">粒子y方向的加速度分量</td>
</tr>
<tr>
<td style="text-align:center">zAcceleration</td>
<td style="text-align:center">粒子z方向的加速度分量</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@interface ViewController () </div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView; </div><div class="line">@end </div><div class="line">@implementation ViewController </div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line"> [super viewDidLoad]; </div><div class="line">//create particle emitter layer </div><div class="line">CAEmitterLayer *emitter = [CAEmitterLayer layer];</div><div class="line"> emitter.frame = self.containerView.bounds; [self.containerView.layer addSublayer:emitter]; </div><div class="line">//configure emitter emitter.renderMode = kCAEmitterLayerAdditive; </div><div class="line">emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0); </div><div class="line">//create a particle template </div><div class="line">CAEmitterCell *cell = [[CAEmitterCell alloc] init]; </div><div class="line">cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage; cell.birthRate = 150; </div><div class="line">cell.lifetime = 5.0;</div><div class="line"> cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor; </div><div class="line">cell.alphaSpeed = -0.4; </div><div class="line">cell.velocity = 50;</div><div class="line"> cell.velocityRange = 50; </div><div class="line">cell.emissionRange = M_PI * 2.0; //add particle template to emitter emitter.emitterCells = @[cell]; </div><div class="line">&#125; </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>#####点赞的破碎动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">self.view.backgroundColor =[UIColor whiteColor];</div><div class="line"></div><div class="line">self.container =[[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 30)];</div><div class="line">self.container.layer.contents = (__bridge id)[UIImage imageNamed:@&quot;点赞2&quot;].CGImage;</div><div class="line">self.container.center = self.view.center;</div><div class="line">[self.view addSubview:self.container];</div><div class="line">CAEmitterCell *emitterCell = [CAEmitterCell emitterCell];</div><div class="line">emitterCell.name           = @&quot;emitter&quot;;</div><div class="line">emitterCell.alphaRange     = 0.10;</div><div class="line">emitterCell.alphaSpeed     = -1.0;</div><div class="line">emitterCell.lifetime       = 0.6;</div><div class="line">emitterCell.lifetimeRange  = 0.3;</div><div class="line">emitterCell.birthRate      = 0;</div><div class="line">emitterCell.velocity       = 40.00;</div><div class="line">emitterCell.velocityRange  = 10.00;</div><div class="line">emitterCell.scale          = 0.03;</div><div class="line">emitterCell.scaleRange     = 0.02;</div><div class="line">emitterCell.contents       = (id)[UIImage imageNamed:@&quot;Emitter&quot;].CGImage;</div><div class="line"></div><div class="line"> self.emitterLayer               = [CAEmitterLayer layer];</div><div class="line"> self.emitterLayer.name          = @&quot;emitterLayer&quot;;</div><div class="line"> self.emitterLayer.emitterShape  = kCAEmitterLayerCircle;</div><div class="line"> self.emitterLayer.emitterMode   = kCAEmitterLayerOutline;</div><div class="line"> self.emitterLayer.emitterSize   = CGSizeMake(20, 20);</div><div class="line"> self.emitterLayer.emitterCells  = @[emitterCell];</div><div class="line"> self.emitterLayer.renderMode    = kCAEmitterLayerAdditive;</div><div class="line"> self.emitterLayer.masksToBounds = NO;</div><div class="line"> self.emitterLayer.position      = CGPointMake(self.container.frame.size.width/2.0,self.container.frame.size.height/2.0);</div><div class="line"></div><div class="line">[self.container.layer addSublayer:self.emitterLayer];</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CAShapeLayer与UIBezierPath实现注水动画与正余弦水波纹动画,雷达扩散效果，添加购物车动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CAShapeLayer与UIBezierPath实现注水动画与正余弦水波纹动画,雷达扩散效果，添加购物车动画/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>初步学习了CoreAnimation框架，总结了几个动画效果，主要是通过CAShapeLayer与贝塞尔曲线实现。<br>推荐一个大神的博客：<a href="http://kittenyang.com/" target="_blank" rel="noopener">Kitten 的时间胶囊</a>,爱好动画的可以看看。感觉数学好渣渣，是时候恶补一下了<br>先看下效果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-729daa88f1ae1a23.gif?imageMogr2/auto-orient/strip" alt="gif.gif"></p>
<blockquote>
<p>#####<strong>扇形下载进度</strong></p>
</blockquote>
<p>要实现扇形的下载进度，有两种方法， 这里先使用第一种：<br>1.使用设置UIBezierPath的角度<br>2.使用 CAShapeLayer的stokeEnd属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//设置中心点</div><div class="line">  CGPoint point = CGPointMake(self.frame.size.width/2, self.frame.size.height/2);</div><div class="line">  </div><div class="line">  //起点位置</div><div class="line">  CGFloat startAngle = - M_PI /2;</div><div class="line">  </div><div class="line">  //结束位置</div><div class="line">  CGFloat endAngle = self.progress *M_PI *2 + startAngle;</div><div class="line">  </div><div class="line">  </div><div class="line">  UIBezierPath *path =[UIBezierPath bezierPathWithArcCenter:point radius:self.bounds.size.width/2 startAngle:startAngle endAngle:endAngle clockwise:1];</div><div class="line">  </div><div class="line">   //画一根到 圆心的线</div><div class="line">  [path addLineToPoint:point];</div><div class="line">  </div><div class="line">  </div><div class="line">  //通过layer绘制</div><div class="line">  CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">  </div><div class="line">  </div><div class="line">  layer.path = path.CGPath;</div><div class="line">  </div><div class="line">  layer.fillColor =[UIColor colorWithRed:0.47 green:0.83 blue:0.98 alpha:1].CGColor;</div><div class="line">  </div><div class="line">  [self.layer addSublayer:layer];</div></pre></td></tr></table></figure></p>
<blockquote>
<h5 id="圆形进度"><a href="#圆形进度" class="headerlink" title="圆形进度"></a><strong>圆形进度</strong></h5></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">首先 我们需要一个背景层 一个前景层，一个路径供给两个layer使用。这里我们使用改变stokeEnd 来改变圆弧的进度，代码里增加了一点渐变</div><div class="line">   self.backLayer =[CAShapeLayer layer];</div><div class="line">    self.backLayer.fillColor  =[UIColor clearColor].CGColor;</div><div class="line">    self.backLayer.frame = self.bounds;</div><div class="line">    self.backLayer.lineWidth = 4;</div><div class="line">    self.backLayer.strokeColor =[UIColor lightGrayColor].CGColor;</div><div class="line">    [self.layer addSublayer:self.backLayer];</div><div class="line">    </div><div class="line">    self.foreLayer =[CAShapeLayer layer];</div><div class="line">    self.foreLayer.fillColor  =[UIColor clearColor].CGColor;</div><div class="line">    self.foreLayer.frame = self.bounds;</div><div class="line">    self.foreLayer.strokeColor =[UIColor redColor].CGColor;</div><div class="line">    self.foreLayer.lineWidth = 4;</div><div class="line">    [self.layer addSublayer:self.foreLayer];</div><div class="line">    </div><div class="line">    </div><div class="line">    UIBezierPath *path=  [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2) radius:self.bounds.size.width/2-2 startAngle:-M_PI_2 endAngle:M_PI *1.5 clockwise:YES];</div><div class="line">    self.backPath = path;</div><div class="line">    </div><div class="line">    self.backLayer.path = self.backPath.CGPath;</div><div class="line">    self.foreLayer.path = self.backPath.CGPath;</div><div class="line">    self.foreLayer.strokeEnd = 0;</div><div class="line">    </div><div class="line">    </div><div class="line">    self.gradientLayerLeft =[CAGradientLayer layer];</div><div class="line">    self.gradientLayerLeft.frame = self.bounds;</div><div class="line">    </div><div class="line">    self.gradientLayerLeft.colors =@[(__bridge id)[UIColor redColor].CGColor,(__bridge id)[UIColor yellowColor].CGColor,(__bridge id)[UIColor blueColor].CGColor];</div><div class="line">    self.gradientLayerLeft.locations = @[@0,@0.5,@1];</div><div class="line">    self.gradientLayerLeft.startPoint = CGPointMake(0, 0);</div><div class="line">    self.gradientLayerLeft.endPoint = CGPointMake(0, 1);</div><div class="line">    [self.layer addSublayer:self.gradientLayerLeft];</div><div class="line">  </div><div class="line">    </div><div class="line">    //设置mask</div><div class="line">    [self.gradientLayerLeft setMask:self.foreLayer];</div><div class="line">-(void)setProgressValue:(CGFloat)progressValue</div><div class="line">&#123;</div><div class="line">    _progressValue = progressValue;</div><div class="line">    self.foreLayer.strokeEnd = progressValue;</div><div class="line">    self.label.text = [NSString stringWithFormat:@&quot;%.f%%&quot;,progressValue *100];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> #####<strong>一个加载动画</strong></p>
</blockquote>
<p>引自：<a href="http://www.jianshu.com/p/447b0de110a7" target="_blank" rel="noopener">旋转加载动画</a><br>可以重点学习下做动画的思路，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//核心代码 在动画开始的时候做一些平移旋转</div><div class="line">- (void)animationDidStart:(CAAnimation *)anim&#123;</div><div class="line">    [UIView animateWithDuration:0.3 delay:0.1 options:UIViewAnimationOptionCurveEaseOut|UIViewAnimationOptionBeginFromCurrentState animations:^&#123;</div><div class="line">        </div><div class="line">        self.ball_1.transform = CGAffineTransformMakeTranslation(-BALL_RADIUS, 0);</div><div class="line">        self.ball_1.transform = CGAffineTransformScale(self.ball_1.transform, 0.7, 0.7);</div><div class="line">        </div><div class="line">        self.ball_3.transform = CGAffineTransformMakeTranslation(BALL_RADIUS, 0);</div><div class="line">        self.ball_3.transform = CGAffineTransformScale(self.ball_3.transform, 0.7, 0.7);</div><div class="line">        </div><div class="line">        </div><div class="line">        self.ball_2.transform = CGAffineTransformScale(self.ball_2.transform, 0.7, 0.7);</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [UIView animateWithDuration:0.3 delay:0.1 options:UIViewAnimationOptionCurveEaseIn  | UIViewAnimationOptionBeginFromCurrentState animations:^&#123;</div><div class="line">            self.ball_1.transform = CGAffineTransformIdentity;</div><div class="line">            self.ball_3.transform = CGAffineTransformIdentity;</div><div class="line">            self.ball_2.transform = CGAffineTransformIdentity;</div><div class="line">        &#125; completion:NULL];</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>#####<strong>使用正余弦做的注水动画</strong></p>
</blockquote>
<p>在使用正余弦做注水动画时，先了解下正余弦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 正弦曲线公式可表示为y=Asin(ωx+φ)+k：</div><div class="line"> A，振幅，最高和最低的距离</div><div class="line"> W，角速度，用于控制周期大小，单位x中的起伏个数</div><div class="line"> K，偏距，曲线整体上下偏移量</div><div class="line"> φ，初相，左右移动的值</div><div class="line"> </div><div class="line"> 这个效果主要的思路是添加两条曲线 一条正玄曲线、一条余弦曲线 然后在曲线下添加深浅不同的背景颜色，从而达到波浪显示的效果</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>我们要做的 就是使用两条正余弦，但是这两条正余弦， 波峰需要对应波谷，有两种方法：</p>
<ol>
<li>使用for循环分别拼接正余弦的路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">-(void)updateWave</div><div class="line">&#123;</div><div class="line">    //波浪宽度</div><div class="line">    CGFloat waterWaveWidth = self.bounds.size.width;</div><div class="line">    //初始化运动路径</div><div class="line">    CGMutablePathRef path = CGPathCreateMutable();</div><div class="line">    </div><div class="line">    CGMutablePathRef maskPath = CGPathCreateMutable();</div><div class="line">    //设置起始位置</div><div class="line">    CGPathMoveToPoint(path, nil, 0, _waveY);</div><div class="line">    </div><div class="line">    //设置起始位置</div><div class="line">    CGPathMoveToPoint(maskPath, nil, 0, _waveY);</div><div class="line">    //初始化波浪其实Y为偏距</div><div class="line">    CGFloat y = _waveY;</div><div class="line">  </div><div class="line">    //正弦曲线公式为： y=Asin(ωx+φ)+k;</div><div class="line">    for (float x = 0.0f; x &lt;= waterWaveWidth ; x++) &#123;</div><div class="line">        y = _waveAmplitude * sin(_wavePalstance * x + _waveX) + _waveY;</div><div class="line">       </div><div class="line">        CGPathAddLineToPoint(path, nil, x, y);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    for (float x = 0.0f; x &lt;= waterWaveWidth ; x++) &#123;</div><div class="line">        y = _waveAmplitude * cos(_wavePalstance * x + _waveX) + _waveY;</div><div class="line">       </div><div class="line">        CGPathAddLineToPoint(maskPath, nil, x, y);</div><div class="line">    &#125;</div><div class="line">    [self updateLayer:_waveLayer1 path:path];</div><div class="line">    [self updateLayer:_waveLayer2 path:maskPath];</div><div class="line"></div><div class="line">&#125;</div><div class="line">-(void)updateLayer:(CAShapeLayer *)layer path:(CGMutablePathRef )path</div><div class="line">&#123;</div><div class="line">    //填充底部颜色</div><div class="line">    CGFloat waterWaveWidth = self.bounds.size.width;</div><div class="line">    CGPathAddLineToPoint(path, nil, waterWaveWidth, self.bounds.size.height);</div><div class="line">    CGPathAddLineToPoint(path, nil, 0, self.bounds.size.height);</div><div class="line">    CGPathCloseSubpath(path);</div><div class="line">    layer.path = path;</div><div class="line">     CGPathRelease(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.使用单个for循环只是 设置 另一条曲线的y值相反即可实现两条正余弦的效果 ，最后一个动画中会有说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (int x = 0; x&lt;WIDTH; x++) &#123;</div><div class="line">       y = waveHeight*sinf(0.01*waveCurvature*x+offSetValue*0.045);</div><div class="line">       CGPathAddLineToPoint(path, nil, x, y);</div><div class="line">       //遮罩层的路径与之相反</div><div class="line">       masky = -y;</div><div class="line">       CGPathAddLineToPoint(maskPath, nil, x, masky);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><strong>但是</strong>我们有个需求就是改变 波浪的高度， 实现注水的百分比，就需要设置波浪的偏距<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(void)updateWaveY</div><div class="line">&#123;</div><div class="line">    CGFloat targetY = self.bounds.size.height - _progress * self.bounds.size.height;</div><div class="line">    if (_waveY &lt; targetY) &#123;</div><div class="line">        _waveY += 2;</div><div class="line">    &#125;</div><div class="line">    if (_waveY &gt; targetY ) &#123;</div><div class="line">        _waveY -= 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>#####<strong>正余弦动画2</strong> </p>
</blockquote>
<p>如果有个需求 ，比如一个小船 随着波浪的波动而起伏<br>那我们就需要计算 波浪的位置，然后设置小船的frame<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//这里使用创建正余弦的第二种方法</div><div class="line">    for (int x = 0; x&lt;WIDTH; x++) &#123;</div><div class="line">        y = waveHeight*sinf(0.01*waveCurvature*x+offSetValue*0.045);</div><div class="line">        CGPathAddLineToPoint(path, nil, x, y);</div><div class="line">        //遮罩层的路径与之相反</div><div class="line">        masky = -y;</div><div class="line">        CGPathAddLineToPoint(maskPath, nil, x, masky);</div><div class="line">    &#125;</div><div class="line">计算出实浪波动时，最中间的位置，设置小船的frame</div><div class="line">  CGFloat CentY = waveHeight*sinf(0.01*waveCurvature*WIDTH/2+offSetValue*0.045);</div><div class="line">    CGRect boardViewFrame = [boardView frame];</div><div class="line">    boardViewFrame.origin.y = 100-waveHeight+CentY;</div><div class="line">    boardView.frame = boardViewFrame;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>雷达动画</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-4dfc88e76fa8a370.gif?imageMogr2/auto-orient/strip" alt="gif.gif"></p>
<p>给UIView添加一个分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface UIView (RadarAnimation)</div><div class="line"></div><div class="line">@property(nonatomic,strong)UIColor *radarColor; //扩散颜色</div><div class="line">@property(nonatomic,assign)UIColor *radarBorderColor; //扩散边界颜色</div><div class="line">-(void)addRadarAnimation;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.radarColor = LBColor(237, 174, 130, 1);</div><div class="line">button.radarBorderColor = LBColor(237, 174, 130, 0.5);</div><div class="line"> [button addRadarAnimation];</div></pre></td></tr></table></figure></p>
<p>动画:添加动画的方法,创建三个layer，只不过，开始动画的时间要错开形成这个效果：：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">-(void)Animation&#123;</div><div class="line">    NSInteger pulsingCount = 3;</div><div class="line">    double animationDuration = 2;</div><div class="line"></div><div class="line">    CALayer * animationLayer = [[CALayer alloc]init];</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; pulsingCount; i++) &#123;</div><div class="line">        CALayer * pulsingLayer = [[CALayer alloc]init];</div><div class="line">        pulsingLayer.frame = CGRectMake(0, 0, self.frame.size.width, self.frame.size.height);</div><div class="line">        pulsingLayer.backgroundColor = self.radarColor.CGColor;</div><div class="line">        pulsingLayer.borderColor = self.radarBorderColor.CGColor;</div><div class="line"></div><div class="line"></div><div class="line">        pulsingLayer.borderWidth = 1.0;</div><div class="line">        pulsingLayer.cornerRadius = self.frame.size.height/2;</div><div class="line"></div><div class="line">        CAMediaTimingFunction * defaultCurve = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line"></div><div class="line">        CAAnimationGroup * animationGroup = [[CAAnimationGroup alloc]init];</div><div class="line">        animationGroup.fillMode = kCAFillModeBoth;</div><div class="line">        animationGroup.beginTime = CACurrentMediaTime() + (double)i * animationDuration/(double)pulsingCount;</div><div class="line">        animationGroup.duration = animationDuration;</div><div class="line">        animationGroup.repeatCount = HUGE_VAL;</div><div class="line">        animationGroup.timingFunction = defaultCurve;</div><div class="line"></div><div class="line">        CABasicAnimation * scaleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</div><div class="line">        scaleAnimation.autoreverses = NO;</div><div class="line">        scaleAnimation.fromValue = [NSNumber numberWithDouble:1];</div><div class="line">        scaleAnimation.toValue = [NSNumber numberWithDouble:1.5];</div><div class="line"></div><div class="line">        CAKeyframeAnimation * opacityAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];</div><div class="line">        opacityAnimation.values = @[[NSNumber numberWithDouble:1.0],[NSNumber numberWithDouble:0.5],[NSNumber numberWithDouble:0.3],[NSNumber numberWithDouble:0.0]];</div><div class="line">        opacityAnimation.keyTimes = @[[NSNumber numberWithDouble:0.0],[NSNumber numberWithDouble:0.25],[NSNumber numberWithDouble:0.5],[NSNumber numberWithDouble:1.0]];</div><div class="line">        animationGroup.animations = @[scaleAnimation,opacityAnimation];</div><div class="line"></div><div class="line">        [pulsingLayer addAnimation:animationGroup forKey:@&quot;pulsing&quot;];</div><div class="line">        [animationLayer addSublayer:pulsingLayer];</div><div class="line">    &#125;</div><div class="line">        animationLayer.zPosition = -1;//重新加载时，使动画至底层</div><div class="line">    [self.layer addSublayer:animationLayer];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>爱奇艺旋转动画，说白了还是监听stokeStart stokeEnd做动画效果。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-2394fa45a2af03ef.gif?imageMogr2/auto-orient/strip" alt="  爱奇艺动画.gif"></p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">-(void)setUp&#123;</div><div class="line">    </div><div class="line">    CGPoint point =  CGPointMake(self.width/2, self.height/2);</div><div class="line">    UIBezierPath *path =[UIBezierPath bezierPathWithArcCenter:point radius:(self.width - 1)/2 startAngle:-0.5 *M_PI endAngle:1.5 *M_PI clockwise:YES];</div><div class="line"></div><div class="line">    self.shapeLayer =[[CAShapeLayer alloc]init];</div><div class="line">    self.shapeLayer.frame = self. bounds;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeColor = [UIColor hexStringToColor:@&quot;#94BF3F&quot;].CGColor;</div><div class="line">    self.shapeLayer.fillColor =[UIColor clearColor].CGColor;</div><div class="line">    self.shapeLayer.lineWidth = 1;</div><div class="line">    self.shapeLayer.lineCap = kCALineCapRound;</div><div class="line">    </div><div class="line"> </div><div class="line">    self.shapeLayer.path = path.CGPath;</div><div class="line">    </div><div class="line">    [self.layer addSublayer:self.shapeLayer];</div><div class="line">    </div><div class="line">    </div><div class="line">  </div><div class="line">    self.imageView =[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 9, 9)];</div><div class="line">    self.imageView.center = point;</div><div class="line">    self.imageView.image =[UIImage imageNamed:@&quot;三角形&quot;];</div><div class="line">    </div><div class="line">    [self addSubview:self.imageView];</div><div class="line">    [self animationOne];</div><div class="line"></div><div class="line">&#125;</div><div class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</div><div class="line">    if ([[anim valueForKey:@&quot;animationName&quot;] isEqualToString:@&quot;AnimationEnd&quot;]) &#123;</div><div class="line">        </div><div class="line">        [self animationTwo];</div><div class="line">        [self rotationAnimation];</div><div class="line">    &#125;</div><div class="line">    if ([[anim valueForKey:@&quot;animationName&quot;] isEqualToString:@&quot;AnimationStart&quot;]) &#123;</div><div class="line">        </div><div class="line">   </div><div class="line">        [self.shapeLayer removeAllAnimations];</div><div class="line">        [self animationOne];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)animationOne&#123;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeStart=0;</div><div class="line">    //设置strokeEnd的最终值，动画的fromValue为0，strokeEnd的最终值为0.98</div><div class="line">    self.shapeLayer.strokeEnd=0.98;</div><div class="line">    CABasicAnimation *basicAnimationOne=[CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</div><div class="line">    basicAnimationOne.fromValue=@(0);</div><div class="line">    </div><div class="line">    basicAnimationOne.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    basicAnimationOne.delegate=self;</div><div class="line">    [basicAnimationOne setValue:@&quot;AnimationEnd&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line">    [self.shapeLayer addAnimation:basicAnimationOne forKey:@&quot;animationName&quot;];</div><div class="line">&#125;</div><div class="line">-(void)animationTwo&#123;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeStart = 0.98;</div><div class="line">    CABasicAnimation *basicAnimationTwo=[CABasicAnimation animationWithKeyPath:@&quot;strokeStart&quot;];</div><div class="line">    basicAnimationTwo.fromValue=@(0);</div><div class="line">    </div><div class="line">    basicAnimationTwo.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    basicAnimationTwo.delegate=self;</div><div class="line">    [basicAnimationTwo setValue:@&quot;AnimationStart&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line"></div><div class="line">    [self.shapeLayer addAnimation:basicAnimationTwo forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)rotationAnimation&#123;</div><div class="line">    CABasicAnimation *rotationAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">    </div><div class="line">    rotationAnimation.toValue=@(M_PI*2);</div><div class="line">    rotationAnimation.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    rotationAnimation.delegate=self;</div><div class="line">    [rotationAnimation setValue:@&quot;AnimationRotation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    [self.imageView.layer addAnimation:rotationAnimation forKey:@&quot;AnimationRotation&quot;];</div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初学动画，参考很多文章，做个小小总结。<br>demo地址 <a href="https://github.com/liuxinixn/ProgressViewDemo" target="_blank" rel="noopener">demo集合</a></p>
<p>另外一个加入购物车的小动画：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-37a8d72c7ff0562c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimation</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    </div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(_endPoint.x, _startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:_startPoint];</div><div class="line">    [path addQuadCurveToPoint:_endPoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [_viewController.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    [_shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/a9a4c51aef13" target="_blank" rel="noopener">贝塞尔曲线（加入购物车动画）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之maskLayer使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之maskLayer使用/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>demo 地址：<a href="https://github.com/liuxinixn/MaskLayer" target="_blank" rel="noopener">MaskLayer使用</a><br><img src="http://upload-images.jianshu.io/upload_images/1694376-979ecf2a4a198745.gif?imageMogr2/auto-orient/strip" alt="1.gif"><br>因为初学动画的缘故，对mask 蒙版理解不是很到位。</p>
<p> demo中的三个例子效果其实都是有<strong>前景和背景图视图，mask只是加在前景视图上</strong>，在使用mask的时候，会直接覆盖掉被遮盖图层（如果frame 与被覆盖层相同的话），然后我们可以通过改变mask layer 的一些属性做一些动画。</p>
<blockquote>
<p>首先看下 ❤️ 形的注水效果 </p>
</blockquote>
<p><strong>1</strong>. 要实现这样的效果，我们需要准备两张图片，比如<br>背景：<img src="http://upload-images.jianshu.io/upload_images/1694376-283a683670025357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="心2.png"><br>前景：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-c104e6bad2904e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="心.png"><br>我们需要做的就是设置一个mask 蒙版加载前景视图上，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"> self.maskLayer =[CAShapeLayer layer];</div><div class="line">//大小一样</div><div class="line"> self.maskLayer.frame = self.imageView.bounds;</div><div class="line"> CGPoint center  =  CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2);</div><div class="line"> UIBezierPath *path =[UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:2 *M_PI clockwise:YES];</div><div class="line"> self.maskLayer.path = path.CGPath;</div><div class="line"> self.imageView.layer.mask =  self.maskLayer;</div></pre></td></tr></table></figure></p>
<p><strong>2</strong>. 实现注水效果的第二步，我们要实现那样的动态效果，视图中能看到的是蒙版与前景共同作用的效果。当我们把蒙版从 下方移动到上方，就可以可以实现。<br> 首先在初始化maskLayer时需要设置maskLayer的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.maskLayer.position =CGPointMake(self.bounds.size.width/2, self.bounds.size.height * 1.5);</div></pre></td></tr></table></figure></p>
<p>然后做一个基础动画即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *animation =[CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 2;</div><div class="line">    animation.repeatCount = HUGE;</div><div class="line">    animation.fromValue = [NSValue valueWithCGPoint:CGPointMake(self.bounds.size.width/2, self.bounds.size.height * 1.5)]; //因为蒙版大小和前景图大小一样，我们需要把中心点向下移动一倍的高度</div><div class="line">    animation.toValue = [NSValue valueWithCGPoint:CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2)];</div><div class="line">    [self.maskLayer addAnimation:animation forKey:nil];</div><div class="line">    self.maskLayer.position = CGPointMake(self.bounds.size.width/2, self.bounds.size.height * 1.5);</div></pre></td></tr></table></figure></p>
<p>这样基本上 一个简单的动画就实现了，如果想实现两个方向的 注水，可以添加两个subLayer作为蒙版</p>
<blockquote>
<p>文字渐变</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/6c8f645cb604" target="_blank" rel="noopener">参考文章</a><br>也是使用了两个视图 加一个蒙版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,strong)UILabel *forelLabel;</div><div class="line">@property(nonatomic,strong)UILabel *backLabel;</div><div class="line">@property(nonatomic,strong)CAGradientLayer *maskLayer;</div></pre></td></tr></table></figure></p>
<p>动画代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">-(void)setType:(GradientType)type</div><div class="line">&#123;</div><div class="line">    _type = type;</div><div class="line">    switch (type) &#123;</div><div class="line">        case fadeOne:</div><div class="line">            self.maskLayer.colors = @[(id)[UIColor clearColor],(id)[UIColor redColor].CGColor,(id)[UIColor blackColor].CGColor,(id)[UIColor clearColor].CGColor];</div><div class="line">            self.maskLayer.locations = @[@(0.01),@(0.1),@(0.9),@(0.99)];</div><div class="line">            [self fadeString:(self.bounds.size.width)];</div><div class="line">            break;</div><div class="line">        case fadeTwo:</div><div class="line">             self.maskLayer.colors = @[(id)[UIColor clearColor].CGColor,(id)[UIColor redColor].CGColor,(id)[UIColor clearColor].CGColor];</div><div class="line">             self.maskLayer.locations = @[@(0.25),@(0.5),@(0.75)];</div><div class="line">             self.maskLayer.startPoint = CGPointMake(0, 0);</div><div class="line">             self.maskLayer.endPoint = CGPointMake(1, 0);</div><div class="line">           </div><div class="line">             self.maskLayer.position = CGPointMake(-self.bounds.size.width/2.0, self.bounds.size.height/2.0);</div><div class="line">           //默认中心点修改为左侧一半处。</div><div class="line">            [self iphoneFade: (self.bounds.size.width+self.bounds.size.width/2.0)];</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)fadeString:(CGFloat) toValue</div><div class="line">&#123;</div><div class="line">    CABasicAnimation *basicAnimation = [CABasicAnimation animation];</div><div class="line">    basicAnimation.keyPath = @&quot;transform.translation.x&quot;;</div><div class="line">    basicAnimation.fromValue = @(0);</div><div class="line">    basicAnimation.toValue = @(toValue);</div><div class="line">    basicAnimation.duration = 2;</div><div class="line">    basicAnimation.repeatCount = HUGE;</div><div class="line">    basicAnimation.removedOnCompletion = NO;</div><div class="line">    basicAnimation.fillMode = kCAFillModeForwards;</div><div class="line">    [self.maskLayer addAnimation:basicAnimation forKey:nil];</div><div class="line"></div><div class="line">&#125;</div><div class="line">-(void)iphoneFade:(CGFloat) toValue</div><div class="line">&#123;</div><div class="line">    CABasicAnimation *basicAnimation = [CABasicAnimation animation];</div><div class="line">    basicAnimation.keyPath = @&quot;transform.translation.x&quot;;</div><div class="line">    basicAnimation.fromValue = @(0);</div><div class="line">    basicAnimation.toValue = @(toValue);</div><div class="line">    basicAnimation.duration = 2;</div><div class="line">    basicAnimation.repeatCount = HUGE;</div><div class="line">    basicAnimation.removedOnCompletion = NO;</div><div class="line">    basicAnimation.fillMode = kCAFillModeForwards;</div><div class="line">    [self.maskLayer addAnimation:basicAnimation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之变换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之变换/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>很不幸，没人能告诉你母体是什么，你只能自己体会 – 骇客帝国</p>
</blockquote>
<p>在第四章“可视效果”中，我们研究了一些增强图层和它的内容显示效果的一些技术，在这一章中，我们将要研究可以用来对图层旋转，摆放或者扭曲的CGAffineTransform，以及可以将扁平物体转换成三维空间对象的CATransform3D（而不是仅仅对圆角矩形添加下沉阴影）。</p>
<ul>
<li>####<strong>仿射变换</strong></li>
</ul>
<p>在第三章“图层几何学”中，我们使用了UIView的transform属性旋转了钟的指针，但并没有解释背后运作的原理，实际上UIView的transform属性是一个CGAffineTransform类型，用于在二维空间做旋转，缩放和平移。CGAffineTransform是一个可以和二维空间向量（例如CGPoint）做乘法的3X2的矩阵（见图5.1）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-3045549ea178fed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.png"><br> 用CGPoint的每一列和CGAffineTransform矩阵的每一行对应元素相乘再求和，就形成了一个新的CGPoint类型的结果。要解释一下图中显示的灰色元素，为了能让矩阵做乘法，左边矩阵的列数一定要和右边矩阵的行数个数相同，所以要给矩阵填充一些标志值，使得既可以让矩阵做乘法，又不改变运算结果，并且没必要存储这些添加的值，因为它们的值不会发生变化，但是要用来做运算。</p>
<p>因此，通常会用3×3（而不是2×3）的矩阵来做二维变换，你可能会见到3行2列格式的矩阵，这是所谓的以列为主的格式，图5.1所示的是以行为主的格式，只要能保持一致，用哪种格式都无所谓。</p>
<p>当对图层应用变换矩阵，图层矩形内的每一个点都被相应地做变换，从而形成一个新的四边形的形状。CGAffineTransform中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行，CGAffineTransform可以做出任意符合上述标注的变换，图5.2显示了一些仿射的和非仿射的变换：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-942383d3231167ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.2.png"></p>
<pre><code>仿射和非仿射变换
</code></pre><p><strong>创建一个CGAffineTransform</strong></p>
<p>对矩阵数学做一个全面的阐述就超出本书的讨论范围了，不过如果你对矩阵完全不熟悉的话，矩阵变换可能会使你感到畏惧。幸运的是，Core Graphics提供了一系列函数，对完全没有数学基础的开发者也能够简单地做一些变换。如下几个函数都创建了一个CGAffineTransform实例：<br><code>CGAffineTransformMakeRotation(CGFloat angle) 
CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)</code><br>  旋转和缩放变换都可以很好解释–分别旋转或者缩放一个向量的值。平移变换是指每个点都移动了向量指定的x或者y值–所以如果向量代表了一个点，那它就平移了这个点的距离。</p>
<p>我们用一个很简单的项目来做个demo，把一个原始视图旋转45度角度（图5.3）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-378ef29aa545c385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.3.png"><br> UIView可以通过设置transform属性做变换，但实际上它只是封装了内部图层的变换。</p>
<p>CALayer同样也有一个transform属性，但它的类型是CATransform3D，而不是CGAffineTransform，本章后续将会详细解释。CALayer对应于UIView的transform属性叫做affineTransform，清单5.1的例子就是使用affineTransform对图层做了45度顺时针旋转。</p>
<p>#####清单5.1 使用affineTransform对图层旋转45度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //rotate the layer 45 degrees</div><div class="line">    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">    self.layerView.layer.affineTransform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>注意我们使用的旋转常量是M_PI_4，而不是你想象的45，因为<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>的变换函数使用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所以四分之一的pi就是45度。</p>
<p>C的数学函数库（iOS会自动引入）提供了pi的一些简便的换算，M_PI_4于是就是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) </div><div class="line">#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)</div></pre></td></tr></table></figure></p>
<p><strong>混合变换</strong><br>Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要缩放又要旋转的变换，这就会非常有用了。例如下面几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)     </div><div class="line">CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)      </div><div class="line">CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)</div></pre></td></tr></table></figure></p>
<p>当操纵一个变换的时候，初始生成一个什么都不做的变换很重要–也就是创建一个CGAffineTransform<br>类型的空值，矩阵论中称作单位矩阵，Core Graphics同样也提供了一个方便的常量：<br><code>CGAffineTransformIdentity</code><br>最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：<br><code>CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);</code></p>
<p>我们来用这些函数组合一个更加复杂的变换，先缩小50%，再旋转30度，最后向右移动200个像素（清单5.2）。图5.4显示了图层变换最后的结果。</p>
<p>#####清单5.2 使用若干方法创建一个复合变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad]; //create a new transform</div><div class="line">    CGAffineTransform transform = CGAffineTransformIdentity; //scale by 50%</div><div class="line">    transform = CGAffineTransformScale(transform, 0.5, 0.5); //rotate by 30 degrees</div><div class="line">    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //translate by 200 points</div><div class="line">    transform = CGAffineTransformTranslate(transform, 200, 0);</div><div class="line">    //apply transform to layer</div><div class="line">    self.layerView.layer.affineTransform = transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-336be9d648d56cd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.4.png"></p>
<p> 图5.4中有些需要注意的地方：图片向右边发生了平移，但并没有指定距离那么远（200像素），另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。</p>
<p>这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<p><strong>剪切变换</strong><br>Core Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置CGAffineTransform<br>的值。除非需要创建一个斜切的变换，Core Graphics并没有提供直接的函数。<br>斜切变换是放射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。我们用一张图片可以很直接的说明效果（图5.5）。也许用“倾斜”描述更加恰当，具体做变换的代码见清单5.3。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6817472cb15dc214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="斜切变换.png"></p>
<p>####清单5.3 实现一个斜切变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)</div><div class="line">&#123;</div><div class="line">    CGAffineTransform transform = CGAffineTransformIdentity;</div><div class="line">    transform.c = -x;</div><div class="line">    transform.b = y;</div><div class="line">    return transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //shear the layer at a 45-degree angle</div><div class="line">    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3D变换</strong><br> CG的前缀告诉我们，CGAffineTransform类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且CGAffineTransform仅仅对2D变换有效。</p>
<p>在第三章中，我们提到了zPosition属性，可以用来让图层靠近或者远离相机（用户视角），transform属性（CATransform3D类型）可以真正做到这点，即让图层在3D空间内移动或者旋转。</p>
<p>和CGAffineTransform类似，CATransform3D也是一个矩阵，但是和2x3的矩阵不同，CATransform3D是一个可以在3维空间内做变换的4x4的矩阵（图5.6）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-474ebda43a0f86d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.6.png"></p>
<pre><code>对一个3D像素点做CATransform3D矩阵变换
</code></pre><p>和CGAffineTransform矩阵类似，Core Animation提供了一系列的方法用来创建和组合CATransform3D类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个z参数，并且旋转函数除了angle之外多出了x,y,z三个参数，分别决定了每个坐标轴方向上的旋转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)</div><div class="line">CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) </div><div class="line">CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)</div></pre></td></tr></table></figure></p>
<p>你应该对X轴和Y轴比较熟悉了，分别以右和下为正方向（回忆第三章，这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向（图5.7)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0808e997f038e4a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.7.png"></p>
<p> 由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。</p>
<p>举个例子：清单5.4的代码使用了CATransform3DMakeRotation对视图内的图层绕Y轴做了45度角的旋转，我们可以把视图向右倾斜，这样会看得更清晰。</p>
<p>结果见图5.8，但并不像我们期待的那样。</p>
<p>#####清单5.4 绕Y轴旋转图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //rotate the layer 45 degrees along the Y axis</div><div class="line">        CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);</div><div class="line">        self.layerView.layer.transform = transform;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-740459ecf2961450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.8.png"></p>
<p>看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，是哪里出了问题呢？<br>其实完全没错，视图看起来更窄实际上是因为我们在用一个斜向的视角看它，而不是透视。</p>
<p><strong>透视投影</strong><br>在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边跟短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中任然保持平行，和之前提到的仿射变换类似。</p>
<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处（例如建筑绘图，颠倒，和伪3D视频），但当前我们并不需要。</p>
<p>为了做一些修正，我们需要引入投影变换（又称作z变换）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：</p>
<p>CATransform3D的透视效果通过一个矩阵中一个很简单的元素来控制：m34。m34（图5.9）用于按比例缩放X和Y的值来计算到底要离视角多远。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d9b4df52bdf13918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.9.png"><br> m34的默认值是0，我们可以通过设置m34为-1.0 / d来应用透视效果，d代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了。</p>
<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的防止的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果，对视图应用透视的代码见清单5.5，结果见图5.10。</p>
<p>#####清单5.5 对变换应用透视效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a new transform</div><div class="line">    CATransform3D transform = CATransform3DIdentity;</div><div class="line">    //apply perspective</div><div class="line">    transform.m34 = - 1.0 / 500.0;</div><div class="line">    //rotate by 45 degrees along the Y axis</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);</div><div class="line">    //apply to layer</div><div class="line">    self.layerView.layer.transform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-b2c36c95bd0d9de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.10.png"></p>
<p><strong>灭点</strong><br> 当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>在现实中，这个点通常是视图的中心（图5.11），于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0009ba0f03440c28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.11.png"><br> Core Animation定义了这个点位于变换图层的anchorPoint（通常位于图层中心，但也有例外，见第三章）。这就是说，当图层发生变换时，这个点永远位于图层变换之前anchorPoint的位置。</p>
<p>当改变一个图层的position，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整m34来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的position），这样所有的3D图层都共享一个灭点。</p>
<ul>
<li>####<strong>sublayerTransform属性</strong></li>
</ul>
<p>如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个position，如果用一个函数封装这些操作的确会更加方便，但仍然有限制（例如，你不能在Interface Builder中摆放视图），这里有一个更好的方法。</p>
<p>CALayer有一个属性叫做sublayerTransform。它也是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<p>相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在容器图层的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用position<br>和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
<p>我们来用一个demo举例说明。这里用Interface Builder并排放置两个视图（图5.12），然后通过设置它们容器视图的透视变换，我们可以保证它们有相同的透视和灭点，代码见清单5.6，结果见图5.13。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-99bde2090f46140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.12.png"></p>
<p>#####清单5.6 应用sublayerTransform<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //apply perspective transform to container</div><div class="line">    CATransform3D perspective = CATransform3DIdentity;</div><div class="line">    perspective.m34 = - 1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = perspective;</div><div class="line">    //rotate layerView1 by 45 degrees along the Y axis</div><div class="line">    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);</div><div class="line">    self.layerView1.layer.transform = transform1;</div><div class="line">    //rotate layerView2 by 45 degrees along the Y axis</div><div class="line">    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);</div><div class="line">    self.layerView2.layer.transform = transform2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-550f11f77952d490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.13通过相同的透视效果分别对视图做变换.png"><br><strong>背面</strong><br>我们既然可以在3D场景下旋转图层，那么也可以从背面去观察它。如果我们在清单5.4中把角度修改为M_PI（180度）而不是当前的M_PI_4（45度），那么将会把图层完全旋转一个半圈，于是完全背对了相机视角。<br>那么从背部看图层是什么样的呢，见图5.14</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d410b79466859b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.14.png"></p>
<p> 如你所见，图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p>CALayer有一个叫做doubleSided的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<p><strong>扁平化图层</strong><br>如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？见图5.15</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-8c0d287a3d5365db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.15.png"></p>
<p>意做了-45度旋转的内部图层是怎样抵消旋转45度的图层，从而恢复正常状态的。</p>
<p>如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。</p>
<p>验证一下，相应代码见清单5.7，结果见5.16</p>
<p>#####清单5.7 绕Z轴做相反的旋转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *outerView;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *innerView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //rotate the outer layer 45 degrees</div><div class="line">       CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);</div><div class="line">       self.outerView.layer.transform = outer;</div><div class="line">       //rotate the inner layer -45 degrees</div><div class="line">       CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);</div><div class="line">       self.innerView.layer.transform = inner;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c628c844d39fcbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.16.png"></p>
<p>运行结果和我们预期的一致。现在在3D情况下再试一次。修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用sublayerTransform属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换（清单5.8）。</p>
<p>#####清单5.8 绕Y轴相反的旋转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //rotate the outer layer 45 degrees</div><div class="line">    CATransform3D outer = CATransform3DIdentity;</div><div class="line">    outer.m34 = -1.0 / 500.0;</div><div class="line">    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);</div><div class="line">    self.outerView.layer.transform = outer;</div><div class="line">    //rotate the inner layer -45 degrees</div><div class="line">    CATransform3D inner = CATransform3DIdentity;</div><div class="line">    inner.m34 = -1.0 / 500.0;</div><div class="line">    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);</div><div class="line">    self.innerView.layer.transform = inner;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d0ede7526b6d95b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.17.png"></p>
<p>但其实这并不是我们所看到的，相反，我们看到的结果如图5.18所示。发什么了什么呢？内部的图层仍然向左侧旋转，并且发生了扭曲，但按道理说它应该保持正面朝上，并且显示正常的方块。</p>
<p>这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-77d09181063d3aa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="518.png"></p>
<p> 类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>
<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系–在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。</p>
<p>至少当你用正常的CALayer的时候是这样，CALayer有一个叫做CATransformLayer的子类来解决这个问题。具体在第六章“特殊的图层”中将会具体讨论。</p>
<p><strong>固体对象</strong><br>现在你懂得了在3D空间的一些图层布局的基础，我们来试着创建一个固态的3D对象（实际上是一个技术上所谓的空洞对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。<br>在这个例子中，我们用Interface Builder来构建立方体的面（图5.19），我们当然可以用代码来写，但是用Interface Builder的好处是可以方便的在每一个面上添加子视图。记住这些面仅仅是包含视图和控件的普通的用户界面元素，它们完全是我们界面交互的部分，并且当把它折成一个立方体之后也不会改变这个性质。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-9ac8ecb9aac49eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.19.png"><br> 这些面视图并没有放置在主视图当中，而是松散地排列在根nib文件里面。我们并不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的transform对它们进行重新布局，并且用Interface Builder在容器视图之外摆放他们可以让我们容易看清楚它们的内容，如果把它们一个叠着一个都塞进主视图，将会变得很难看。</p>
<p>我们把一个有颜色的UILabel放置在视图内部，是为了清楚的辨别它们之间的关系，并且UIButton被放置在第三个面视图里面，后面会做简单的解释。</p>
<p>具体把视图组织成立方体的代码见清单5.9，结果见图5.20</p>
<p>#####清单5.9 创建一个立方体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform</div><div class="line">&#123;</div><div class="line">    //get the face view and add it to the container</div><div class="line">    UIView *face = self.faces[index];</div><div class="line">    [self.containerView addSubview:face];</div><div class="line">    //center the face view within the container</div><div class="line">    CGSize containerSize = self.containerView.bounds.size;</div><div class="line">    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div><div class="line">    // apply the transform</div><div class="line">    face.layer.transform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //set up the container sublayer transform</div><div class="line">    CATransform3D perspective = CATransform3DIdentity;</div><div class="line">    perspective.m34 = -1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = perspective;</div><div class="line">    //add cube face 1</div><div class="line">    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);</div><div class="line">    [self addFace:0 withTransform:transform];</div><div class="line">    //add cube face 2</div><div class="line">    transform = CATransform3DMakeTranslation(100, 0, 0);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);</div><div class="line">    [self addFace:1 withTransform:transform];</div><div class="line">    //add cube face 3</div><div class="line">    transform = CATransform3DMakeTranslation(0, -100, 0);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);</div><div class="line">    [self addFace:2 withTransform:transform];</div><div class="line">    //add cube face 4</div><div class="line">    transform = CATransform3DMakeTranslation(0, 100, 0);</div><div class="line">    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);</div><div class="line">    [self addFace:3 withTransform:transform];</div><div class="line">    //add cube face 5</div><div class="line">    transform = CATransform3DMakeTranslation(-100, 0, 0);</div><div class="line">    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);</div><div class="line">    [self addFace:4 withTransform:transform];</div><div class="line">    //add cube face 6</div><div class="line">    transform = CATransform3DMakeTranslation(0, 0, -100);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);</div><div class="line">    [self addFace:5 withTransform:transform];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-27336b3a305d88a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="520.png"></p>
<p>从这个角度看立方体并不是很明显；看起来只是一个方块，为了更好地欣赏它，我们将更换一个不同的视角。</p>
<p>旋转这个立方体将会显得很笨重，因为我们要单独对每个面做旋转。另一个简单的方案是通过调整容器视图的sublayerTransform去旋转照相机。添加如下几行去旋转containerView图层的perspective变换矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0); </div><div class="line">perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);</div></pre></td></tr></table></figure></p>
<p>这就对相机（或者相对相机的整个场景，你也可以这么认为）绕Y轴旋转45度，并且绕X轴旋转45度。现在从另一个角度去观察立方体，就能看出它的真实面貌（图5.21）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-358730cc31f8063f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.21.png"><br><strong>光亮和阴影</strong></p>
<p>现在它看起来更像是一个立方体没错了，但是对每个面之间的连接还是很难分辨。Core Animation可以用3D显示图层，但是它对光线并没有概念。如果想让立方体看起来更加真实，需要自己做一个阴影效果。你可以通过改变每个面的背景颜色或者直接用带光亮效果的图片来调整。</p>
<p>如果需要动态地创建光线效果，你可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层，但为了计算阴影图层的不透明度，你需要得到每个面的正太向量（垂直于表面的向量），然后根据一个想象的光源计算出两个向量叉乘结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。</p>
<p>清单5.10实现了这样一个结果，我们用GLKit框架来做向量的计算（你需要引入GLKit库来运行代码），每个面的CATransform3D都被转换成GLKMatrix4，然后通过GLKMatrix4GetMatrix3函数得出一个3×3的旋转矩阵。这个旋转矩阵指定了图层的方向，然后可以用它来得到正太向量的值。结果如图5.22所示，试着调整LIGHT_DIRECTION和AMBIENT_LIGHT的值来切换光线效果</p>
<p>#####清单5.10 对立方体的表面应用动态的光线效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &lt;GLKit/GLKit.h&gt;</div><div class="line">    </div><div class="line">#define LIGHT_DIRECTION 0, 1, -0.5</div><div class="line">#define AMBIENT_LIGHT 0.5</div><div class="line">    </div><div class="line">    @interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)applyLightingToFace:(CALayer *)face</div><div class="line">    &#123;</div><div class="line">        //add lighting layer</div><div class="line">        CALayer *layer = [CALayer layer];</div><div class="line">        layer.frame = face.bounds;</div><div class="line">        [face addSublayer:layer];</div><div class="line">        //convert the face transform to matrix</div><div class="line">        //(GLKMatrix4 has the same structure as CATransform3D)</div><div class="line">        //译者注：GLKMatrix4和CATransform3D内存结构一致，但坐标类型有长度区别，所以理论上应该做一次float到CGFloat的转换，感谢[@zihuyishi](https://github.com/zihuyishi)同学~</div><div class="line">        CATransform3D transform = face.transform;</div><div class="line">        GLKMatrix4 matrix4 = *(GLKMatrix4 *)&amp;transform;</div><div class="line">        GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);</div><div class="line">        //get face normal</div><div class="line">        GLKVector3 normal = GLKVector3Make(0, 0, 1);</div><div class="line">        normal = GLKMatrix3MultiplyVector3(matrix3, normal);</div><div class="line">        normal = GLKVector3Normalize(normal);</div><div class="line">        //get dot product with light direction</div><div class="line">        GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));</div><div class="line">        float dotProduct = GLKVector3DotProduct(light, normal);</div><div class="line">        //set lighting layer opacity</div><div class="line">        CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;</div><div class="line">        UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];</div><div class="line">        layer.backgroundColor = color.CGColor;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform</div><div class="line">    &#123;</div><div class="line">        //get the face view and add it to the container</div><div class="line">        UIView *face = self.faces[index];</div><div class="line">        [self.containerView addSubview:face];</div><div class="line">        //center the face view within the container</div><div class="line">        CGSize containerSize = self.containerView.bounds.size;</div><div class="line">        face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div><div class="line">        // apply the transform</div><div class="line">        face.layer.transform = transform;</div><div class="line">        //apply lighting</div><div class="line">        [self applyLightingToFace:face.layer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //set up the container sublayer transform</div><div class="line">        CATransform3D perspective = CATransform3DIdentity;</div><div class="line">        perspective.m34 = -1.0 / 500.0;</div><div class="line">        perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);</div><div class="line">        perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);</div><div class="line">        self.containerView.layer.sublayerTransform = perspective;</div><div class="line">        //add cube face 1</div><div class="line">        CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);</div><div class="line">        [self addFace:0 withTransform:transform];</div><div class="line">        //add cube face 2</div><div class="line">        transform = CATransform3DMakeTranslation(100, 0, 0);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);</div><div class="line">        [self addFace:1 withTransform:transform];</div><div class="line">        //add cube face 3</div><div class="line">        transform = CATransform3DMakeTranslation(0, -100, 0);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);</div><div class="line">        [self addFace:2 withTransform:transform];</div><div class="line">        //add cube face 4</div><div class="line">        transform = CATransform3DMakeTranslation(0, 100, 0);</div><div class="line">        transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);</div><div class="line">        [self addFace:3 withTransform:transform];</div><div class="line">        //add cube face 5</div><div class="line">        transform = CATransform3DMakeTranslation(-100, 0, 0);</div><div class="line">        transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);</div><div class="line">        [self addFace:4 withTransform:transform];</div><div class="line">        //add cube face 6</div><div class="line">        transform = CATransform3DMakeTranslation(0, 0, -100);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);</div><div class="line">        [self addFace:5 withTransform:transform];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-5326f4bc4b613368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.22.png"></p>
<p><strong>点击事件</strong></p>
<p>你应该能注意到现在可以在第三个表面的顶部看见按钮了，点击它，什么都没发生，为什么呢？</p>
<p>这并不是因为iOS在3D场景下正确地处理响应事件，实际上是可以做到的。问题在于视图顺序。在第三章中我们简要提到过，点击事件的处理由视图在父视图中的顺序决定的，并不是3D空间中的Z轴顺序。当给立方体添加视图的时候，我们实际上是按照一个顺序添加，所以按照视图/图层顺序来说，4，5，6在3的前面。</p>
<p>即使我们看不见4，5，6的表面（因为被1，2，3遮了），iOS在事件响应上仍然保持之前的顺序。当试图点击表面3上的按钮，表面4，5，6截断了点击事件（取决于点击的位置），这就和普通的2D布局在按钮上覆盖物体一样。</p>
<p>你也许认为把doubleSided设置成NO可以解决这个问题，因为它不再渲染视图后面的内容，但实际上并不起作用。因为背对相机而隐藏的视图仍然会响应点击事件（这和通过设置hidden<br>属性或者设置alpha为0而隐藏的视图不同，那两种方式将不会响应事件）。所以即使禁止了双面渲染仍然不能解决这个问题（虽然由于性能问题，还是需要把它设置成NO）。</p>
<p>这里有几种正确的方案：把除了表面3的其他视图userInteractionEnabled属性都设置成NO来禁止事件传递。或者简单通过代码把视图3覆盖在视图6上。无论怎样都可以点击按钮了（图5.23）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-589bc9df2efcabfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.23.png"></p>
<p>#####总结<br> 这一章涉及了一些2D和3D的变换。你学习了一些矩阵计算的基础，以及如何用Core Animation创建3D场景。你看到了图层背后到底是如何呈现的，并且知道了不能把扁平的图片做成真实的立体效果，最后我们用demo说明了触摸事件的处理，视图中图层添加的层级顺序会比屏幕上显示的顺序更有意义。</p>
<p>第六章我们会研究一些Core Animation提供不同功能的具体的CALayer子类</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之图层树/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之图层树/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong> 图层的树状结构</strong></p>
</blockquote>
<p>Core Animation其实是一个令人误解的命名。你可能认为它只是用来做动画的，但实际上它是从一个叫做Layer Kit这么一个不怎么和动画有关的名字演变而来，所以做动画这只是Core Animation特性的冰山一角。<br>Core Animation是一个复合引擎，它的职责就是尽可能快地组合屏幕上不同的可视内容，这个内容是被分解成独立的图层，存储在一个叫做图层树的体系之中。于是这个树形成了UIKit以及在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>应用程序当中你所能在屏幕上看见的一切的基础。<br>在我们讨论动画之前，我们将从图层树开始，涉及一下Core Animation的静态组合以及布局特性。</p>
<blockquote>
<p><strong>图层和视图</strong></p>
</blockquote>
<p>如果你曾经在iOS或者Mac OS平台上写过应用程序，你可能会对视图的概念比较熟悉。一个视图就是在屏幕上显示的一个矩形块（比如图片，文字或者视频），它能够拦截类似于鼠标点击或者触摸手势等用户输入。视图在层级关系中可以互相嵌套，一个视图可以管理它的所有子视图的位置。<br>在iOS当中，所有的视图都从一个叫做UIVIew的基类派生而来，UIView可以处理触摸事件，可以支持基于CoreGraphics绘图，可以做仿射变换（例如旋转或者缩放），或者简单的类似于滑动或者渐变的动画。</p>
<blockquote>
<p><strong>CALayer</strong></p>
</blockquote>
<p>CALayer类在概念上和UIView类似，同样也是一些被层级关系树管理的矩形块，同样也可以包含一些内容（像图片，文本或者背景色），管理子图层的位置。它们有一些方法和属性用来做动画和变换。和UIView最大的不同是CALayer不处理用户的交互。<br>CALayer并不清楚具体的响应链（iOS通过视图层级关系用来传送触摸事件的机制），于是它并不能够响应事件，即使它提供了一些方法来判断是否一个触点在图层的范围之内（具体见第三章，“图层的几何学”）</p>
<blockquote>
<p><strong>平行的层级关系</strong></p>
</blockquote>
<p>每一个UIview都有一个CALayer实例的图层属性，也就是所谓的backing layer，视图的职责就是创建并管理这个图层，以确保当子视图在层级关系中添加或者被移除的时候，他们关联的图层也同样对应在层级关系树当中有相同的操作,实际上这些背后关联的图层才是真正用来在屏幕上显示和做动画，UIView仅仅是对它的一个封装，提供了一些iOS类似于处理触摸的具体功能，以及Core Animation底层方法的高级接口。</p>
<p>但是为什么iOS要基于UIView和CALayer提供两个平行的层级关系呢？为什么不用一个简单的层级来处理所有事情呢？原因在于要做职责分离，这样也能避免很多重复代码。在iOS和Mac OS两个平台上，事件和用户交互有很多地方的不同，基于多点触控的用户界面和基于鼠标键盘有着本质的区别，这就是为什么iOS有UIKit和UIView，但是Mac OS有AppKit和NSView<br>的原因。他们功能上很相似，但是在实现上有着显著的区别。</p>
<p>绘图，布局和动画，相比之下就是类似Mac笔记本和桌面系列一样应用于iPhone和iPad触屏的概念。把这种功能的逻辑分开并应用到独立的Core Animation框架，苹果就能够在iOS和Mac OS之间共享代码，使得对苹果自己的OS开发团队和第三方开发者去开发两个平台的应用更加便捷。</p>
<p>实际上，这里并不是两个层级关系，而是四个，每一个都扮演不同的角色，除了视图层级和图层树之外，还存在呈现树和渲染树，将在第七章“隐式动画”和第十二章“性能调优”分别讨论。</p>
<blockquote>
<p> <strong>图层的能力</strong></p>
</blockquote>
<p> 如果说CALayer是UIView内部实现细节，那我们为什么要全面地了解它呢？苹果当然为我们提供了优美简洁的UIView接口，那么我们是否就没必要直接去处理Core Animation的细节了呢？</p>
<p>某种意义上说的确是这样，对一些简单的需求来说，我们确实没必要处理CALayer，因为苹果已经通过UIView的高级API间接地使得动画变得很简单。</p>
<p>但是这种简单会不可避免地带来一些灵活上的缺陷。如果你略微想在底层做一些改变，或者使用一些苹果没有在UIView上实现的接口功能，这时除了介入CoreAnimation底层之外别无选择。</p>
<p>我们已经证实了图层不能像视图那样处理触摸事件，那么他能做哪些视图不能做的呢？这里有一些UIView没有暴露出来的CALayer的功能：</p>
<ul>
<li>阴影，圆角，带颜色的边框</li>
<li>非矩形范围</li>
<li>阴影，圆角，带颜色的边框</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>
<p>我们将会在后续章节中探索这些功能，首先我们要关注一下在应用程序当中CALayer是怎样被利用起来的。</p>
<blockquote>
<p><strong>使用图层</strong></p>
</blockquote>
<p>首先我们来创建一个简单的项目，来操纵一些layer<br>的属性。打开Xcode，使用Single View Application模板创建一个工程。<br>在屏幕中央创建一个小视图（大约200 X 200的尺寸），当然你可以手工编码，或者使用Interface Builder（随你方便）。确保你的视图控制器要添加一个视图的属性以便可以直接访问它。我们把它称作layerView。<br>运行项目，应该能在浅灰色屏幕背景中看见一个白色方块（图1.3），如果没看见，可能需要调整一下背景window或者view的颜色<br><img src="http://upload-images.jianshu.io/upload_images/1694376-444333d7d60da741.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1.png"></p>
<p>灰色背景上的一个白色UIView这并没有什么令人激动的地方，我们来添加一个色块，在白色方块中间添加一个小的蓝色块。<br>我们当然可以简单地在已经存在的UIView上添加一个子视图（随意用代码或者IB），但这不能真正学到任何关于图层的东西。</p>
<p>于是我们来创建一个CALayer，并且把它作为我们视图相关图层的子图层。尽管UIView类的接口中暴露了图层属性，但是标准的Xcode项目模板并没有包含Core Animation相关头文件。所以如果我们不给项目添加合适的库，是不能够使用任何图层相关的方法或者访问它的属性。所以首先需要添加QuartzCore框架到Build Phases标签，然后在vc的.m文件中引入库。</p>
<p>之后就可以在代码中直接引用CALayer的属性和方法。在清单1.1中，我们用创建了一个CALayer，设置了它的backgroundColor属性，然后添加到layerView背后相关图层的子图层（这段代码的前提是通过IB创建了layerView并做好了连接），图1.5显示了结果。</p>
<p>#####清单1.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad&#123; [super viewDidLoad]; </div><div class="line">//create sublayer</div><div class="line"> CALayer *blueLayer = [CALayer layer]; </div><div class="line">blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f); </div><div class="line">blueLayer.backgroundColor = [UIColor blueColor].CGColor; </div><div class="line">//add it to our view</div><div class="line"> [self.layerView.layer addSublayer:blueLayer];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-028a10c1cb2ecf63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图1.5.png"><br> 一个视图只有一个相关联的图层（自动创建），同时它也可以支持添加无数多个子图层，从清单1.1可以看出，你可以显示创建一个单独的图层，并且把它直接添加到视图关联图层的子图层。尽管可以这样添加图层，但往往我们只是见简单地处理视图，他们关联的图层并不需要额外地手动添加子图层。</p>
<p>在Mac OS平台，10.8版本之前，一个显著的性能缺陷就是由于用了视图层级而不是单独在一个视图内使用CALayer树状层级。但是在iOS平台，使用轻量级的UIView类并没有显著的性能影响（当然在Mac OS 10.8之后，NSView的性能同样也得到很大程度的提高）。</p>
<p>使用图层关联的视图而不是CALayer的好处在于，你能在使用所有CALayer底层特性的同时，也可以使用UIView的高级API（比如自动排版，布局和事件处理）。</p>
<p>然而，当满足以下条件的时候，你可能更需要使用CALayer而不是UIView  </p>
<ul>
<li>开发同时可以在Mac OS上运行的跨平台应用</li>
<li>使用多种CALayer的子类（见第六章，“特殊的图层“），并且不想创建额外的UIView去包封装它们所有</li>
<li>做一些对性能特别挑剔的工作，比如对UIView一些可忽略不计的操作都会引起显著的不同（尽管如此，你可能会直接想使用OpenGL绘图）</li>
</ul>
<p>但是这些例子都很少见，总的来说，处理视图会比单独处理图层更加方便</p>
<p>####<strong>总结</strong><br> 这一章阐述了图层的树状结构，说明了如何在iOS中由UIView的层级关系形成的一种平行的CALayer层级关系，在后面的实验中，我们创建了自己的CALayer，并把它添加到图层树中。</p>
<p>在第二章，“图层关联的图片”，我们将要研究一下CALayer关联的图片，以及Core Animation提供的操作显示的一些特性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之动画继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之动画继承/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1694376-5bbcf21b1ece3a71.gif?imageMogr2/auto-orient/strip" alt="1.gif"><br> demo地址 :    <a href="https://github.com/liuxinixn/CoreAnimation-" target="_blank" rel="noopener">属性动画</a><br>在做属性动画的时候，先了解下动画继承关系：</p>
<p>####CAAnimation ：父类 遵守了<strong>CAMediaTiming</strong>协议</p>
<blockquote>
<p>CAMediaTiming媒体时间类协议</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CAMediaTiming中的协议内容</div><div class="line"> 1.beginTime 动画开始的时间 默认为0</div><div class="line"> 2.duration 动画的持续时间 默认为0 持续时间 受速度的影响 实际动画完成时间 = 持续时间/速度</div><div class="line"> 3.speed 动画的播放速度 默认为1 速度设置为0 可以暂停动画 如果speed 2秒 duration 60秒 那么动画真正播放完成的时间 30秒 </div><div class="line"> 4.timeOffset 动画播放时间的偏移量</div><div class="line"> 5.repeatCount 动画的循环次数 默认是0 只播放一次 </div><div class="line"> 6.repeatDuration 动画循环的持续时间 repeatCount/repeatDuration 只能设置其中的一个属性 </div><div class="line"> 7.autoreverses 是否以动画的形式返回 返回到播放之前的状态 </div><div class="line"> 8.fillMode 设置当前对象在非活动时间段的状态 要想fillMode有效 需设置removedOnCompletion = NO</div><div class="line">  kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态 </div><div class="line">  kCAFillModeBackwards 立即进入动画的初始状态并等待动画开始 </div><div class="line">  kCAFillModeBoth 动画加入后开始之前 layer处于动画初始状态 动画结束后layer保持动画最后的状态</div><div class="line">  kCAFillModeRemoved 默认值 动画结束后 layer会恢复到之前的状态</div></pre></td></tr></table></figure>
<blockquote>
<p>CAAnimation动画属性方法介绍</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1.初始化的方法 animation </div><div class="line">2.timingFunction 速度控制类 控制动画运行的节奏 </div><div class="line">初始化:functionWithName:</div><div class="line"> kCAMediaTimingFunctionLinear 匀速 </div><div class="line">kCAMediaTimingFunctionEaseIn 慢进快出 </div><div class="line">kCAMediaTimingFunctionEaseOut 快进慢出 </div><div class="line">kCAMediaTimingFunctionEaseInEaseOut 慢进慢出 中间加速 </div><div class="line">kCAMediaTimingFunctionDefault 默认 </div><div class="line">3.delegate 代理</div><div class="line">4.removedOnCompletion 完成动画的时候 是否移除动画效果 </div><div class="line">5.代理方法 </div><div class="line">- (void)animationDidStart:(CAAnimation *)anim</div><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div></pre></td></tr></table></figure>
<blockquote>
<p>#####三个常用个子类</p>
</blockquote>
<ul>
<li><p>CAPropertyAnimation</p>
<ul>
<li><p>CABasicAnimation 扩充属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">介绍：通过改变某个属性的值 到某个值 只能设置两个值 产生的动画</div><div class="line">fromValue 开始值 如果不设置不会返回到初始位置</div><div class="line">toValue 结束值</div><div class="line">byValue 通过哪个值</div><div class="line">@property(nullable, strong) id fromValue;</div><div class="line">@property(nullable, strong) id toValue;</div><div class="line">@property(nullable, strong) id byValue;</div></pre></td></tr></table></figure>
</li>
<li><p>CAKeyframeAnimation</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> 属性解析：</div><div class="line"></div><div class="line">- values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</div><div class="line"></div><div class="line">- path：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略</div><div class="line"></div><div class="line">- keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</div><div class="line"></div><div class="line">- 说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</div></pre></td></tr></table></figure>
<ul>
<li><p>CAAnimationGroup<br><code>@property(nullable, copy) NSArray&lt;CAAnimation *&gt; *animations;//组动画</code></p>
</li>
<li><p>CATransition 提供渐变效果:(推拉push效果,消退fade效果,揭开reveal效果)。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">type：动画过渡的类型</div><div class="line">subtype：动画过渡的方向</div><div class="line">@property(copy) NSString *type;</div><div class="line">@property(nullable, copy) NSString *subtype;</div><div class="line">@property float startProgress;</div><div class="line">@property float endProgress;</div><div class="line"></div><div class="line">/* Common transition types. */</div><div class="line"></div><div class="line">CA_EXTERN NSString * const kCATransitionFade</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionMoveIn</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionPush</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionReveal</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line"></div><div class="line">/* Common transition subtypes. */</div><div class="line"></div><div class="line">CA_EXTERN NSString * const kCATransitionFromRight</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionFromLeft</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionFromTop</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionFromBottom</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div></pre></td></tr></table></figure>
<blockquote>
<h5 id="keyPath可以使用的key-可以做动画的属性，包括虚拟属性"><a href="#keyPath可以使用的key-可以做动画的属性，包括虚拟属性" class="headerlink" title="keyPath可以使用的key ,可以做动画的属性，包括虚拟属性"></a>keyPath可以使用的key ,可以做动画的属性，包括虚拟属性</h5></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">- #define angle2Radian(angle) ((angle)/180.0*M_PI)</div><div class="line">- transform.rotation.x 围绕x轴翻转 参数：角度 angle2Radian(4)</div><div class="line"></div><div class="line">transform.rotation.y 围绕y轴翻转 参数：同上</div><div class="line"></div><div class="line">transform.rotation.z 围绕z轴翻转 参数：同上</div><div class="line"></div><div class="line">transform.rotation 默认围绕z轴</div><div class="line"></div><div class="line">transform.scale.x x方向缩放 参数：缩放比例 1.5</div><div class="line"></div><div class="line">transform.scale.y y方向缩放 参数：同上</div><div class="line"></div><div class="line">transform.scale.z z方向缩放 参数：同上</div><div class="line"></div><div class="line">transform.scale 所有方向缩放 参数：同上</div><div class="line"></div><div class="line">transform.translation.x x方向移动 参数：x轴上的坐标 100</div><div class="line"></div><div class="line">transform.translation.y x方向移动 参数：y轴上的坐标</div><div class="line"></div><div class="line">transform.translation.z x方向移动 参数：z轴上的坐标</div><div class="line"></div><div class="line">transform.translation 移动 参数：移动到的点 （100，100）</div><div class="line"></div><div class="line">opacity 透明度 参数：透明度 0.5</div><div class="line"></div><div class="line">backgroundColor 背景颜色 参数：颜色 (id)[[UIColor redColor] CGColor]</div><div class="line"></div><div class="line">cornerRadius 圆角 参数：圆角半径 5</div><div class="line"></div><div class="line">borderWidth 边框宽度 参数：边框宽度 5</div><div class="line"></div><div class="line">bounds 大小 参数：CGRect</div><div class="line"></div><div class="line">contents 内容 参数：CGImage</div><div class="line"></div><div class="line">contentsRect 可视内容 参数：CGRect 值是0～1之间的小数</div><div class="line"></div><div class="line">hidden 是否隐藏</div><div class="line"></div><div class="line">position</div><div class="line"></div><div class="line">shadowColor</div><div class="line"></div><div class="line">shadowOffset</div><div class="line"></div><div class="line">shadowOpacity</div><div class="line"></div><div class="line">shadowRadius</div></pre></td></tr></table></figure>
<blockquote>
<p>#####基础动画 基础动画可以看做只有两帧。</p>
</blockquote>
<p>经常做的有个  心跳动画，可以尝试一波，有两个方法： </p>
<ol>
<li>改变bounds</li>
<li><p>改变 transform.scale </p>
<ul>
<li>第一种</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 创建动画对象</div><div class="line">       CABasicAnimation *anim = [CABasicAnimation animation];</div><div class="line">   </div><div class="line">       anim.keyPath = @&quot;bounds&quot;;  // transform.scale 表示长和宽都缩放</div><div class="line">       anim.fromValue = [NSValue valueWithCGRect:self.subLayer.bounds];</div><div class="line">       anim.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, self.bounds.size.width , self.bounds.size.height )];                  // @0 缩放到最小</div><div class="line">   </div><div class="line">       anim.duration = 0.5;                // 设置动画执行时间</div><div class="line">       anim.repeatCount = MAXFLOAT;        // MAXFLOAT 表示动画执行次数为无限次</div><div class="line">   </div><div class="line">       anim.autoreverses = YES;            // 控制动画反转 默认情况下动画从尺寸1到0的过程中是有动画的，但是从0到1的过程中是没有动画的，设置autoreverses属性可以让尺寸0到1也是有过程的</div><div class="line">   </div><div class="line">       [self.subLayer addAnimation: anim forKey: nil];</div></pre></td></tr></table></figure>
<ul>
<li>第二种<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 创建动画对象</div><div class="line">       CABasicAnimation *anim = [CABasicAnimation animation];</div><div class="line">   </div><div class="line">       anim.keyPath = @&quot;transform.scale&quot;;  // transform.scale 表示长和宽都缩放</div><div class="line">       anim.toValue = @0;                  // @0 缩放到最小</div><div class="line">   </div><div class="line">       anim.duration = 0.5;                // 设置动画执行时间</div><div class="line">       anim.repeatCount = MAXFLOAT;        // MAXFLOAT 表示动画执行次数为无限次</div><div class="line">   </div><div class="line">       anim.autoreverses = YES;            // 控制动画反转 默认情况下动画从尺寸1到0的过程中是有动画的，但是从0到1的过程中是没有动画的，设置autoreverses属性可以让尺寸0到1也是有过程的</div><div class="line">   </div><div class="line">       [self.icon.layer addAnimation: anim forKey: nil];</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>#####关键帧动画  tranfrom.rotation 其实是虚拟属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define angle2Radio(angle) ((angle) * M_PI / 180.0)</div><div class="line">   CAKeyframeAnimation *animation =[CAKeyframeAnimation animationWithKeyPath:@&quot;transform.rotation&quot;];</div><div class="line">   animation.values = @[@(angle2Radio(-5)), @(angle2Radio(5)), @(angle2Radio(-5))]; // 把度数转换为弧度  度数/180*M_PI</div><div class="line">   animation.repeatCount = HUGE;</div><div class="line">   [self.subLayer addAnimation:animation forKey:nil];</div></pre></td></tr></table></figure>
<blockquote>
<p>#####过渡动画  在平常imageview切换时是没有动画的，我们可以在图片切换过程中增加个过渡动画</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (IBAction)btnAction:(UIButton *)sender &#123;</div><div class="line">    </div><div class="line">    // 0、切换图片</div><div class="line">    a++;</div><div class="line">    if (a&gt; 3) &#123;</div><div class="line">        a = 1;</div><div class="line">    &#125;</div><div class="line">     sender.userInteractionEnabled = NO;</div><div class="line">    self.icon.image = [UIImage imageNamed: [NSString stringWithFormat: @&quot;%d.jpg&quot;, a]];</div><div class="line">    CATransition *animation =[CATransition animation];</div><div class="line">    animation.type = @&quot;rippleEffect&quot;;</div><div class="line">    animation.duration = 2;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.timingFunction =[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    [self.icon.layer addAnimation:animation forKey:nil];</div><div class="line">    sender.userInteractionEnabled = NO;</div><div class="line">&#125;</div><div class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    //动画执行完后打开按钮的交互</div><div class="line">    self.button.userInteractionEnabled = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之图层时间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之图层时间/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>时间和空间最大的区别在于，时间不能被复用 – 弗斯特梅里克</p>
</blockquote>
<p>在上面两章中，我们探讨了可以用CAAnimation和它的子类实现的多种图层动画。动画的发生是需要持续一段时间的，所以计时对整个概念来说至关重要。在这一章中，我们来看看CAMediaTiming，看看Core Animation是如何跟踪时间的。</p>
<p>#####CAMediaTiming协议<br>CAMediaTiming协议定义了在一段动画内用来控制逝去时间的属性的集合，CALayer和CAAnimation都实现了这个协议，所以时间可以被任意基于一个图层或者一段动画的类控制。</p>
<p><strong>持续和重复</strong></p>
<p>我们在第八章“显式动画”中简单提到过duration（CAMediaTiming的属性之一），duration是一个CFTimeInterval的类型（类似于NSTimeInterval的一种双精度浮点类型），对将要进行的动画的一次迭代指定了时间。</p>
<p>这里的一次迭代是什么意思呢？CAMediaTiming另外还有一个属性叫做repeatCount，代表动画重复的迭代次数。如果duration是2，repeatCount设为3.5（三个半迭代），那么完整的动画时长将是7秒。</p>
<p>duration和repeatCount默认都是0。但这不意味着动画时长为0秒，或者0次，这里的0仅仅代表了“默认”，也就是0.25秒和1次，你可以用一个简单的测试来尝试为这两个属性赋多个值，如清单9.1，图9.1展示了程序的结果。</p>
<p>#####清单9.1 测试duration和repeatCount<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, weak) IBOutlet UITextField *durationField;</div><div class="line">@property (nonatomic, weak) IBOutlet UITextField *repeatField;</div><div class="line">@property (nonatomic, weak) IBOutlet UIButton *startButton;</div><div class="line">@property (nonatomic, strong) CALayer *shipLayer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add the ship</div><div class="line">    self.shipLayer = [CALayer layer];</div><div class="line">    self.shipLayer.frame = CGRectMake(0, 0, 128, 128);</div><div class="line">    self.shipLayer.position = CGPointMake(150, 150);</div><div class="line">    self.shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">    [self.containerView.layer addSublayer:self.shipLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setControlsEnabled:(BOOL)enabled</div><div class="line">&#123;</div><div class="line">    for (UIControl *control in @[self.durationField, self.repeatField, self.startButton]) &#123;</div><div class="line">        control.enabled = enabled;</div><div class="line">        control.alpha = enabled? 1.0f: 0.25f;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)hideKeyboard</div><div class="line">&#123;</div><div class="line">    ￼[self.durationField resignFirstResponder];</div><div class="line">    [self.repeatField resignFirstResponder];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)start</div><div class="line">&#123;</div><div class="line">    CFTimeInterval duration = [self.durationField.text doubleValue];</div><div class="line">    float repeatCount = [self.repeatField.text floatValue];</div><div class="line">    //animate the ship rotation</div><div class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;transform.rotation&quot;;</div><div class="line">    animation.duration = duration;</div><div class="line">    animation.repeatCount = repeatCount;</div><div class="line">    animation.byValue = @(M_PI * 2);</div><div class="line">    animation.delegate = self;</div><div class="line">    [self.shipLayer addAnimation:animation forKey:@&quot;rotateAnimation&quot;];</div><div class="line">    //disable controls</div><div class="line">    [self setControlsEnabled:NO];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    //reenable controls</div><div class="line">    [self setControlsEnabled:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-96df4a0597b27c80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.1.png"><br>创建重复动画的另一种方式是使用repeatDuration属性，它让动画重复一个指定的时间，而不是指定次数。你甚至设置一个叫做autoreverses的属性（BOOL类型）在每次间隔交替循环过程中自动回放。这对于播放一段连续非循环的动画很有用，例如打开一扇门，然后关上它（图9.2）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-275ccb9e9af8fc04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.2.png"><br> 对门进行摆动的代码见清单9.2。我们用了autoreverses来使门在打开后自动关闭，在这里我们把repeatDuration设置为INFINITY，于是动画无限循环播放，设置repeatCount为INFINITY也有同样的效果。注意repeatCount和repeatDuration可能会相互冲突，所以你只要对其中一个指定非零值。对两个属性都设置非0值的行为没有被定义。</p>
<p>#####清单9.2 使用autoreverses属性实现门的摇摆<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">  </div><div class="line">  @property (nonatomic, weak) UIView *containerView;</div><div class="line">  </div><div class="line">  @end</div><div class="line">  </div><div class="line">  @implementation ViewController</div><div class="line">  </div><div class="line">  - (void)viewDidLoad</div><div class="line">  &#123;</div><div class="line">      [super viewDidLoad];</div><div class="line">      //add the door</div><div class="line">      CALayer *doorLayer = [CALayer layer];</div><div class="line">      doorLayer.frame = CGRectMake(0, 0, 128, 256);</div><div class="line">      doorLayer.position = CGPointMake(150 - 64, 150);</div><div class="line">      doorLayer.anchorPoint = CGPointMake(0, 0.5);</div><div class="line">      doorLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Door.png&quot;].CGImage;</div><div class="line">      [self.containerView.layer addSublayer:doorLayer];</div><div class="line">      //apply perspective transform</div><div class="line">      CATransform3D perspective = CATransform3DIdentity;</div><div class="line">      perspective.m34 = -1.0 / 500.0;</div><div class="line">      self.containerView.layer.sublayerTransform = perspective;</div><div class="line">      //apply swinging animation</div><div class="line">      CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">      animation.keyPath = @&quot;transform.rotation.y&quot;;</div><div class="line">      animation.toValue = @(-M_PI_2);</div><div class="line">      animation.duration = 2.0;</div><div class="line">      animation.repeatDuration = INFINITY;</div><div class="line">      animation.autoreverses = YES;</div><div class="line">      [doorLayer addAnimation:animation forKey:nil];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  @end</div></pre></td></tr></table></figure></p>
<p><strong>相对时间</strong></p>
<p> 每次讨论到Core Animation，时间都是相对的，每个动画都有它自己描述的时间，可以独立地加速，延时或者偏移。</p>
<p>beginTime指定了动画开始之前的的延迟时间。这里的延迟从动画添加到可见图层的那一刻开始测量，默认是0（就是说动画会立刻执行）。</p>
<p>speed是一个时间的倍数，默认1.0，减少它会减慢图层/动画的时间，增加它会加快速度。如果2.0的速度，那么对于一个duration为1的动画，实际上在0.5秒的时候就已经完成了。</p>
<p>timeOffset和beginTime类似，但是和增加beginTime导致的延迟动画不同，增加timeOffset只是让动画快进到某一点，例如，对于一个持续1秒的动画来说，设置timeOffset为0.5意味着动画将从一半的地方开始。</p>
<p>和beginTime不同的是，timeOffset并不受speed的影响。所以如果你把speed设为2.0，把timeOffset设置为0.5，那么你的动画将从动画最后结束的地方开始，因为1秒的动画实际上被缩短到了0.5秒。然而即使使用了timeOffset让动画从结束的地方开始，它仍然播放了一个完整的时长，这个动画仅仅是循环了一圈，然后从头开始播放。</p>
<p>可以用清单9.3的测试程序验证一下，设置speed和timeOffset滑块到随意的值，然后点击播放来观察效果（见图9.3）</p>
<p>#####清单9.3 测试timeOffset和speed属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">  </div><div class="line">  @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">  @property (nonatomic, weak) IBOutlet UILabel *speedLabel;</div><div class="line">  @property (nonatomic, weak) IBOutlet UILabel *timeOffsetLabel;</div><div class="line">  @property (nonatomic, weak) IBOutlet UISlider *speedSlider;</div><div class="line">  @property (nonatomic, weak) IBOutlet UISlider *timeOffsetSlider;</div><div class="line">  @property (nonatomic, strong) UIBezierPath *bezierPath;</div><div class="line">  @property (nonatomic, strong) CALayer *shipLayer;</div><div class="line">  </div><div class="line">  @end</div><div class="line">  </div><div class="line">  @implementation ViewController</div><div class="line">  </div><div class="line">  - (void)viewDidLoad</div><div class="line">  &#123;</div><div class="line">      [super viewDidLoad];</div><div class="line">      //create a path</div><div class="line">      self.bezierPath = [[UIBezierPath alloc] init];</div><div class="line">      [self.bezierPath moveToPoint:CGPointMake(0, 150)];</div><div class="line">      [self.bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];</div><div class="line">      //draw the path using a CAShapeLayer</div><div class="line">      CAShapeLayer *pathLayer = [CAShapeLayer layer];</div><div class="line">      pathLayer.path = self.bezierPath.CGPath;</div><div class="line">      pathLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">      pathLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">      pathLayer.lineWidth = 3.0f;</div><div class="line">      [self.containerView.layer addSublayer:pathLayer];</div><div class="line">      //add the ship</div><div class="line">      self.shipLayer = [CALayer layer];</div><div class="line">      self.shipLayer.frame = CGRectMake(0, 0, 64, 64);</div><div class="line">      self.shipLayer.position = CGPointMake(0, 150);</div><div class="line">      self.shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">      [self.containerView.layer addSublayer:self.shipLayer];</div><div class="line">      //set initial values</div><div class="line">      [self updateSliders];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  - (IBAction)updateSliders</div><div class="line">  &#123;</div><div class="line">      CFTimeInterval timeOffset = self.timeOffsetSlider.value;</div><div class="line">      self.timeOffsetLabel.text = [NSString stringWithFormat:@&quot;%0.2f&quot;, timeOffset];</div><div class="line">      float speed = self.speedSlider.value;</div><div class="line">      self.speedLabel.text = [NSString stringWithFormat:@&quot;%0.2f&quot;, speed];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  - (IBAction)play</div><div class="line">  &#123;</div><div class="line">      //create the keyframe animation</div><div class="line">      CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">      animation.keyPath = @&quot;position&quot;;</div><div class="line">      animation.timeOffset = self.timeOffsetSlider.value;</div><div class="line">      animation.speed = self.speedSlider.value;</div><div class="line">      animation.duration = 1.0;</div><div class="line">      animation.path = self.bezierPath.CGPath;</div><div class="line">      animation.rotationMode = kCAAnimationRotateAuto;</div><div class="line">      animation.removedOnCompletion = NO;</div><div class="line">      [self.shipLayer addAnimation:animation forKey:@&quot;slide&quot;];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-4a83c5d46df16476.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="9.3.png"></p>
<pre><code>**fillMode**
</code></pre><p>对于beginTime非0的一段动画来说，会出现一个当动画添加到图层上但什么也没发生的状态。类似的，removeOnCompletion被设置为NO<br>的动画将会在动画结束的时候仍然保持之前的状态。这就产生了一个问题，当动画开始之前和动画结束之后，被设置动画的属性将会是什么值呢？</p>
<p>一种可能是属性和动画没被添加之前保持一致，也就是在模型图层定义的值（见第七章“隐式动画”，模型图层和呈现图层的解释）。<br>另一种可能是保持动画开始之前那一帧，或者动画结束之后的那一帧。这就是所谓的填充，因为动画开始和结束的值用来填充开始之前和结束之后的时间。<br>这种行为就交给开发者了，它可以被CAMediaTiming的fillMode<br>来控制。fillMode是一个NSString类型，可以接受如下四种常量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kCAFillModeForwards </div><div class="line">kCAFillModeBackwards </div><div class="line">kCAFillModeBoth </div><div class="line">kCAFillModeRemoved</div></pre></td></tr></table></figure></p>
<p> 默认是kCAFillModeRemoved，当动画不再播放的时候就显示图层模型指定的值剩下的三种类型向前，向后或者即向前又向后去填充动画状态，使得动画在开始前或者结束后仍然保持开始和结束那一刻的值。</p>
<p>这就对避免在动画结束的时候急速返回提供另一种方案（见第八章）。但是记住了，当用它来解决这个问题的时候，需要把removeOnCompletion设置为NO，另外需要给动画添加一个非空的键，于是可以在不需要动画的时候把它从图层上移除。</p>
<p><strong>层级关系时间</strong></p>
<p> 在第三章“图层几何学”中，你已经了解到每个图层是如何相对在图层树中的父图层定义它的坐标系的。动画时间和它类似，每个动画和图层在时间上都有它自己的层级概念，相对于它的父亲来测量。对图层调整时间将会影响到它本身和子图层的动画，但不会影响到父图层。另一个相似点是所有的动画都被按照层级组合（使用CAAnimationGroup实例）。</p>
<p>对CALayer或者CAGroupAnimation调整duration和repeatCount/repeatDuration属性并不会影响到子动画。但是beginTime，timeOffset和speed属性将会影响到子动画。然而在层级关系中，beginTime指定了父图层开始动画（或者组合关系中的父动画）和对象将要开始自己动画之间的偏移。类似的，调整CALayer和CAGroupAnimation的speed属性将会对动画以及子动画速度应用一个缩放的因子。</p>
<p><strong>全局时间和本地时间</strong></p>
<p>CoreAnimation有一个全局时间的概念，也就是所谓的马赫时间（“马赫”实际上是<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>和Mac OS系统内核的命名）。马赫时间在设备上所有进程都是全局的–但是在不同设备上并不是全局的–不过这已经足够对动画的参考点提供便利了，你可以使用CACurrentMediaTime函数来访问马赫时间：<br><code>CFTimeInterval time = CACurrentMediaTime();</code><br>这个函数返回的值其实无关紧要（它返回了设备自从上次启动后的秒数，并不是你所关心的），它真实的作用在于对动画的时间测量提供了一个相对值。注意当设备休眠的时候马赫时间会暂停，也就是所有的CAAnimations（基于马赫时间）同样也会暂停。</p>
<p>因此马赫时间对长时间测量并不有用。比如用CACurrentMediaTime<br>去更新一个实时闹钟并不明智。（可以用[NSDate date]代替，就像第三章例子所示）。</p>
<p>每个CALayer和CAAnimation实例都有自己本地时间的概念，是根据父图层/动画层级关系中的beginTime，timeOffset和speed属性计算。就和转换不同图层之间坐标关系一样，CALayer同样也提供了方法来转换不同图层之间的本地时间。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> (CFTimeInterval)convertTime:(CFTimeInterval)t fromLayer:(CALayer *)l; </div><div class="line">- (CFTimeInterval)convertTime:(CFTimeInterval)t toLayer:(CALayer *)l;</div></pre></td></tr></table></figure></p>
<p>当用来同步不同图层之间有不同的speed，timeOffset和beginTime的动画，这些方法会很有用。</p>
<p><strong>暂停，倒回和快进</strong></p>
<p>设置动画的speed属性为0可以暂停动画，但在动画被添加到图层之后不太可能再修改它了，所以不能对正在进行的动画使用这个属性。给图层添加一个CAAnimation实际上是给动画对象做了一个不可改变的拷贝，所以对原始动画对象属性的改变对真实的动画并没有作用。相反，直接用-animationForKey:来检索图层正在进行的动画可以返回正确的动画对象，但是修改它的属性将会抛出异常。</p>
<p>如果移除图层正在进行的动画，图层将会急速返回动画之前的状态。但如果在动画移除之前拷贝呈现图层到模型图层，动画将会看起来暂停在那里。但是不好的地方在于之后就不能再恢复动画了。</p>
<p>一个简单的方法是可以利用CAMediaTiming来暂停图层本身。如果把图层的speed设置成0，它会暂停任何添加到图层上的动画。类似的，设置speed大于1.0将会快进，设置成一个负值将会倒回动画。</p>
<p>通过增加主窗口图层的speed，可以暂停整个应用程序的动画。这对UI自动化提供了好处，我们可以加速所有的视图动画来进行自动化测试（注意对于在主窗口之外的视图并不会被影响，比如UIAlertview<br>）。可以在app delegate设置如下进行验证：</p>
<p><code>self.window.layer.speed = 100;</code></p>
<p>你也可以通过这种方式来减速，但其实也可以在模拟器通过切换慢速动画来实现</p>
<p><strong>手动动画</strong><br> timeOffset一个很有用的功能在于你可以它可以让你手动控制动画进程，通过设置speed为0，可以禁用动画的自动播放，然后来使用timeOffset来来回显示动画序列。这可以使得运用手势来手动控制动画变得很简单。</p>
<p>举个简单的例子：还是之前关门的动画，修改代码来用手势控制动画。我们给视图添加一个UIPanGestureRecognizer，然后用timeOffset左右摇晃。</p>
<p>因为在动画添加到图层之后不能再做修改了，我们来通过调整layer的timeOffset达到同样的效果（清单9.4）。</p>
<p>#####清单9.4 通过触摸手势手动控制动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) UIView *containerView;</div><div class="line">   @property (nonatomic, strong) CALayer *doorLayer;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //add the door</div><div class="line">       self.doorLayer = [CALayer layer];</div><div class="line">       self.doorLayer.frame = CGRectMake(0, 0, 128, 256);</div><div class="line">       self.doorLayer.position = CGPointMake(150 - 64, 150);</div><div class="line">       self.doorLayer.anchorPoint = CGPointMake(0, 0.5);</div><div class="line">       self.doorLayer.contents = (__bridge id)[UIImage imageNamed:@&quot;Door.png&quot;].CGImage;</div><div class="line">       [self.containerView.layer addSublayer:self.doorLayer];</div><div class="line">       //apply perspective transform</div><div class="line">       CATransform3D perspective = CATransform3DIdentity;</div><div class="line">       perspective.m34 = -1.0 / 500.0;</div><div class="line">       self.containerView.layer.sublayerTransform = perspective;</div><div class="line">       //add pan gesture recognizer to handle swipes</div><div class="line">       UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] init];</div><div class="line">       [pan addTarget:self action:@selector(pan:)];</div><div class="line">       [self.view addGestureRecognizer:pan];</div><div class="line">       //pause all layer animations</div><div class="line">       self.doorLayer.speed = 0.0;</div><div class="line">       //apply swinging animation (which won&apos;t play because layer is paused)</div><div class="line">       CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">       animation.keyPath = @&quot;transform.rotation.y&quot;;</div><div class="line">       animation.toValue = @(-M_PI_2);</div><div class="line">       animation.duration = 1.0;</div><div class="line">       [self.doorLayer addAnimation:animation forKey:nil];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)pan:(UIPanGestureRecognizer *)pan</div><div class="line">   &#123;</div><div class="line">       //get horizontal component of pan gesture</div><div class="line">       CGFloat x = [pan translationInView:self.view].x;</div><div class="line">       //convert from points to animation duration //using a reasonable scale factor</div><div class="line">       x /= 200.0f;</div><div class="line">       //update timeOffset and clamp result</div><div class="line">       CFTimeInterval timeOffset = self.doorLayer.timeOffset;</div><div class="line">       timeOffset = MIN(0.999, MAX(0.0, timeOffset - x));</div><div class="line">       self.doorLayer.timeOffset = timeOffset;</div><div class="line">       //reset pan gesture</div><div class="line">       [pan setTranslation:CGPointZero inView:self.view];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p> 这其实是个小诡计，也许相对于设置个动画然后每次显示一帧而言，用移动手势来直接设置门的transform会更简单。</p>
<p>在这个例子中的确是这样，但是对于比如说关键这这样更加复杂的情况，或者有多个图层的动画组，相对于实时计算每个图层的属性而言，这就显得方便的多了。</p>
<p>#####总结<br>在这一章，我们了解了CAMediaTiming协议，以及Core Animation用来操作时间控制动画的机制。在下一章，我们将要接触缓冲，另一个用来使动画更加真实的操作时间的技术。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之贝塞尔曲线（加入购物车动画）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之贝塞尔曲线（加入购物车动画）/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1694376-c32df5200c40e600.gif?imageMogr2/auto-orient/strip" alt="12.gif"></p>
<blockquote>
<p><strong>加入购物车这个动画关键是贝塞尔曲线的绘制，然后给购物车加上一个关键帧动画即可。</strong></p>
</blockquote>
<p>贝塞尔曲线的起点从cell 中button开始，到购物车位置结束，控制点取 起点的纵坐标，终点的横坐标。<br>因为不在一个坐标系内，所以我们需要转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;</div><div class="line">- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;</div><div class="line">- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;</div><div class="line">- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;</div></pre></td></tr></table></figure></p>
<p><strong>在这里我们把购物车以及 cell 上的加入购物车按钮 全部转换到selv.view上（ps:本来想把购物车的中心点转化到tableview，上，把动画封装在cell的button 点击事件里，可是失败了， 代理方法会走，但是没有动画效果😢）</strong></p>
<blockquote>
<p>cell 中的回调处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[self layoutIfNeeded];//xib初始化，需要获得正确的frame</div><div class="line">   </div><div class="line">   CGPoint carButtonCenter = sender.center;</div><div class="line">   </div><div class="line">   //把button在cell坐标转化为在tableView上的坐标</div><div class="line">   CGPoint point = [self convertPoint:carButtonCenter toView:self.superview.superview];</div><div class="line">   </div><div class="line">   //回调</div><div class="line">   if (_shoppingButtonBlock)</div><div class="line">   &#123;</div><div class="line">       _shoppingButtonBlock(point);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>viewcontroller中的处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    MyCell *cell =[tableView dequeueReusableCellWithIdentifier:cellId];</div><div class="line">    if (!cell) &#123;</div><div class="line">        cell =[[MyCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    __weak ViewController *weakSelf = self;</div><div class="line">    [cell setShoppingButtonBlock:^(CGPoint centerPoint) &#123;</div><div class="line">        //关键帧动画处理</div><div class="line">        [weakSelf startAnimate:centerPoint];</div><div class="line">    &#125;];</div><div class="line">   </div><div class="line">    return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以把CAShapeLayer去掉，只是为了直观的看到动画效果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimate:(CGPoint)centerPoint</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    CGPoint startPoint = [self.tableview convertPoint:centerPoint toView:self.view];;</div><div class="line">    CGPoint endpoint = self.shopView.center;</div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(endpoint.x, startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:startPoint];</div><div class="line">    [path addQuadCurveToPoint:endpoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [self.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    </div><div class="line">    [self.shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>还是将动画抽取出来，只需要起点和终点以及动画宿主视图,实现解耦。</p>
</blockquote>
<p>定义一个NSObject类，接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@interface AddToShopAnimation : NSObject</div><div class="line">-(instancetype)initWithStartPoint:(CGPoint)startPoint entPoint:(CGPoint)endPoint ViewController:(UIViewController *)viewController HostView:(UIView *)shopView;</div><div class="line">-(void)startAnimation;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimation</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    </div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(_endPoint.x, _startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:_startPoint];</div><div class="line">    [path addQuadCurveToPoint:_endPoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [_viewController.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    [_shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>demo地址：<a href="https://github.com/liuxinixn/UIBezierPathAddtoShop" target="_blank" rel="noopener">贝塞尔曲线之加入购物车</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg"
              alt="雪晟" />
          
            <p class="site-author-name" itemprop="name">雪晟</p>
            <p class="site-description motion-element" itemprop="description">多去尝试你从未尝试的。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">98</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liuxinixn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/3d7c50f31b88" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-flag"></i>Jianshu</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雪晟</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
