<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="如果想让事情变得顺利，只有靠自己 – 夏尔·纪尧姆  上一章介绍了隐式动画的概念。隐式动画是在iOS平台创建动态用户界面的一种直接方式，也是UIKit动画机制的基础，不过它并不能涵盖所有的动画类型。在这一章中，我们将要研究一下显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。 #####属性动画首先我们来探讨一下属性动画。属性动画作用于图层的某个单一属性">
<meta property="og:type" content="article">
<meta property="og:title" content="CoreAnimation之显示动画">
<meta property="og:url" content="liuxinixn.github.io/2016/05/13/CoreAnimation之显示动画/index.html">
<meta property="og:site_name" content="雪晟">
<meta property="og:description" content="如果想让事情变得顺利，只有靠自己 – 夏尔·纪尧姆  上一章介绍了隐式动画的概念。隐式动画是在iOS平台创建动态用户界面的一种直接方式，也是UIKit动画机制的基础，不过它并不能涵盖所有的动画类型。在这一章中，我们将要研究一下显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。 #####属性动画首先我们来探讨一下属性动画。属性动画作用于图层的某个单一属性">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1694376-b656b6df2d935ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1694376-07bb86da115815c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1694376-304e99329e4d21fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1694376-6a0f100cbb16306c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1694376-9855be160cbe4c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1694376-aa8e3c239a61eb22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1694376-acf5535f7530a9ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-12-29T12:44:48.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CoreAnimation之显示动画">
<meta name="twitter:description" content="如果想让事情变得顺利，只有靠自己 – 夏尔·纪尧姆  上一章介绍了隐式动画的概念。隐式动画是在iOS平台创建动态用户界面的一种直接方式，也是UIKit动画机制的基础，不过它并不能涵盖所有的动画类型。在这一章中，我们将要研究一下显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。 #####属性动画首先我们来探讨一下属性动画。属性动画作用于图层的某个单一属性">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1694376-b656b6df2d935ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxinixn.github.io/2016/05/13/CoreAnimation之显示动画/"/>





  <title>CoreAnimation之显示动画 | 雪晟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雪晟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">十年饮冰，难凉热血。我是雪晟。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/13/CoreAnimation之显示动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CoreAnimation之显示动画</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-13T20:19:35+08:00">
                2016-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>如果想让事情变得顺利，只有靠自己 – 夏尔·纪尧姆</p>
</blockquote>
<p>上一章介绍了隐式动画的概念。隐式动画是在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>平台创建动态用户界面的一种直接方式，也是UIKit动画机制的基础，不过它并不能涵盖所有的动画类型。在这一章中，我们将要研究一下显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。</p>
<p>#####属性动画<br>首先我们来探讨一下属性动画。属性动画作用于图层的某个单一属性，并指定了它的一个目标值，或者一连串将要做动画的值。属性动画分为两种：基础和关键帧。</p>
<p>#####基础动画<br>动画其实就是一段时间内发生的改变，最简单的形式就是从一个值改变到另一个值，这也是CABasicAnimation最主要的功能。CABasicAnimation是CAPropertyAnimation的一个子类，而CAPropertyAnimation的父类是CAAnimation，CAAnimation同时也是Core Animation所有动画类型的抽象基类。作为一个抽象类，CAAnimation本身并没有做多少工作，它提供了一个计时函数（见第十章“缓冲”），一个委托（用于反馈动画状态）以及一个removedOnCompletion，用于标识动画是否该在结束后自动释放（默认YES，为了防止内存泄露）。CAAnimation同时实现了一些协议，包括CAAction（允许CAAnimation的子类可以提供图层行为），以及CAMediaTiming（第九章“图层时间”将会详细解释）。</p>
<p>CAPropertyAnimation通过指定动画的keyPath作用于一个单一属性，CAAnimation通常应用于一个指定的CALayer，于是这里指的也就是一个图层的keyPath了。实际上它是一个关键路径（一些用点表示法可以在层级关系中指向任意嵌套的对象），而不仅仅是一个属性的名称，因为这意味着动画不仅可以作用于图层本身的属性，而且还包含了它的子成员的属性，甚至是一些虚拟的属性（后面会详细解释）。</p>
<p>CABasicAnimation继承于CAPropertyAnimation，并添加了如下属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id fromValue </div><div class="line">id toValue </div><div class="line">id byValue</div></pre></td></tr></table></figure></p>
<p> 从命名就可以得到很好的解释：fromValue代表了动画开始之前属性的值，toValue代表了动画结束之后的值，byValue代表了动画执行过程中改变的值。</p>
<p>通过组合这三个属性就可以有很多种方式来指定一个动画的过程。它们被定义成id类型而不是一些具体的类型是因为属性动画可以用作很多不同种的属性类型，包括数字类型，矢量，变换矩阵，甚至是颜色或者图片。</p>
<p>id类型可以包含任意由NSObject派生的对象，但有时候你会希望对一些不直接从NSObject继承的属性类型做动画，这意味着你需要把这些值用一个对象来封装，或者强转成一个对象，就像某些功能和Objective-C对象类似的Core Foundation类型。但是如何从一个具体的数据类型转换成id看起来并不明显，一些普通的例子见表8.1。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-b656b6df2d935ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.png"><br> fromValue，toValue和byValue属性可以用很多种方式来组合，但为了防止冲突，不能一次性同时指定这三个值。例如，如果指定了fromValue等于2，toValue等于4，byValue等于3，那么Core Animation就不知道结果到底是4（toValue）还是5（fromValue + byValue）了。他们的用法在CABasicAnimation头文件中已经描述的很清楚了，所以在这里就不重复了。总的说来，就是只需要指定toValue或者byValue，剩下的值都可以通过上下文自动计算出来。</p>
<p>举个例子：我们修改一下第七章中的颜色渐变的动画，用显式的CABasicAnimation来取代之前的隐式动画，代码见清单8.1。</p>
<p>#####清单8.1 通过CABasicAnimation来设置图层背景色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"> </div><div class="line"> @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line"> @property (nonatomic, strong) IBOutlet CALayer *colorLayer;</div><div class="line"> </div><div class="line"> @end</div><div class="line"> </div><div class="line"> @implementation ViewController</div><div class="line"> </div><div class="line"> - (void)viewDidLoad</div><div class="line"> &#123;</div><div class="line">     [super viewDidLoad];</div><div class="line">     //create sublayer</div><div class="line">     self.colorLayer = [CALayer layer];</div><div class="line">     self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">     self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">     //add it to our view</div><div class="line">     [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> - (IBAction)changeColor</div><div class="line"> &#123;</div><div class="line">     ￼//create a new random color</div><div class="line">     CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">     CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">     CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">     UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];</div><div class="line">     //create a basic animation</div><div class="line">     CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">     animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">     animation.toValue = (__bridge id)color.CGColor;</div><div class="line">     //apply animation to layer</div><div class="line">     [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，结果有点差强人意，点击按钮，的确可以使图层动画过渡到一个新的颜色，然动画结束之后又立刻变回原始值。</p>
<p>这是因为动画并没有改变图层的模型，而只是呈现（第七章）。一旦动画结束并从图层上移除之后，图层就立刻恢复到之前定义的外观状态。我们从没改变过backgroundColor<br>属性，所以图层就返回到原始的颜色。</p>
<p>当之前在使用隐式动画的时候，实际上它就是用例子中CABasicAnimation来实现的（回忆第七章，我们在-actionForLayer:forKey:委托方法打印出来的结果就是CABasicAnimation）。但是在那个例子中，我们通过设置属性来打开动画。在这里我们做了相同的动画，但是并没有设置任何属性的值（这就是为什么会立刻变回初始状态的原因）。</p>
<p>把动画设置成一个图层的行为（然后通过改变属性值来启动动画）是到目前为止同步属性值和动画状态最简单的方式了，假设由于某些原因我们不能这么做（通常因为UIView关联的图层不能这么做动画），那么有两种可以更新属性值的方式：在动画开始之前或者动画结束之后。</p>
<p>动画之前改变属性的值是最简单的办法，但这意味着我们不能使用fromValue这么好的特性了，而且要手动将fromValue设置成图层当前的值。</p>
<p>于是在动画创建之前插入如下代码，就可以解决问题了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">animation.fromValue = (__bridge id)self.colorLayer.backgroundColor; </div><div class="line">self.colorLayer.backgroundColor = color.CGColor;</div></pre></td></tr></table></figure></p>
<p>这的确是可行的，但还是有些问题，如果这里已经正在进行一段动画，我们需要从呈现图层那里去获得fromValue，而不是模型图层。另外，由于这里的图层并不是UIView关联的图层，我们需要用CATransaction来禁用隐式动画行为，否则默认的图层行为会干扰我们的显式动画（实际上，显式动画通常会覆盖隐式动画，但在文章中并没有提到，所以为了安全最好这么做）。</p>
<p>更新之后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CALayer *layer = self.colorLayer.presentationLayer ?:self.colorLayer; </div><div class="line">animation.fromValue = (__bridge id)layer.backgroundColor;</div><div class="line">[CATransaction begin];</div><div class="line">[CATransaction setDisableActions:YES];</div><div class="line">self.colorLayer.backgroundColor = color.CGColor;[CATransaction commit];</div></pre></td></tr></table></figure></p>
<p> 如果给每个动画都添加这些，代码会显得特别臃肿。幸运的是，我们可以从CABasicAnimation去自动设置这些。于是可以创建一个可复用的代码。清单8.2修改了之前的示例，通过使用CABasicAnimation的一个函数来避免在每次动画时候都重复那些臃肿的代码。</p>
<p>#####清单8.2 修改动画立刻恢复到原始状态的一个可复用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)applyBasicAnimation:(CABasicAnimation *)animation toLayer:(CALayer *)layer</div><div class="line">   &#123;</div><div class="line">       </div><div class="line">       //set the from value (using presentation layer if available)</div><div class="line">       animation.fromValue = [layer.presentationLayer ?: layer valueForKeyPath:animation.keyPath];</div><div class="line">       //update the property in advance</div><div class="line">       //note: this approach will only work if toValue != nil</div><div class="line">       [CATransaction begin];</div><div class="line">       [CATransaction setDisableActions:YES];</div><div class="line">       [layer setValue:animation.toValue forKeyPath:animation.keyPath];</div><div class="line">       [CATransaction commit];</div><div class="line">       //apply animation to layer</div><div class="line">       [layer addAnimation:animation forKey:nil];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (IBAction)changeColor</div><div class="line">   &#123;</div><div class="line">       //create a new random color</div><div class="line">       CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];</div><div class="line">       //create a basic animation</div><div class="line">       CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">       animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">       animation.toValue = (__bridge id)color.CGColor;</div><div class="line">       //apply animation without snap-back</div><div class="line">       [self applyBasicAnimation:animation toLayer:self.colorLayer];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p> 这种简单的实现方式通过toValue而不是byValue来处理动画，不过这已经是朝更好的解决方案迈出一大步了。你可以把它添加给CALayer作为一个分类，以方便更好地使用。</p>
<p>解决看起来如此简单的一个问题都着实麻烦，但是别的方案会更加复杂。如果不在动画开始之前去更新目标属性，那么就只能在动画完全结束或者取消的时候更新它。这意味着我们需要精准地在动画结束之后，图层返回到原始值之前更新属性。那么该如何找到这个点呢？</p>
<p>#####CAAnimationDelegate<br>在第七章使用隐式动画的时候，我们可以在CATransaction<br>完成块中检测到动画的完成。但是这种方式并不适用于显式动画，因为这里的动画和事务并没太多关联。</p>
<p>那么为了知道一个显式动画在何时结束，我们需要使用一个实现了CAAnimationDelegate协议的delegate。</p>
<p>CAAnimationDelegate在任何头文件中都找不到，但是可以在CAAnimation头文件或者苹果开发者文档中找到相关函数。在这个例子中，我们用-animationDidStop:finished:<br>方法在动画结束之后来更新图层的backgroundColor。</p>
<p>当更新属性的时候，我们需要设置一个新的事务，并且禁用图层行为。否则动画会发生两次，一个是因为显式的CABasicAnimation，另一次是因为隐式动画，具体实现见订单8.3。</p>
<p>#####清单8.3 动画完成之后修改图层的背景色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create sublayer</div><div class="line">    self.colorLayer = [CALayer layer];</div><div class="line">    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">    //add it to our view</div><div class="line">    [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)changeColor</div><div class="line">&#123;</div><div class="line">    //create a new random color</div><div class="line">    CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];</div><div class="line">    //create a basic animation</div><div class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">    animation.toValue = (__bridge id)color.CGColor;</div><div class="line">    animation.delegate = self;</div><div class="line">    //apply animation to layer</div><div class="line">    [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    //set the backgroundColor property to match animation toValue</div><div class="line">    [CATransaction begin];</div><div class="line">    [CATransaction setDisableActions:YES];</div><div class="line">    self.colorLayer.backgroundColor = (__bridge CGColorRef)anim.toValue;</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>对CAAnimation而言，使用委托模式而不是一个完成块会带来一个问题，就是当你有多个动画的时候，无法在在回调方法中区分。在一个视图控制器中创建动画的时候，通常会用控制器本身作为一个委托（如清单8.3所示），但是所有的动画都会调用同一个回调方法，所以你就需要判断到底是那个图层的调用。</p>
<p> 考虑一下第三章的闹钟，“图层几何学”，我们通过简单地每秒更新指针的角度来实现一个钟，但如果指针动态地转向新的位置会更加真实。</p>
<p>我们不能通过隐式动画来实现因为这些指针都是UIView的实例，所以图层的隐式动画都被禁用了。我们可以简单地通过UIView的动画方法来实现。但如果想更好地控制动画时间，使用显式动画会更好（更多内容见第十章）。使用CABasicAnimation来做动画可能会更加复杂，因为我们需要在-animationDidStop:finished:中检测指针状态（用于设置结束的位置）。<br> 动画本身会作为一个参数传入委托的方法，也许你会认为可以控制器中把动画存储为一个属性，然后在回调用比较，但实际上并不起作用，因为委托传入的动画参数是原始值的一个深拷贝，从而不是同一个值。</p>
<p>当使用-addAnimation:forKey:把动画添加到图层，这里有一个到目前为止我们都设置为nil的key参数。这里的键是-animationForKey:方法找到对应动画的唯一标识符，而当前动画的所有键都可以用animationKeys获取。如果我们对每个动画都关联一个唯一的键，就可以对每个图层循环所有键，然后调用-animationForKey:来比对结果。尽管这不是一个优雅的实现。</p>
<p>幸运的是，还有一种更加简单的方法。像所有的NSObject子类一样，CAAnimation实现了KVC（键-值-编码）协议，于是你可以用-setValue:forKey:和-valueForKey:方法来存取属性。但是CAAnimation有一个不同的性能：它更像一个NSDictionary，可以让你随意设置键值对，即使和你使用的动画类所声明的属性并不匹配。</p>
<p>这意味着你可以对动画用任意类型打标签。在这里，我们给UIView类型的指针添加的动画，所以可以简单地判断动画到底属于哪个视图，然后在委托方法中用这个信息正确地更新钟的指针（清单8.4）。</p>
<p>#####清单8.4 使用KVC对动画打标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *hourHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *secondHand;</div><div class="line">@property (nonatomic, weak) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //adjust anchor points</div><div class="line">    self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">    //start timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">    //set initial hand positions</div><div class="line">    [self updateHandsAnimated:NO];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tick</div><div class="line">&#123;</div><div class="line">    [self updateHandsAnimated:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateHandsAnimated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    //convert time to hours, minutes and seconds</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">    CGFloat hourAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">    //calculate hour hand angle //calculate minute hand angle</div><div class="line">    CGFloat minuteAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">    //calculate second hand angle</div><div class="line">    CGFloat secondAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">    //rotate hands</div><div class="line">    [self setAngle:hourAngle forHand:self.hourHand animated:animated];</div><div class="line">    [self setAngle:minuteAngle forHand:self.minuteHand animated:animated];</div><div class="line">    [self setAngle:secondAngle forHand:self.secondHand animated:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setAngle:(CGFloat)angle forHand:(UIView *)handView animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    //generate transform</div><div class="line">    CATransform3D transform = CATransform3DMakeRotation(angle, 0, 0, 1);</div><div class="line">    if (animated) &#123;</div><div class="line">        //create transform animation</div><div class="line">        CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">        [self updateHandsAnimated:NO];</div><div class="line">        animation.keyPath = @&quot;transform&quot;;</div><div class="line">        animation.toValue = [NSValue valueWithCATransform3D:transform];</div><div class="line">        animation.duration = 0.5;</div><div class="line">        animation.delegate = self;</div><div class="line">        [animation setValue:handView forKey:@&quot;handView&quot;];</div><div class="line">        [handView.layer addAnimation:animation forKey:nil];</div><div class="line">    &#125; else &#123;</div><div class="line">        //set transform directly</div><div class="line">        handView.layer.transform = transform;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    //set final position for hand view</div><div class="line">    UIView *handView = [anim valueForKey:@&quot;handView&quot;];</div><div class="line">    handView.layer.transform = [anim.toValue CATransform3DValue];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 我们成功的识别出每个图层停止动画的时间，然后更新它的变换到一个新值，很好。</p>
<p>不幸的是，即使做了这些，还是有个问题，清单8.4在模拟器上运行的很好，但当真正跑在iOS设备上时，我们发现在-animationDidStop:finished:委托方法调用之前，指针会迅速返回到原始值，这个清单8.3图层颜色发生的情况一样。</p>
<p>问题在于回调方法在动画完成之前已经被调用了，但不能保证这发生在属性动画返回初始状态之前。这同时也很好地说明了为什么要在真实的设备上测试动画代码，而不仅仅是模拟器。</p>
<p>我们可以用一个fillMode属性来解决这个问题，下一章会详细说明，这里知道在动画之前设置它比在动画结束之后更新属性更加方便。</p>
<p>#####关键帧动画<br>CABasicAnimation揭示了大多数隐式动画背后依赖的机制，这的确很有趣，但是显式地给图层添加CABasicAnimation<br>相较于隐式动画而言，只能说费力不讨好。</p>
<p>CAKeyframeAnimation是另一种UIKit没有暴露出来但功能强大的类。和CABasicAnimatio类似，CAKeyframeAnimation同样是CAPropertyAnimation<br>的一个子类，它依然作用于单一的一个属性，但是和CABasicAnimation不一样的是，它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。</p>
<p>关键帧起源于传动动画，意思是指主导的动画在显著改变发生时重绘当前帧（也就是关键帧），每帧之间剩下的绘制（可以通过关键帧推算出）将由熟练的艺术家来完成。CAKeyframeAnimation也是同样的道理：你提供了显著的帧，然后Core Animation在每帧之间进行插入。</p>
<p>我们可以用之前使用颜色图层的例子来演示，设置一个颜色的数组，然后通过关键帧动画播放出来（清单8.5）</p>
<p>#####清单8.5 使用CAKeyframeAnimation应用一系列颜色的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (IBAction)changeColor</div><div class="line">&#123;</div><div class="line">    //create a keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">    animation.duration = 2.0;</div><div class="line">    animation.values = @[</div><div class="line">                         (__bridge id)[UIColor blueColor].CGColor,</div><div class="line">                         (__bridge id)[UIColor redColor].CGColor,</div><div class="line">                         (__bridge id)[UIColor greenColor].CGColor,</div><div class="line">                         (__bridge id)[UIColor blueColor].CGColor ];</div><div class="line">    //apply animation to layer</div><div class="line">    [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意到序列中开始和结束的颜色都是蓝色，这是因为CAKeyframeAnimation并不能自动把当前值作为第一帧（就像CABasicAnimation那样把fromValue设为nil）。动画会在开始的时候突然跳转到第一帧的值，然后在动画结束的时候突然恢复到原始的值。所以为了动画的平滑特性，我们需要开始和结束的关键帧来匹配当前属性的值。</p>
<p>当然可以创建一个结束和开始值不同的动画，那样的话就需要在动画启动之前手动更新属性和最后一帧的值保持一致，就和之前讨论的一样。</p>
<p>我们用duration<br>属性把动画时间从默认的0.25秒增加到2秒，以便于动画做的不那么快。运行它，你会发现动画通过颜色不断循环，但效果看起来有些奇怪。原因在于动画以一个恒定的步调在运行。当在每个动画之间过渡的时候并没有减速，这就产生了一个略微奇怪的效果，为了让动画看起来更自然，我们需要调整一下缓冲，第十章将会详细说明。</p>
<p>提供一个数组的值就可以按照颜色变化做动画，但一般来说用数组来描述动画运动并不直观。CAKeyframeAnimation<br>有另一种方式去指定动画，就是使用CGPath。path<br>属性可以用一种直观的方式，使用Core Graphics函数定义运动序列来绘制动画。</p>
<p>我们来用一个宇宙飞船沿着一个简单曲线的实例演示一下。为了创建路径，我们需要使用一个三次贝塞尔曲线，它是一种使用开始点，结束点和另外两个控制点来定义形状的曲线，可以通过使用一个基于C的Core Graphics绘图指令来创建，不过用UIKit提供的UIBezierPath类会更简单。</p>
<p>我们这次用CAShapeLayer来在屏幕上绘制曲线，尽管对动画来说并不是必须的，但这会让我们的动画更加形象。绘制完CGPath之后，我们用它来创建一个CAKeyframeAnimation，然后用它来应用到我们的宇宙飞船。代码见清单8.6，结果见图8.1。</p>
<p>#####清单8.6 沿着一个贝塞尔曲线对图层做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a path</div><div class="line">    UIBezierPath *bezierPath = [[UIBezierPath alloc] init];</div><div class="line">    [bezierPath moveToPoint:CGPointMake(0, 150)];</div><div class="line">    [bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];</div><div class="line">    //draw the path using a CAShapeLayer</div><div class="line">    CAShapeLayer *pathLayer = [CAShapeLayer layer];</div><div class="line">    pathLayer.path = bezierPath.CGPath;</div><div class="line">    pathLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    pathLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    pathLayer.lineWidth = 3.0f;</div><div class="line">    [self.containerView.layer addSublayer:pathLayer];</div><div class="line">    //add the ship</div><div class="line">    CALayer *shipLayer = [CALayer layer];</div><div class="line">    shipLayer.frame = CGRectMake(0, 0, 64, 64);</div><div class="line">    shipLayer.position = CGPointMake(0, 150);</div><div class="line">    shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">    [self.containerView.layer addSublayer:shipLayer];</div><div class="line">    //create the keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 4.0;</div><div class="line">    animation.path = bezierPath.CGPath;</div><div class="line">    [shipLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-07bb86da115815c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8..png"></p>
<p> 运行示例，你会发现飞船的动画有些不太真实，这是因为当它运动的时候永远指向右边，而不是指向曲线切线的方向。你可以调整它的affineTransform来对运动方向做动画，但很可能和其它的动画冲突。</p>
<p>幸运的是，苹果预见到了这点，并且给CAKeyFrameAnimation添加了一个rotationMode的属性。设置它为常量kCAAnimationRotateAuto（清单8.7），图层将会根据曲线的切线自动旋转（图8.2）。</p>
<p>#####清单8.7 通过rotationMode自动对齐图层到曲线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a path</div><div class="line">    ...</div><div class="line">    //create the keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 4.0;</div><div class="line">    animation.path = bezierPath.CGPath;</div><div class="line">    animation.rotationMode = kCAAnimationRotateAuto;</div><div class="line">    [shipLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-304e99329e4d21fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.png"></p>
<p>#####虚拟属性<br>之前提到过属性动画实际上是针对于关键路径而不是一个键，这就意味着可以对子属性甚至是虚拟属性做动画。但是虚拟属性到底是什么呢？</p>
<p>考虑一个旋转的动画：如果想要对一个物体做旋转的动画，那就需要作用于transform属性，因为CALayer<br>没有显式提供角度或者方向之类的属性，代码如清单8.8所示</p>
<p>#####清单8.8 用transform属性对图层做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add the ship</div><div class="line">    CALayer *shipLayer = [CALayer layer];</div><div class="line">    shipLayer.frame = CGRectMake(0, 0, 128, 128);</div><div class="line">    shipLayer.position = CGPointMake(150, 150);</div><div class="line">    shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">    [self.containerView.layer addSublayer:shipLayer];</div><div class="line">    //animate the ship rotation</div><div class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;transform&quot;;</div><div class="line">    animation.duration = 2.0;</div><div class="line">    animation.toValue = [NSValue valueWithCATransform3D: CATransform3DMakeRotation(M_PI, 0, 0, 1)];</div><div class="line">    [shipLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>这么做是可行的，但看起来更因为是运气而不是设计的原因，如果我们把旋转的值从M_PI（180度）调整到2 * M_PI（360度），然后运行程序，会发现这时候飞船完全不动了。这是因为这里的矩阵做了一次360度的旋转，和做了0度是一样的，所以最后的值根本没变。</p>
<p>现在继续使用M_PI，但这次用byValue而不是toValue。也许你会认为这和设置toValue结果一样，因为0 + 90度 == 90度，但实际上飞船的图片变大了，并没有做任何旋转，这是因为变换矩阵不能像角度值那样叠加。</p>
<p>那么如果需要独立于角度之外单独对平移或者缩放做动画呢？由于都需要我们来修改transform属性，实时地重新计算每个时间点的每个变换效果，然后根据这些创建一个复杂的关键帧动画，这一切都是为了对图层的一个独立做一个简单的动画.</p>
<p>幸运的是，有一个更好的解决方案：为了旋转图层，我们可以对transform.rotation关键路径应用动画，而不是transform本身（清单8.9）。</p>
<p>#####清单8.9 对虚拟的transform.rotation属性做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add the ship</div><div class="line">    CALayer *shipLayer = [CALayer layer];</div><div class="line">    shipLayer.frame = CGRectMake(0, 0, 128, 128);</div><div class="line">    shipLayer.position = CGPointMake(150, 150);</div><div class="line">    shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">    [self.containerView.layer addSublayer:shipLayer];</div><div class="line">    //animate the ship rotation</div><div class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;transform.rotation&quot;;</div><div class="line">    animation.duration = 2.0;</div><div class="line">    animation.byValue = @(M_PI * 2);</div><div class="line">    [shipLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>结果运行的特别好，用transform.rotation而不是transform做动画的好处如下：</p>
<ul>
<li>我们可以不通过关键帧一步旋转多于180度的动画。</li>
<li>可以用相对值而不是绝对值旋转（设置byValue而不是toValue）。</li>
<li>可以不用创建CATransform3D，而是使用一个简单的数值来指定角度。</li>
<li>不会和transform.position或者transform.scale冲突（同样是使用关键路径来做独立的动画属性）。</li>
</ul>
<p>transform.rotation属性有一个奇怪的问题是它其实并不存在。这是因为CATransform3D并不是一个对象，它实际上是一个结构体，也没有符合KVC相关属性，transform.rotation，实际上是一个CALayer用于处理动画变换的虚拟属性。</p>
<p>你不可以直接设置transform.rotation或者transform.scale，他们不能被直接使用。当你对他们做动画时，Core Animation自动地根据通过CAValueFunction来计算的值来更新transform属性</p>
<p> CAValueFunction用于把我们赋给虚拟的transform.rotation简单浮点值转换成真正的用于摆放图层的CATransform3D矩阵值。你可以通过设置CAPropertyAnimation的valueFunction属性来改变，于是你设置的函数将会覆盖默认的函数。</p>
<p>CAValueFunction看起来似乎是对那些不能简单相加的属性（例如变换矩阵）做动画的非常有用的机制，但由于CAValueFunction的实现细节是私有的，所以目前不能通过继承它来自定义。你可以通过使用苹果目前已近提供的常量（目前都是和变换矩阵的虚拟属性相关，所以没太多使用场景了，因为这些属性都有了默认的实现方式）。</p>
<p>#####动画组<br> CABasicAnimation和CAKeyframeAnimation仅仅作用于单独的属性，而CAAnimationGroup可以把这些动画组合在一起。CAAnimationGroup是另一个继承于CAAnimation的子类，它添加了一个animations数组的属性，用来组合别的动画。我们把清单8.6那种关键帧动画和调整图层背景色的基础动画组合起来（清单8.10），结果如图8.3所示。</p>
<p>#####清单8.10 组合关键帧动画和基础动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a path</div><div class="line">    UIBezierPath *bezierPath = [[UIBezierPath alloc] init];</div><div class="line">    [bezierPath moveToPoint:CGPointMake(0, 150)];</div><div class="line">    [bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];</div><div class="line">    //draw the path using a CAShapeLayer</div><div class="line">    CAShapeLayer *pathLayer = [CAShapeLayer layer];</div><div class="line">    pathLayer.path = bezierPath.CGPath;</div><div class="line">    pathLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    pathLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    pathLayer.lineWidth = 3.0f;</div><div class="line">    [self.containerView.layer addSublayer:pathLayer];</div><div class="line">    //add a colored layer</div><div class="line">    CALayer *colorLayer = [CALayer layer];</div><div class="line">    colorLayer.frame = CGRectMake(0, 0, 64, 64);</div><div class="line">    colorLayer.position = CGPointMake(0, 150);</div><div class="line">    colorLayer.backgroundColor = [UIColor greenColor].CGColor;</div><div class="line">    [self.containerView.layer addSublayer:colorLayer];</div><div class="line">    //create the position animation</div><div class="line">    CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];</div><div class="line">    animation1.keyPath = @&quot;position&quot;;</div><div class="line">    animation1.path = bezierPath.CGPath;</div><div class="line">    animation1.rotationMode = kCAAnimationRotateAuto;</div><div class="line">    //create the color animation</div><div class="line">    CABasicAnimation *animation2 = [CABasicAnimation animation];</div><div class="line">    animation2.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">    animation2.toValue = (__bridge id)[UIColor redColor].CGColor;</div><div class="line">    //create group animation</div><div class="line">    CAAnimationGroup *groupAnimation = [CAAnimationGroup animation];</div><div class="line">    groupAnimation.animations = @[animation1, animation2];</div><div class="line">    groupAnimation.duration = 4.0;</div><div class="line">    //add the animation to the color layer</div><div class="line">    [colorLayer addAnimation:groupAnimation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6a0f100cbb16306c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3.png"></p>
<p>#####过渡<br> 有时候对于iOS应用程序来说，希望能通过属性动画来对比较难做动画的布局进行一些改变。比如交换一段文本和图片，或者用一段网格视图来替换，等等。属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。</p>
<p>于是就有了过渡的概念。过渡并不像属性动画那样平滑地在两个值之间做动画，而是影响到整个图层的变化。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。</p>
<p>为了创建一个过渡动画，我们将使用CATransition，同样是另一个CAAnimation的子类，和别的子类不同，CATransition有一个type和subtype来标识变换效果。type属性是一个NSString类型，可以被设置成如下类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kCATransitionFromRight </div><div class="line">kCATransitionFromLeft </div><div class="line">kCATransitionFromTop </div><div class="line">kCATransitionFromBottom</div></pre></td></tr></table></figure></p>
<p> 一个简单的用CATransition来对非动画属性做动画的例子如清单8.11所示，这里我们对UIImage的image属性做修改，但是隐式动画或者CAPropertyAnimation都不能对它做动画，因为Core Animation不知道如何在插图图片。通过对图层应用一个淡入淡出的过渡，我们可以忽略它的内容来做平滑动画（图8.4），我们来尝试修改过渡的type常量来观察其它效果。</p>
<p>#####清单8.11 使用CATransition来对UIImageView做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *imageView;</div><div class="line">@property (nonatomic, copy) NSArray *images;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //set up images</div><div class="line">    self.images = @[[UIImage imageNamed:@&quot;Anchor.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Cone.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Igloo.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Spaceship.png&quot;]];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (IBAction)switchImage</div><div class="line">&#123;</div><div class="line">    //set up crossfade transition</div><div class="line">    CATransition *transition = [CATransition animation];</div><div class="line">    transition.type = kCATransitionFade;</div><div class="line">    //apply transition to imageview backing layer</div><div class="line">    [self.imageView.layer addAnimation:transition forKey:nil];</div><div class="line">    //cycle to next image</div><div class="line">    UIImage *currentImage = self.imageView.image;</div><div class="line">    NSUInteger index = [self.images indexOfObject:currentImage];</div><div class="line">    index = (index + 1) % [self.images count];</div><div class="line">    self.imageView.image = self.images[index];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>你可以从代码中看出，过渡动画和之前的属性动画或者动画组添加到图层上的方式一致，都是通过-addAnimation:forKey:方法。但是和属性动画不同的是，对指定的图层一次只能使用一次CATransition，因此，无论你对动画的键设置什么值，过渡动画都会对它的键设置成“transition”，也就是常量kCATransition。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-9855be160cbe4c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.4.png"></p>
<p>#####隐式过渡<br> CATransision可以对图层任何变化平滑过渡的事实使得它成为那些不好做动画的属性图层行为的理想候选。苹果当然意识到了这点，并且当设置了CALayer的content属性的时候，CATransition的确是默认的行为。但是对于视图关联的图层，或者是其他隐式动画的行为，这个特性依然是被禁用的，但是对于你自己创建的图层，这意味着对图层contents图片做的改动都会自动附上淡入淡出的动画。</p>
<p>我们在第七章使用CATransition作为一个图层行为来改变图层的背景色，当然backgroundColor属性可以通过正常的CAPropertyAnimation来实现，但这不是说不可以用CATransition来实行。</p>
<p>#####对图层树的动画<br>CATransition并不作用于指定的图层属性，这就是说你可以在即使不能准确得知改变了什么的情况下对图层做动画，例如，在不知道UITableView哪一行被添加或者删除的情况下，直接就可以平滑地刷新它，或者在不知道UIViewController内部的视图层级的情况下对两个不同的实例做过渡动画。</p>
<p>这些例子和我们之前所讨论的情况完全不同，因为它们不仅涉及到图层的属性，而且是整个图层树的改变–我们在这种动画的过程中手动在层级关系中添加或者移除图层。</p>
<p>这里用到了一个小诡计，要确保CATransition添加到的图层在过渡动画发生时不会在树状结构中被移除，否则CATransition将会和图层一起被移除。一般来说，你只需要将动画添加到被影响图层的superlayer。</p>
<p>在清单8.2中，我们展示了如何在UITabBarController切换标签的时候添加淡入淡出的动画。这里我们建立了默认的标签应用程序模板，然后用UITabBarControllerDelegate的-tabBarController:didSelectViewController:方法来应用过渡动画。我们把动画添加UITabBarController的视图图层上，于是在标签被替换的时候动画不会被移除。</p>
<p>#####清单8.12 对UITabBarController做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#import &quot;FirstViewController.h&quot;</div><div class="line">#import &quot;SecondViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">    @implementation AppDelegate</div><div class="line">    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">    &#123;</div><div class="line">        self.window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]];</div><div class="line">        UIViewController *viewController1 = [[FirstViewController alloc] init];</div><div class="line">        UIViewController *viewController2 = [[SecondViewController alloc] init];</div><div class="line">        self.tabBarController = [[UITabBarController alloc] init];</div><div class="line">        self.tabBarController.viewControllers = @[viewController1, viewController2];</div><div class="line">        self.tabBarController.delegate = self;</div><div class="line">        self.window.rootViewController = self.tabBarController;</div><div class="line">        [self.window makeKeyAndVisible];</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    - (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController</div><div class="line">    &#123;</div><div class="line">        ￼//set up crossfade transition</div><div class="line">        CATransition *transition = [CATransition animation];</div><div class="line">        transition.type = kCATransitionFade;</div><div class="line">        //apply transition to tab bar controller&apos;s view</div><div class="line">        [self.tabBarController.view.layer addAnimation:transition forKey:nil];</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p>#####自定义动画<br>我们证实了过渡是一种对那些不太好做平滑动画属性的强大工具，但是CATransition的提供的动画类型太少了。</p>
<p>更奇怪的是苹果通过<br>UIView+transitionFromView:toView:duration:options:completion:和+transitionWithView:duration:options:animations:<br>方法提供了Core Animation的过渡特性。但是这里的可用的过渡选项和CATransition的type属性提供的常量完全不同。UIView过渡方法中options参数可以由如下常量指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">UIViewAnimationOptionTransitionFlipFromLeft </div><div class="line">UIViewAnimationOptionTransitionFlipFromRight</div><div class="line">UIViewAnimationOptionTransitionCurlUp </div><div class="line">UIViewAnimationOptionTransitionCurlDown</div><div class="line">UIViewAnimationOptionTransitionCrossDissolve </div><div class="line">UIViewAnimationOptionTransitionFlipFromTop </div><div class="line">UIViewAnimationOptionTransitionFlipFromBottom</div></pre></td></tr></table></figure></p>
<p>除了UIViewAnimationOptionTransitionCrossDissolve之外，剩下的值和CATransition类型完全没关系。你可以用之前例子修改过的版本来测试一下（见清单8.13）。</p>
<p>#####清单8.13 使用UIKit提供的方法来做过渡动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *imageView;</div><div class="line">@property (nonatomic, copy) NSArray *images;</div><div class="line">@end</div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad]; //set up images</div><div class="line">    self.images = @[[UIImage imageNamed:@&quot;Anchor.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Cone.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Igloo.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Spaceship.png&quot;]];</div><div class="line">    - (IBAction)switchImage</div><div class="line">    &#123;</div><div class="line">        [UIView transitionWithView:self.imageView duration:1.0</div><div class="line">                           options:UIViewAnimationOptionTransitionFlipFromLeft</div><div class="line">                        animations:^&#123;</div><div class="line">                            //cycle to next image</div><div class="line">                            UIImage *currentImage = self.imageView.image;</div><div class="line">                            NSUInteger index = [self.images indexOfObject:currentImage];</div><div class="line">                            index = (index + 1) % [self.images count];</div><div class="line">                            self.imageView.image = self.images[index];</div><div class="line">                        &#125;</div><div class="line">                        completion:NULL];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p>文档暗示过在iOS5（带来了Core Image框架）之后，可以通过CATransition的filter属性，用CIFilter来创建其它的过渡效果。然是直到iOS6都做不到这点。试图对CATransition使用Core Image的滤镜完全没效果（但是在Mac OS中是可行的，也许文档是想表达这个意思）。<br> 因此，根据要实现的效果，你只用关心是用CATransition还是用UIView的过渡方法就可以了。希望下个版本的iOS系统可以通过CATransition很好的支持Core Image的过渡滤镜效果（或许甚至会有新的方法）。</p>
<p>但这并不意味着在iOS上就不能实现自定义的过渡效果了。这只是意味着你需要做一些额外的工作。就像之前提到的那样，过渡动画做基础的原则就是对原始的图层外观截图，然后添加一段动画，平滑过渡到图层改变之后那个截图的效果。如果我们知道如何对图层截图，我们就可以使用属性动画来代替CATransition或者是UIKit的过渡方法来实现动画。</p>
<p> 事实证明，对图层做截图还是很简单的。CALayer有一个-renderInContext:方法，可以通过把它绘制到Core Graphics的上下文中捕获当前内容的图片，然后在另外的视图中显示出来。如果我们把这个截屏视图置于原始视图之上，就可以遮住真实视图的所有变化，于是重新创建了一个简单的过渡效果。</p>
<p>清单8.14演示了一个基本的实现。我们对当前视图状态截图，然后在我们改变原始视图的背景色的时候对截图快速转动并且淡出，图8.5展示了我们自定义的过渡效果。</p>
<p>为了让事情更简单，我们用UIView -animateWithDuration:completion:方法来实现。虽然用CABasicAnimation可以达到同样的效果，但是那样的话我们就需要对图层的变换和不透明属性创建单独的动画，然后当动画结束的是哦户在CAAnimationDelegate中把coverView从屏幕中移除。</p>
<p>#####清单8.14 用renderInContext:创建自定义过渡效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">   - (IBAction)performTransition</div><div class="line">   &#123;</div><div class="line">       //preserve the current view snapshot</div><div class="line">       UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, YES, 0.0);</div><div class="line">       [self.view.layer renderInContext:UIGraphicsGetCurrentContext()];</div><div class="line">       UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">       //insert snapshot view in front of this one</div><div class="line">       UIView *coverView = [[UIImageView alloc] initWithImage:coverImage];</div><div class="line">       coverView.frame = self.view.bounds;</div><div class="line">       [self.view addSubview:coverView];</div><div class="line">       //update the view (we&apos;ll simply randomize the layer background color)</div><div class="line">       CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       self.view.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];</div><div class="line">       //perform animation (anything you like)</div><div class="line">       [UIView animateWithDuration:1.0 animations:^&#123;</div><div class="line">           //scale, rotate and fade the view</div><div class="line">           CGAffineTransform transform = CGAffineTransformMakeScale(0.01, 0.01);</div><div class="line">           transform = CGAffineTransformRotate(transform, M_PI_2);</div><div class="line">           coverView.transform = transform;</div><div class="line">           coverView.alpha = 0.0;</div><div class="line">       &#125; completion:^(BOOL finished) &#123;</div><div class="line">           //remove the cover view now we&apos;re finished with it</div><div class="line">           [coverView removeFromSuperview];</div><div class="line">       &#125;];</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-aa8e3c239a61eb22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5.png"></p>
<p>这里有个警告：-renderInContext:捕获了图层的图片和子图层，但是不能对子图层正确地处理变换效果，而且对视频和OpenGL内容也不起作用。但是用CATransition，或者用私有的截屏方式就没有这个限制了。</p>
<p>#####在动画过程中取消动画<br>之前提到过，你可以用-addAnimation:forKey:方法中的key参数来在添加动画之后检索一个动画，使用如下方法：</p>
<p><code>- (CAAnimation *)animationForKey:(NSString *)key;</code></p>
<p> 但并不支持在动画运行过程中修改动画，所以这个方法主要用来检测动画的属性，或者判断它是否被添加到当前图层中。</p>
<p>为了终止一个指定的动画，你可以用如下方法把它从图层移除掉：</p>
<p><code>- (void)removeAnimationForKey:(NSString *)key;</code><br>或者移除所有动画：</p>
<p><code>- (void)removeAllAnimations;</code></p>
<p> 动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置removedOnCompletion为NO，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>
<p>我们来扩展之前旋转飞船的示例，这里添加一个按钮来停止或者启动动画。这一次我们用一个非nil的值作为动画的键，以便之后可以移除它。-animationDidStop:finished:方法中的flag参数表明了动画是自然结束还是被打断，我们可以在控制台打印出来。如果你用停止按钮来终止动画，它会打印NO，如果允许它完成，它会打印YES。</p>
<p>清单8.15是更新后的示例代码，图8.6显示了结果。</p>
<p>#####清单8.15 开始和停止一个动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">   @property (nonatomic, strong) CALayer *shipLayer;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //add the ship</div><div class="line">       self.shipLayer = [CALayer layer];</div><div class="line">       self.shipLayer.frame = CGRectMake(0, 0, 128, 128);</div><div class="line">       self.shipLayer.position = CGPointMake(150, 150);</div><div class="line">       self.shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">       [self.containerView.layer addSublayer:self.shipLayer];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (IBAction)start</div><div class="line">   &#123;</div><div class="line">       //animate the ship rotation</div><div class="line">       CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">       animation.keyPath = @&quot;transform.rotation&quot;;</div><div class="line">       animation.duration = 2.0;</div><div class="line">       animation.byValue = @(M_PI * 2);</div><div class="line">       animation.delegate = self;</div><div class="line">       [self.shipLayer addAnimation:animation forKey:@&quot;rotateAnimation&quot;];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (IBAction)stop</div><div class="line">   &#123;</div><div class="line">       [self.shipLayer removeAnimationForKey:@&quot;rotateAnimation&quot;];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">   &#123;</div><div class="line">       //log that the animation stopped</div><div class="line">       NSLog(@&quot;The animation stopped (finished: %@)&quot;, flag? @&quot;YES&quot;: @&quot;NO&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-acf5535f7530a9ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.6.png"></p>
<p>#####总结<br> 这一章中，我们涉及了属性动画（你可以对单独的图层属性动画有更加具体的控制），动画组（把多个属性动画组合成一个独立单元）以及过度（影响整个图层，可以用来对图层的任何内容做任何类型的动画，包括子图层的添加和移除）。</p>
<p>在第九章中，我们继续学习CAMediaTiming协议，来看一看Core Animation是怎样处理逝去的时间。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/12/CoreAnimation之图层树/" rel="next" title="CoreAnimation之图层树">
                <i class="fa fa-chevron-left"></i> CoreAnimation之图层树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/15/CoreAnimation之隐式动画/" rel="prev" title="CoreAnimation之隐式动画">
                CoreAnimation之隐式动画 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg"
              alt="雪晟" />
          
            <p class="site-author-name" itemprop="name">雪晟</p>
            <p class="site-description motion-element" itemprop="description">多去尝试你从未尝试的。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">112</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liuxinixn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/3d7c50f31b88" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-flag"></i>Jianshu</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雪晟</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
