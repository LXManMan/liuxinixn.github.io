<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="我可以指导你，但是你必须按照我说的做。 – 骇客帝国  在第10章“缓冲”中，我们研究了CAMediaTimingFunction，它是一个通过控制动画缓冲来模拟物理效果例如加速或者减速来增强现实感的东西，那么如果想更加真实地模拟物理交互或者实时根据用户输入修改动画改怎么办呢？在这一章中，我们将继续探索一种能够允许我们精确地控制一帧一帧展示的基于定时器的动画。 #####定时帧动画看起来是用来显">
<meta property="og:type" content="article">
<meta property="og:title" content="CoreAnimation之基于定时器的动画">
<meta property="og:url" content="liuxinixn.github.io/2016/05/10/CoreAnimation之基于定时器的动画/index.html">
<meta property="og:site_name" content="雪晟">
<meta property="og:description" content="我可以指导你，但是你必须按照我说的做。 – 骇客帝国  在第10章“缓冲”中，我们研究了CAMediaTimingFunction，它是一个通过控制动画缓冲来模拟物理效果例如加速或者减速来增强现实感的东西，那么如果想更加真实地模拟物理交互或者实时根据用户输入修改动画改怎么办呢？在这一章中，我们将继续探索一种能够允许我们精确地控制一帧一帧展示的基于定时器的动画。 #####定时帧动画看起来是用来显">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/1694376-d283e91c630081dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2017-12-29T12:43:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="CoreAnimation之基于定时器的动画">
<meta name="twitter:description" content="我可以指导你，但是你必须按照我说的做。 – 骇客帝国  在第10章“缓冲”中，我们研究了CAMediaTimingFunction，它是一个通过控制动画缓冲来模拟物理效果例如加速或者减速来增强现实感的东西，那么如果想更加真实地模拟物理交互或者实时根据用户输入修改动画改怎么办呢？在这一章中，我们将继续探索一种能够允许我们精确地控制一帧一帧展示的基于定时器的动画。 #####定时帧动画看起来是用来显">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/1694376-d283e91c630081dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxinixn.github.io/2016/05/10/CoreAnimation之基于定时器的动画/"/>





  <title>CoreAnimation之基于定时器的动画 | 雪晟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雪晟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">十年饮冰，难凉热血。我是雪晟。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/10/CoreAnimation之基于定时器的动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">CoreAnimation之基于定时器的动画</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-10T20:19:35+08:00">
                2016-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <blockquote>
<p>我可以指导你，但是你必须按照我说的做。 – 骇客帝国</p>
</blockquote>
<p>在第10章“缓冲”中，我们研究了CAMediaTimingFunction，它是一个通过控制动画缓冲来模拟物理效果例如加速或者减速来增强现实感的东西，那么如果想更加真实地模拟物理交互或者实时根据用户输入修改动画改怎么办呢？在这一章中，我们将继续探索一种能够允许我们精确地控制一帧一帧展示的基于定时器的动画。</p>
<p>#####定时帧<br>动画看起来是用来显示一段连续的运动过程，但实际上当在固定位置上展示像素的时候并不能做到这一点。一般来说这种显示都无法做到连续的移动，能做的仅仅是足够快地展示一系列静态图片，只是看起来像是做了运动。</p>
<p>我们之前提到过<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>按照每秒60次刷新屏幕，然后CAAnimation计算出需要展示的新的帧，然后在每次屏幕更新的时候同步绘制上去，CAAnimation最机智的地方在于每次刷新需要展示的时候去计算插值和缓冲。</p>
<p>在第10章中，我们解决了如何自定义缓冲函数，然后根据需要展示的帧的数组来告诉CAKeyframeAnimation的实例如何去绘制。所有的Core Animation实际上都是按照一定的序列来显示这些帧，那么我们可以自己做到这些么？</p>
<p>#####NSTimer<br> 实际上，我们在第三章“图层几何学”中已经做过类似的东西，就是时钟那个例子，我们用了NSTimer来对钟表的指针做定时动画，一秒钟更新一次，但是如果我们把频率调整成一秒钟更新60次的话，原理是完全相同的。</p>
<p>我们来试着用NSTimer来修改第十章中弹性球的例子。由于现在我们在定时器启动之后连续计算动画帧，我们需要在类中添加一些额外的属性来存储动画的fromValue，toValue，duration和当前的timeOffset（见清单11.1）。</p>
<p>#####清单11.1 使用NSTimer实现弹性球动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line">@property (nonatomic, assign) NSTimeInterval duration;</div><div class="line">@property (nonatomic, assign) NSTimeInterval timeOffset;</div><div class="line">@property (nonatomic, strong) id fromValue;</div><div class="line">@property (nonatomic, strong) id toValue;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add ball image view</div><div class="line">    UIImage *ballImage = [UIImage imageNamed:@&quot;Ball.png&quot;];</div><div class="line">    self.ballView = [[UIImageView alloc] initWithImage:ballImage];</div><div class="line">    [self.containerView addSubview:self.ballView];</div><div class="line">    //animate</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //replay animation on tap</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">float interpolate(float from, float to, float time)</div><div class="line">&#123;</div><div class="line">    return (to - from) * time + from;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)interpolateFromValue:(id)fromValue toValue:(id)toValue time:(float)time</div><div class="line">&#123;</div><div class="line">    if ([fromValue isKindOfClass:[NSValue class]]) &#123;</div><div class="line">        //get type</div><div class="line">        const char *type = [(NSValue *)fromValue objCType];</div><div class="line">        if (strcmp(type, @encode(CGPoint)) == 0) &#123;</div><div class="line">            CGPoint from = [fromValue CGPointValue];</div><div class="line">            CGPoint to = [toValue CGPointValue];</div><div class="line">            CGPoint result = CGPointMake(interpolate(from.x, to.x, time), interpolate(from.y, to.y, time));</div><div class="line">            return [NSValue valueWithCGPoint:result];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //provide safe default implementation</div><div class="line">    return (time &lt; 0.5)? fromValue: toValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">float bounceEaseOut(float t)</div><div class="line">&#123;</div><div class="line">    if (t &lt; 4/11.0) &#123;</div><div class="line">        return (121 * t * t)/16.0;</div><div class="line">    &#125; else if (t &lt; 8/11.0) &#123;</div><div class="line">        return (363/40.0 * t * t) - (99/10.0 * t) + 17/5.0;</div><div class="line">    &#125; else if (t &lt; 9/10.0) &#123;</div><div class="line">        return (4356/361.0 * t * t) - (35442/1805.0 * t) + 16061/1805.0;</div><div class="line">    &#125;</div><div class="line">    return (54/5.0 * t * t) - (513/25.0 * t) + 268/25.0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //configure the animation</div><div class="line">    self.duration = 1.0;</div><div class="line">    self.timeOffset = 0.0;</div><div class="line">    self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    //stop the timer if it&apos;s already running</div><div class="line">    [self.timer invalidate];</div><div class="line">    //start the timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1/60.0</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(step:)</div><div class="line">                                                userInfo:nil</div><div class="line">                                                 repeats:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)step:(NSTimer *)step</div><div class="line">&#123;</div><div class="line">    //update time offset</div><div class="line">    self.timeOffset = MIN(self.timeOffset + 1/60.0, self.duration);</div><div class="line">    //get normalized time offset (in range 0 - 1)</div><div class="line">    float time = self.timeOffset / self.duration;</div><div class="line">    //apply easing</div><div class="line">    time = bounceEaseOut(time);</div><div class="line">    //interpolate position</div><div class="line">    id position = [self interpolateFromValue:self.fromValue</div><div class="line">                                     toValue:self.toValue</div><div class="line">                                        time:time];</div><div class="line">    //move ball view to new position</div><div class="line">    self.ballView.center = [position CGPointValue];</div><div class="line">    //stop the timer if we&apos;ve reached the end of the animation</div><div class="line">    if (self.timeOffset &gt;= self.duration) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>很赞，而且和基于关键帧例子的代码一样很多，但是如果想一次性在屏幕上对很多东西做动画，很明显就会有很多问题。</p>
<p>NSTimer并不是最佳方案，为了理解这点，我们需要确切地知道NSTimer是如何工作的。iOS上的每个线程都管理了一个NSRunloop，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项：</p>
<ul>
<li>处理触摸事件</li>
<li>发送和接受网络数据包</li>
<li>执行使用gcd的代码</li>
<li>处理计时器行为</li>
<li>屏幕重绘<br>当你设置一个NSTimer，他会被插入到当前任务列表中，然后直到指定时间过去之后才会被执行。但是何时启动定时器并没有一个时间上限，而且它只会在列表中上一个任务完成之后开始执行。这通常会导致有几毫秒的延迟，但是如果上一个任务过了很久才完成就会导致延迟很长一段时间。</li>
</ul>
<p>屏幕重绘的频率是一秒钟六十次，但是和定时器行为一样，如果列表中上一个执行了很长时间，它也会延迟。这些延迟都是一个随机值，于是就不能保证定时器精准地一秒钟执行六十次。有时候发生在屏幕重绘之后，这就会使得更新屏幕会有个延迟，看起来就是动画卡壳了。有时候定时器会在屏幕更新的时候执行两次，于是动画看起来就跳动了。</p>
<p>我们可以通过一些途径来优化：</p>
<pre><code>- 我们可以用CADisplayLink让更新频率严格控制在每次屏幕刷新之后。
</code></pre><ul>
<li>基于真实帧的持续时间而不是假设的更新频率来做动画。</li>
<li>调整动画计时器的run loop模式，这样就不会被别的事件干扰。</li>
</ul>
<p>#####CADisplayLink<br>CADisplayLink<br>是CoreAnimation提供的另一个类似于NSTimer的类，它总是在屏幕完成一次更新之前启动，它的接口设计的和NSTimer很类似，所以它实际上就是一个内置实现的替代，但是和timeInterval以秒为单位不同，CADisplayLink有一个整型的frameInterval属性，指定了间隔多少帧之后才执行。默认值是1，意味着每次屏幕更新之前都会执行一次。但是如果动画的代码执行起来超过了六十分之一秒，你可以指定frameInterval为2，就是说动画每隔一帧执行一次（一秒钟30帧）或者3，也就是一秒钟20次，等等。</p>
<p>用CADisplayLink而不是NSTimer，会保证帧率足够连续，使得动画看起来更加平滑，但即使CADisplayLink也不能保证每一帧都按计划执行，一些失去控制的离散的任务或者事件（例如资源紧张的后台程序）可能会导致动画偶尔地丢帧。当使用NSTimer的时候，一旦有机会计时器就会开启，但是CADisplayLink却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。</p>
<p>#####计算帧的持续时间<br> 无论是使用NSTimer还是CADisplayLink，我们仍然需要处理一帧的时间超出了预期的六十分之一秒。由于我们不能够计算出一帧真实的持续时间，所以需要手动测量。我们可以在每帧开始刷新的时候用CACurrentMediaTime()记录当前时间，然后和上一帧记录的时间去比较。</p>
<p>通过比较这些时间，我们就可以得到真实的每帧持续的时间，然后代替硬编码的六十分之一秒。我们来更新一下上个例子（见清单11.2）。</p>
<p>#####清单11.2 通过测量没帧持续的时间来使得动画更加平滑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line">@property (nonatomic, strong) CADisplayLink *timer;</div><div class="line">@property (nonatomic, assign) CFTimeInterval duration;</div><div class="line">@property (nonatomic, assign) CFTimeInterval timeOffset;</div><div class="line">@property (nonatomic, assign) CFTimeInterval lastStep;</div><div class="line">@property (nonatomic, strong) id fromValue;</div><div class="line">@property (nonatomic, strong) id toValue;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //configure the animation</div><div class="line">    self.duration = 1.0;</div><div class="line">    self.timeOffset = 0.0;</div><div class="line">    self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    //stop the timer if it&apos;s already running</div><div class="line">    [self.timer invalidate];</div><div class="line">    //start the timer</div><div class="line">    self.lastStep = CACurrentMediaTime();</div><div class="line">    self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                             selector:@selector(step:)];</div><div class="line">    [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                     forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)step:(CADisplayLink *)timer</div><div class="line">&#123;</div><div class="line">    //calculate time delta</div><div class="line">    CFTimeInterval thisStep = CACurrentMediaTime();</div><div class="line">    CFTimeInterval stepDuration = thisStep - self.lastStep;</div><div class="line">    self.lastStep = thisStep;</div><div class="line">    //update time offset</div><div class="line">    self.timeOffset = MIN(self.timeOffset + stepDuration, self.duration);</div><div class="line">    //get normalized time offset (in range 0 - 1)</div><div class="line">    float time = self.timeOffset / self.duration;</div><div class="line">    //apply easing</div><div class="line">    time = bounceEaseOut(time);</div><div class="line">    //interpolate position</div><div class="line">    id position = [self interpolateFromValue:self.fromValue toValue:self.toValue</div><div class="line">                                        time:time];</div><div class="line">    //move ball view to new position</div><div class="line">    self.ballView.center = [position CGPointValue];</div><div class="line">    //stop the timer if we&apos;ve reached the end of the animation</div><div class="line">    if (self.timeOffset &gt;= self.duration) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#####Run Loop 模式<br> 注意到当创建CADisplayLink的时候，我们需要指定一个run loop和run loop mode，对于run loop来说，我们就使用了主线程的run loop，因为任何用户界面的更新都需要在主线程执行，但是模式的选择就并不那么清楚了，每个添加到run loop的任务都有一个指定了优先级的模式，为了保证用户界面保持平滑，iOS会提供和用户界面相关任务的优先级，而且当UI很活跃的时候的确会暂停一些别的任务。</p>
<p>一个典型的例子就是当是用UIScrollview滑动的时候，重绘滚动视图的内容会比别的任务优先级更高，所以标准的NSTimer和网络请求就不会启动，一些常见的run loop模式如下：</p>
<pre><code>- NSDefaultRunLoopMode - 标准优先级
- NSRunLoopCommonModes - 高优先级
- UITrackingRunLoopMode - 用于UIScrollView和别的控件的动画
</code></pre><p>在我们的例子中，我们是用了NSDefaultRunLoopMode，但是不能保证动画平滑的运行，所以就可以用NSRunLoopCommonModes来替代。但是要小心，因为如果动画在一个高帧率情况下运行，你会发现一些别的类似于定时器的任务或者类似于滑动的其他iOS动画会暂停，直到动画结束</p>
<p> 同样可以同时对CADisplayLink指定多个run loop模式，于是我们可以同时加入NSDefaultRunLoopMode和UITrackingRunLoopMode来保证它不会被滑动打断，也不会被其他UIKit控件动画影响性能，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(step:)];</div><div class="line">[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line">[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode];</div></pre></td></tr></table></figure></p>
<p>和CADisplayLink类似，NSTimer同样也可以使用不同的run loop模式配置，通过别的函数，而不是+scheduledTimerWithTimeInterval:构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">self.timer = [NSTimer timerWithTimeInterval:1/60.0</div><div class="line">                                 target:self</div><div class="line">                               selector:@selector(step:)</div><div class="line">                               userInfo:nil</div><div class="line">                                repeats:YES];</div><div class="line">[[NSRunLoop mainRunLoop] addTimer:self.timer</div><div class="line">                          forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure></p>
<p>#####物理模拟<br>即使使用了基于定时器的动画来复制第10章中关键帧的行为，但还是会有一些本质上的区别：在关键帧的实现中，我们提前计算了所有帧，但是在新的解决方案中，我们实际上实在按需要在计算。意义在于我们可以根据用户输入实时修改动画的逻辑，或者和别的实时动画系统例如物理引擎进行整合。</p>
<p>#####Chipmunk<br>我们来基于物理学创建一个真实的重力模拟效果来取代当前基于缓冲的弹性动画，但即使模拟2D的物理效果就已近极其复杂了，所以就不要尝试去实现它了，直接用开源的物理引擎库好了。</p>
<p>我们将要使用的物理引擎叫做Chipmunk。另外的2D物理引擎也同样可以（例如Box2D），但是Chipmunk使用纯C写的，而不是C++，好处在于更容易和Objective-C项目整合。Chipmunk有很多版本，包括一个和Objective-C绑定的“indie”版本。C语言的版本是免费的，所以我们就用它好了。在本书写作的时候6.1.4是最新的版本；你可以从[<a href="http://chipmunk-physics.net]下载它。" target="_blank" rel="noopener">http://chipmunk-physics.net]下载它。</a></p>
<p>Chipmunk完整的物理引擎相当巨大复杂，但是我们只会使用如下几个类：</p>
<ul>
<li>cpSpace- 这是所有的物理结构体的容器。它有一个大小和一个可选的重力矢量</li>
<li>cpBody- 它是一个固态无弹力的刚体。它有一个坐标，以及其他物理属性，例如质量，运动和摩擦系数等等。</li>
<li>cpShape- 它是一个抽象的几何形状，用来检测碰撞。可以给结构体添加一个多边形，而且cpShape<br>有各种子类来代表不同形状的类型。</li>
</ul>
<p>在例子中，我们来对一个木箱建模，然后在重力的影响下下落。我们来创建一个Crate类，包含屏幕上的可视效果（一个UIImageView）和一个物理模型（一个cpBody和一个cpPolyShape，一个cpShape<br>的多边形子类来代表矩形木箱）。</p>
<p>用C版本的Chipmunk会带来一些挑战，因为它现在并不支持Objective-C的引用计数模型，所以我们需要准确的创建和释放对象。为了简化，我们把cpShape和cpBody的生命周期和Crate类进行绑定，然后在木箱的-init方法中创建，在-dealloc中释放。木箱物理属性的配置很复杂，所以阅读了Chipmunk文档会很有意义。</p>
<p>视图控制器用来管理cpSpace，还有和之前一样的计时器逻辑。在每一步中，我们更新cpSpace（用来进行物理计算和所有结构体的重新摆放）然后迭代对象，然后再更新我们的木箱视图的位置来匹配木箱的模型（在这里，实际上只有一个结构体，但是之后我们将要添加更多）。</p>
<p>Chipmunk使用了一个和UIKit颠倒的坐标系（Y轴向上为正方向）。为了使得物理模型和视图之间的同步更简单，我们需要通过使用geometryFlipped属性翻转容器视图的集合坐标（第3章中有提到），于是模型和视图都共享一个相同的坐标系。】</p>
<p> 具体的代码见清单11.3。注意到我们并没有在任何地方释放cpSpace对象。在这个例子中，内存空间将会在整个app的生命周期中一直存在，所以这没有问题。但是在现实世界的场景中，我们需要像创建木箱结构体和形状一样去管理我们的空间，封装在标准的Cocoa对象中，然后来管理Chipmunk对象的生命周期。图11.1展示了掉落的木箱。</p>
<p>#####清单11.3 使用物理学来对掉落的木箱建模<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &quot;chipmunk.h&quot;</div><div class="line">    </div><div class="line">    @interface Crate : UIImageView</div><div class="line">    </div><div class="line">    @property (nonatomic, assign) cpBody *body;</div><div class="line">    @property (nonatomic, assign) cpShape *shape;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation Crate</div><div class="line">    </div><div class="line">#define MASS 100</div><div class="line">    </div><div class="line">    - (id)initWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">            //set image</div><div class="line">            self.image = [UIImage imageNamed:@&quot;Crate.png&quot;];</div><div class="line">            self.contentMode = UIViewContentModeScaleAspectFill;</div><div class="line">            //create the body</div><div class="line">            self.body = cpBodyNew(MASS, cpMomentForBox(MASS, frame.size.width, frame.size.height));</div><div class="line">            //create the shape</div><div class="line">            cpVect corners[] = &#123;</div><div class="line">                cpv(0, 0),</div><div class="line">                cpv(0, frame.size.height),</div><div class="line">                cpv(frame.size.width, frame.size.height),</div><div class="line">                cpv(frame.size.width, 0),</div><div class="line">            &#125;;</div><div class="line">            self.shape = cpPolyShapeNew(self.body, 4, corners, cpv(-frame.size.width/2, -frame.size.height/2));</div><div class="line">            //set shape friction &amp; elasticity</div><div class="line">            cpShapeSetFriction(self.shape, 0.5);</div><div class="line">            cpShapeSetElasticity(self.shape, 0.8);</div><div class="line">            //link the crate to the shape</div><div class="line">            //so we can refer to crate from callback later on</div><div class="line">            self.shape-&gt;data = (__bridge void *)self;</div><div class="line">            //set the body position to match view</div><div class="line">            cpBodySetPos(self.body, cpv(frame.origin.x + frame.size.width/2, 300 - frame.origin.y - frame.size.height/2));</div><div class="line">        &#125;</div><div class="line">        return self;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)dealloc</div><div class="line">    &#123;</div><div class="line">        //release shape and body</div><div class="line">        cpShapeFree(_shape);</div><div class="line">        cpBodyFree(_body);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @property (nonatomic, assign) cpSpace *space;</div><div class="line">    @property (nonatomic, strong) CADisplayLink *timer;</div><div class="line">    @property (nonatomic, assign) CFTimeInterval lastStep;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">#define GRAVITY 1000</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        //invert view coordinate system to match physics</div><div class="line">        self.containerView.layer.geometryFlipped = YES;</div><div class="line">        //set up physics space</div><div class="line">        self.space = cpSpaceNew();</div><div class="line">        cpSpaceSetGravity(self.space, cpv(0, -GRAVITY));</div><div class="line">        //add a crate</div><div class="line">        Crate *crate = [[Crate alloc] initWithFrame:CGRectMake(100, 0, 100, 100)];</div><div class="line">        [self.containerView addSubview:crate];</div><div class="line">        cpSpaceAddBody(self.space, crate.body);</div><div class="line">        cpSpaceAddShape(self.space, crate.shape);</div><div class="line">        //start the timer</div><div class="line">        self.lastStep = CACurrentMediaTime();</div><div class="line">        self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                                 selector:@selector(step:)];</div><div class="line">        [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                         forMode:NSDefaultRunLoopMode];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void updateShape(cpShape *shape, void *unused)</div><div class="line">    &#123;</div><div class="line">        //get the crate object associated with the shape</div><div class="line">        Crate *crate = (__bridge Crate *)shape-&gt;data;</div><div class="line">        //update crate view position and angle to match physics shape</div><div class="line">        cpBody *body = shape-&gt;body;</div><div class="line">        crate.center = cpBodyGetPos(body);</div><div class="line">        crate.transform = CGAffineTransformMakeRotation(cpBodyGetAngle(body));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)step:(CADisplayLink *)timer</div><div class="line">    &#123;</div><div class="line">        //calculate step duration</div><div class="line">        CFTimeInterval thisStep = CACurrentMediaTime();</div><div class="line">        CFTimeInterval stepDuration = thisStep - self.lastStep;</div><div class="line">        self.lastStep = thisStep;</div><div class="line">        //update physics</div><div class="line">        cpSpaceStep(self.space, stepDuration);</div><div class="line">        //update all the shapes</div><div class="line">        cpSpaceEachShape(self.space, &amp;updateShape, NULL);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d283e91c630081dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.1.png"></p>
<p>#####添加用户交互<br> 下一步就是在视图周围添加一道不可见的墙，这样木箱就不会掉落出屏幕之外。或许你会用另一个矩形的cpPolyShape来实现，就和之前创建木箱那样，但是我们需要检测的是木箱何时离开视图，而不是何时碰撞，所以我们需要一个空心而不是固体矩形。</p>
<p>我们可以通过给cpSpace添加四个cpSegmentShape对象（cpSegmentShape代表一条直线，所以四个拼起来就是一个矩形）。然后赋给空间的staticBody属性（一个不被重力影响的结构体）而不是像木箱那样一个新的cpBody实例，因为我们不想让这个边框矩形滑出屏幕或者被一个下落的木箱击中而消失。</p>
<p>同样可以再添加一些木箱来做一些交互。最后再添加一个加速器，这样可以通过倾斜手机来调整重力矢量（为了测试需要在一台真实的设备上运行程序，因为模拟器不支持加速器事件，即使旋转屏幕）。清单11.4展示了更新后的代码，运行结果见图11.2。</p>
<p>由于示例只支持横屏模式，所以交换加速计矢量的x和y值。如果在竖屏下运行程序，请把他们换回来，不然重力方向就错乱了。试一下就知道了，木箱会沿着横向移动。</p>
<p>#####清单11.4 使用围墙和多个木箱的更新后的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    - (void)addCrateWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        Crate *crate = [[Crate alloc] initWithFrame:frame];</div><div class="line">        [self.containerView addSubview:crate];</div><div class="line">        cpSpaceAddBody(self.space, crate.body);</div><div class="line">        cpSpaceAddShape(self.space, crate.shape);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)addWallShapeWithStart:(cpVect)start end:(cpVect)end</div><div class="line">    &#123;</div><div class="line">        cpShape *wall = cpSegmentShapeNew(self.space-&gt;staticBody, start, end, 1);</div><div class="line">        cpShapeSetCollisionType(wall, 2);</div><div class="line">        cpShapeSetFriction(wall, 0.5);</div><div class="line">        cpShapeSetElasticity(wall, 0.8);</div><div class="line">        cpSpaceAddStaticShape(self.space, wall);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        //invert view coordinate system to match physics</div><div class="line">        self.containerView.layer.geometryFlipped = YES;</div><div class="line">        //set up physics space</div><div class="line">        self.space = cpSpaceNew();</div><div class="line">        cpSpaceSetGravity(self.space, cpv(0, -GRAVITY));</div><div class="line">        //add wall around edge of view</div><div class="line">        [self addWallShapeWithStart:cpv(0, 0) end:cpv(300, 0)];</div><div class="line">        [self addWallShapeWithStart:cpv(300, 0) end:cpv(300, 300)];</div><div class="line">        [self addWallShapeWithStart:cpv(300, 300) end:cpv(0, 300)];</div><div class="line">        [self addWallShapeWithStart:cpv(0, 300) end:cpv(0, 0)];</div><div class="line">        //add a crates</div><div class="line">        [self addCrateWithFrame:CGRectMake(0, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(32, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(64, 0, 64, 64)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(128, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(0, 32, 64, 64)];</div><div class="line">        //start the timer</div><div class="line">        self.lastStep = CACurrentMediaTime();</div><div class="line">        self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                                 selector:@selector(step:)];</div><div class="line">        [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                         forMode:NSDefaultRunLoopMode];</div><div class="line">        //update gravity using accelerometer</div><div class="line">        [UIAccelerometer sharedAccelerometer].delegate = self;</div><div class="line">        [UIAccelerometer sharedAccelerometer].updateInterval = 1/60.0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration</div><div class="line">    &#123;</div><div class="line">        //update gravity</div><div class="line">        cpSpaceSetGravity(self.space, cpv(acceleration.y * GRAVITY, -acceleration.x * GRAVITY));</div><div class="line">    &#125;</div><div class="line">   ``` </div><div class="line">    </div><div class="line">![11.2.png](http://upload-images.jianshu.io/upload_images/1694376-72bafe2f6175f44d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">#####模拟时间以及固定的时间步长</div><div class="line"></div><div class="line"> 对于实现动画的缓冲效果来说，计算每帧持续的时间是一个很好的解决方案，但是对模拟物理效果并不理想。通过一个可变的时间步长来实现有着两个弊端：</div><div class="line">- 如果时间步长不是固定的，精确的值，物理效果的模拟也就随之不确定。这意味着即使是传入相同的输入值，也可能在不同场合下有着不同的效果。有时候没多大影响，但是在基于物理引擎的游戏下，玩家就会由于相同的操作行为导致不同的结果而感到困惑。同样也会让测试变得麻烦。</div><div class="line">- 由于性能故常造成的丢帧或者像电话呼入的中断都可能会造成不正确的结果。考虑一个像子弹那样快速移动物体，每一帧的更新都需要移动子弹，检测碰撞。如果两帧之间的时间加长了，子弹就会在这一步移动更远的距离，穿过围墙或者是别的障碍，这样就丢失了碰撞。</div><div class="line"></div><div class="line"></div><div class="line">我们想得到的理想的效果就是通过固定的时间步长来计算物理效果，但是在屏幕发生重绘的时候仍然能够同步更新视图（可能会由于在我们控制范围之外造成不可预知的效果）。</div><div class="line"></div><div class="line">幸运的是，由于我们的模型（在这个例子中就是Chipmunk的cpSpace中的cpBody）被视图（就是屏幕上代表木箱的UIView对象）分离，于是就很简单了。我们只需要根据屏幕刷新的时间跟踪时间步长，然后根据每帧去计算一个或者多个模拟出来的效果。</div><div class="line">    </div><div class="line"> 我们可以通过一个简单的循环来实现。通过每次CADisplayLink的启动来通知屏幕将要刷新，然后记录下当前的CACurrentMediaTime()。我们需要在一个小增量中提前重复物理模拟（这里用120分之一秒）直到赶上显示的时间。然后更新我们的视图，在屏幕刷新的时候匹配当前物理结构体的显示位置。</div><div class="line"></div><div class="line">清单11.5展示了固定时间步长版本的代码</div><div class="line"></div><div class="line">#####清单11.5 固定时间步长的木箱模拟</div></pre></td></tr></table></figure></p>
<p>#define SIMULATION_STEP (1/120.0)</p>
<pre><code>- (void)step:(CADisplayLink *)timer
{
    //calculate frame step duration
    CFTimeInterval frameTime = CACurrentMediaTime();
    //update simulation
    while (self.lastStep &lt; frameTime) {
        cpSpaceStep(self.space, SIMULATION_STEP);
        self.lastStep += SIMULATION_STEP;
    }

    //update all the shapes
    cpSpaceEachShape(self.space, &amp;updateShape, NULL);
}
</code></pre><p>```</p>
<p>#####避免死亡螺旋<br> 当使用固定的模拟时间步长时候，有一件事情一定要注意，就是用来计算物理效果的现实世界的时间并不会加速模拟时间步长。在我们的例子中，我们随意选择了120分之一秒来模拟物理效果。Chipmunk很快，我们的例子也很简单，所以cpSpaceStep()会完成的很好，不会延迟帧的更新。</p>
<p>但是如果场景很复杂，比如有上百个物体之间的交互，物理计算就会很复杂，cpSpaceStep()的计算也可能会超出1/120秒。我们没有测量出物理步长的时间，因为我们假设了相对于帧刷新来说并不重要，但是如果模拟步长更久的话，就会延迟帧率。</p>
<p>如果帧刷新的时间延迟的话会变得很糟糕，我们的模拟需要执行更多的次数来同步真实的时间。这些额外的步骤就会继续延迟帧的更新，等等。这就是所谓的死亡螺旋，因为最后的结果就是帧率变得越来越慢，直到最后应用程序卡死了。</p>
<p>我们可以通过添加一些代码在设备上来对物理步骤计算真实世界的时间，然后自动调整固定时间步长，但是实际上它不可行。其实只要保证你给容错留下足够的边长，然后在期望支持的最慢的设备上进行测试就可以了。如果物理计算超过了模拟时间的50%，就需要考虑增加模拟时间步长（或者简化场景）。如果模拟时间步长增加到超过1/60秒（一个完整的屏幕更新时间），你就需要减少动画帧率到一秒30帧或者增加CADisplayLink的frameInterval来保证不会随机丢帧，不然你的动画将会看起来不平滑。</p>
<p>#####总结<br> 在这一章中，我们了解了如何通过一个计时器创建一帧帧的实时动画，包括缓冲，物理模拟等等一系列动画技术，以及用户输入（通过加速计）。</p>
<p>在第三部分中，我们将研究动画性能是如何被被设备限制所影响的，以及如何调整我们的代码来活的足够好的帧率。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/09/CoreAnimation之缓冲/" rel="next" title="CoreAnimation缓冲">
                <i class="fa fa-chevron-left"></i> CoreAnimation缓冲
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/05/11/CoreAnimation之图层时间/" rel="prev" title="CoreAnimation之图层时间">
                CoreAnimation之图层时间 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg"
              alt="雪晟" />
          
            <p class="site-author-name" itemprop="name">雪晟</p>
            <p class="site-description motion-element" itemprop="description">多去尝试你从未尝试的。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">97</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liuxinixn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/3d7c50f31b88" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-flag"></i>Jianshu</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雪晟</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
