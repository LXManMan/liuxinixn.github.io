<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="多去尝试你从未尝试的。">
<meta property="og:type" content="website">
<meta property="og:title" content="雪晟">
<meta property="og:url" content="liuxinixn.github.io/page/2/index.html">
<meta property="og:site_name" content="雪晟">
<meta property="og:description" content="多去尝试你从未尝试的。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雪晟">
<meta name="twitter:description" content="多去尝试你从未尝试的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxinixn.github.io/page/2/"/>





  <title>雪晟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雪晟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">十年饮冰，难凉热血。我是雪晟。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之基于定时器的动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之基于定时器的动画/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>我可以指导你，但是你必须按照我说的做。 – 骇客帝国</p>
</blockquote>
<p>在第10章“缓冲”中，我们研究了CAMediaTimingFunction，它是一个通过控制动画缓冲来模拟物理效果例如加速或者减速来增强现实感的东西，那么如果想更加真实地模拟物理交互或者实时根据用户输入修改动画改怎么办呢？在这一章中，我们将继续探索一种能够允许我们精确地控制一帧一帧展示的基于定时器的动画。</p>
<p>#####定时帧<br>动画看起来是用来显示一段连续的运动过程，但实际上当在固定位置上展示像素的时候并不能做到这一点。一般来说这种显示都无法做到连续的移动，能做的仅仅是足够快地展示一系列静态图片，只是看起来像是做了运动。</p>
<p>我们之前提到过<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>按照每秒60次刷新屏幕，然后CAAnimation计算出需要展示的新的帧，然后在每次屏幕更新的时候同步绘制上去，CAAnimation最机智的地方在于每次刷新需要展示的时候去计算插值和缓冲。</p>
<p>在第10章中，我们解决了如何自定义缓冲函数，然后根据需要展示的帧的数组来告诉CAKeyframeAnimation的实例如何去绘制。所有的Core Animation实际上都是按照一定的序列来显示这些帧，那么我们可以自己做到这些么？</p>
<p>#####NSTimer<br> 实际上，我们在第三章“图层几何学”中已经做过类似的东西，就是时钟那个例子，我们用了NSTimer来对钟表的指针做定时动画，一秒钟更新一次，但是如果我们把频率调整成一秒钟更新60次的话，原理是完全相同的。</p>
<p>我们来试着用NSTimer来修改第十章中弹性球的例子。由于现在我们在定时器启动之后连续计算动画帧，我们需要在类中添加一些额外的属性来存储动画的fromValue，toValue，duration和当前的timeOffset（见清单11.1）。</p>
<p>#####清单11.1 使用NSTimer实现弹性球动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line">@property (nonatomic, assign) NSTimeInterval duration;</div><div class="line">@property (nonatomic, assign) NSTimeInterval timeOffset;</div><div class="line">@property (nonatomic, strong) id fromValue;</div><div class="line">@property (nonatomic, strong) id toValue;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add ball image view</div><div class="line">    UIImage *ballImage = [UIImage imageNamed:@&quot;Ball.png&quot;];</div><div class="line">    self.ballView = [[UIImageView alloc] initWithImage:ballImage];</div><div class="line">    [self.containerView addSubview:self.ballView];</div><div class="line">    //animate</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //replay animation on tap</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">float interpolate(float from, float to, float time)</div><div class="line">&#123;</div><div class="line">    return (to - from) * time + from;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)interpolateFromValue:(id)fromValue toValue:(id)toValue time:(float)time</div><div class="line">&#123;</div><div class="line">    if ([fromValue isKindOfClass:[NSValue class]]) &#123;</div><div class="line">        //get type</div><div class="line">        const char *type = [(NSValue *)fromValue objCType];</div><div class="line">        if (strcmp(type, @encode(CGPoint)) == 0) &#123;</div><div class="line">            CGPoint from = [fromValue CGPointValue];</div><div class="line">            CGPoint to = [toValue CGPointValue];</div><div class="line">            CGPoint result = CGPointMake(interpolate(from.x, to.x, time), interpolate(from.y, to.y, time));</div><div class="line">            return [NSValue valueWithCGPoint:result];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //provide safe default implementation</div><div class="line">    return (time &lt; 0.5)? fromValue: toValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">float bounceEaseOut(float t)</div><div class="line">&#123;</div><div class="line">    if (t &lt; 4/11.0) &#123;</div><div class="line">        return (121 * t * t)/16.0;</div><div class="line">    &#125; else if (t &lt; 8/11.0) &#123;</div><div class="line">        return (363/40.0 * t * t) - (99/10.0 * t) + 17/5.0;</div><div class="line">    &#125; else if (t &lt; 9/10.0) &#123;</div><div class="line">        return (4356/361.0 * t * t) - (35442/1805.0 * t) + 16061/1805.0;</div><div class="line">    &#125;</div><div class="line">    return (54/5.0 * t * t) - (513/25.0 * t) + 268/25.0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //configure the animation</div><div class="line">    self.duration = 1.0;</div><div class="line">    self.timeOffset = 0.0;</div><div class="line">    self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    //stop the timer if it&apos;s already running</div><div class="line">    [self.timer invalidate];</div><div class="line">    //start the timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1/60.0</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(step:)</div><div class="line">                                                userInfo:nil</div><div class="line">                                                 repeats:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)step:(NSTimer *)step</div><div class="line">&#123;</div><div class="line">    //update time offset</div><div class="line">    self.timeOffset = MIN(self.timeOffset + 1/60.0, self.duration);</div><div class="line">    //get normalized time offset (in range 0 - 1)</div><div class="line">    float time = self.timeOffset / self.duration;</div><div class="line">    //apply easing</div><div class="line">    time = bounceEaseOut(time);</div><div class="line">    //interpolate position</div><div class="line">    id position = [self interpolateFromValue:self.fromValue</div><div class="line">                                     toValue:self.toValue</div><div class="line">                                        time:time];</div><div class="line">    //move ball view to new position</div><div class="line">    self.ballView.center = [position CGPointValue];</div><div class="line">    //stop the timer if we&apos;ve reached the end of the animation</div><div class="line">    if (self.timeOffset &gt;= self.duration) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>很赞，而且和基于关键帧例子的代码一样很多，但是如果想一次性在屏幕上对很多东西做动画，很明显就会有很多问题。</p>
<p>NSTimer并不是最佳方案，为了理解这点，我们需要确切地知道NSTimer是如何工作的。iOS上的每个线程都管理了一个NSRunloop，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项：</p>
<ul>
<li>处理触摸事件</li>
<li>发送和接受网络数据包</li>
<li>执行使用gcd的代码</li>
<li>处理计时器行为</li>
<li>屏幕重绘<br>当你设置一个NSTimer，他会被插入到当前任务列表中，然后直到指定时间过去之后才会被执行。但是何时启动定时器并没有一个时间上限，而且它只会在列表中上一个任务完成之后开始执行。这通常会导致有几毫秒的延迟，但是如果上一个任务过了很久才完成就会导致延迟很长一段时间。</li>
</ul>
<p>屏幕重绘的频率是一秒钟六十次，但是和定时器行为一样，如果列表中上一个执行了很长时间，它也会延迟。这些延迟都是一个随机值，于是就不能保证定时器精准地一秒钟执行六十次。有时候发生在屏幕重绘之后，这就会使得更新屏幕会有个延迟，看起来就是动画卡壳了。有时候定时器会在屏幕更新的时候执行两次，于是动画看起来就跳动了。</p>
<p>我们可以通过一些途径来优化：</p>
<pre><code>- 我们可以用CADisplayLink让更新频率严格控制在每次屏幕刷新之后。
</code></pre><ul>
<li>基于真实帧的持续时间而不是假设的更新频率来做动画。</li>
<li>调整动画计时器的run loop模式，这样就不会被别的事件干扰。</li>
</ul>
<p>#####CADisplayLink<br>CADisplayLink<br>是CoreAnimation提供的另一个类似于NSTimer的类，它总是在屏幕完成一次更新之前启动，它的接口设计的和NSTimer很类似，所以它实际上就是一个内置实现的替代，但是和timeInterval以秒为单位不同，CADisplayLink有一个整型的frameInterval属性，指定了间隔多少帧之后才执行。默认值是1，意味着每次屏幕更新之前都会执行一次。但是如果动画的代码执行起来超过了六十分之一秒，你可以指定frameInterval为2，就是说动画每隔一帧执行一次（一秒钟30帧）或者3，也就是一秒钟20次，等等。</p>
<p>用CADisplayLink而不是NSTimer，会保证帧率足够连续，使得动画看起来更加平滑，但即使CADisplayLink也不能保证每一帧都按计划执行，一些失去控制的离散的任务或者事件（例如资源紧张的后台程序）可能会导致动画偶尔地丢帧。当使用NSTimer的时候，一旦有机会计时器就会开启，但是CADisplayLink却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。</p>
<p>#####计算帧的持续时间<br> 无论是使用NSTimer还是CADisplayLink，我们仍然需要处理一帧的时间超出了预期的六十分之一秒。由于我们不能够计算出一帧真实的持续时间，所以需要手动测量。我们可以在每帧开始刷新的时候用CACurrentMediaTime()记录当前时间，然后和上一帧记录的时间去比较。</p>
<p>通过比较这些时间，我们就可以得到真实的每帧持续的时间，然后代替硬编码的六十分之一秒。我们来更新一下上个例子（见清单11.2）。</p>
<p>#####清单11.2 通过测量没帧持续的时间来使得动画更加平滑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line">@property (nonatomic, strong) CADisplayLink *timer;</div><div class="line">@property (nonatomic, assign) CFTimeInterval duration;</div><div class="line">@property (nonatomic, assign) CFTimeInterval timeOffset;</div><div class="line">@property (nonatomic, assign) CFTimeInterval lastStep;</div><div class="line">@property (nonatomic, strong) id fromValue;</div><div class="line">@property (nonatomic, strong) id toValue;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //configure the animation</div><div class="line">    self.duration = 1.0;</div><div class="line">    self.timeOffset = 0.0;</div><div class="line">    self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    //stop the timer if it&apos;s already running</div><div class="line">    [self.timer invalidate];</div><div class="line">    //start the timer</div><div class="line">    self.lastStep = CACurrentMediaTime();</div><div class="line">    self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                             selector:@selector(step:)];</div><div class="line">    [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                     forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)step:(CADisplayLink *)timer</div><div class="line">&#123;</div><div class="line">    //calculate time delta</div><div class="line">    CFTimeInterval thisStep = CACurrentMediaTime();</div><div class="line">    CFTimeInterval stepDuration = thisStep - self.lastStep;</div><div class="line">    self.lastStep = thisStep;</div><div class="line">    //update time offset</div><div class="line">    self.timeOffset = MIN(self.timeOffset + stepDuration, self.duration);</div><div class="line">    //get normalized time offset (in range 0 - 1)</div><div class="line">    float time = self.timeOffset / self.duration;</div><div class="line">    //apply easing</div><div class="line">    time = bounceEaseOut(time);</div><div class="line">    //interpolate position</div><div class="line">    id position = [self interpolateFromValue:self.fromValue toValue:self.toValue</div><div class="line">                                        time:time];</div><div class="line">    //move ball view to new position</div><div class="line">    self.ballView.center = [position CGPointValue];</div><div class="line">    //stop the timer if we&apos;ve reached the end of the animation</div><div class="line">    if (self.timeOffset &gt;= self.duration) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#####Run Loop 模式<br> 注意到当创建CADisplayLink的时候，我们需要指定一个run loop和run loop mode，对于run loop来说，我们就使用了主线程的run loop，因为任何用户界面的更新都需要在主线程执行，但是模式的选择就并不那么清楚了，每个添加到run loop的任务都有一个指定了优先级的模式，为了保证用户界面保持平滑，iOS会提供和用户界面相关任务的优先级，而且当UI很活跃的时候的确会暂停一些别的任务。</p>
<p>一个典型的例子就是当是用UIScrollview滑动的时候，重绘滚动视图的内容会比别的任务优先级更高，所以标准的NSTimer和网络请求就不会启动，一些常见的run loop模式如下：</p>
<pre><code>- NSDefaultRunLoopMode - 标准优先级
- NSRunLoopCommonModes - 高优先级
- UITrackingRunLoopMode - 用于UIScrollView和别的控件的动画
</code></pre><p>在我们的例子中，我们是用了NSDefaultRunLoopMode，但是不能保证动画平滑的运行，所以就可以用NSRunLoopCommonModes来替代。但是要小心，因为如果动画在一个高帧率情况下运行，你会发现一些别的类似于定时器的任务或者类似于滑动的其他iOS动画会暂停，直到动画结束</p>
<p> 同样可以同时对CADisplayLink指定多个run loop模式，于是我们可以同时加入NSDefaultRunLoopMode和UITrackingRunLoopMode来保证它不会被滑动打断，也不会被其他UIKit控件动画影响性能，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(step:)];</div><div class="line">[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line">[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode];</div></pre></td></tr></table></figure></p>
<p>和CADisplayLink类似，NSTimer同样也可以使用不同的run loop模式配置，通过别的函数，而不是+scheduledTimerWithTimeInterval:构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">self.timer = [NSTimer timerWithTimeInterval:1/60.0</div><div class="line">                                 target:self</div><div class="line">                               selector:@selector(step:)</div><div class="line">                               userInfo:nil</div><div class="line">                                repeats:YES];</div><div class="line">[[NSRunLoop mainRunLoop] addTimer:self.timer</div><div class="line">                          forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure></p>
<p>#####物理模拟<br>即使使用了基于定时器的动画来复制第10章中关键帧的行为，但还是会有一些本质上的区别：在关键帧的实现中，我们提前计算了所有帧，但是在新的解决方案中，我们实际上实在按需要在计算。意义在于我们可以根据用户输入实时修改动画的逻辑，或者和别的实时动画系统例如物理引擎进行整合。</p>
<p>#####Chipmunk<br>我们来基于物理学创建一个真实的重力模拟效果来取代当前基于缓冲的弹性动画，但即使模拟2D的物理效果就已近极其复杂了，所以就不要尝试去实现它了，直接用开源的物理引擎库好了。</p>
<p>我们将要使用的物理引擎叫做Chipmunk。另外的2D物理引擎也同样可以（例如Box2D），但是Chipmunk使用纯C写的，而不是C++，好处在于更容易和Objective-C项目整合。Chipmunk有很多版本，包括一个和Objective-C绑定的“indie”版本。C语言的版本是免费的，所以我们就用它好了。在本书写作的时候6.1.4是最新的版本；你可以从[<a href="http://chipmunk-physics.net]下载它。" target="_blank" rel="noopener">http://chipmunk-physics.net]下载它。</a></p>
<p>Chipmunk完整的物理引擎相当巨大复杂，但是我们只会使用如下几个类：</p>
<ul>
<li>cpSpace- 这是所有的物理结构体的容器。它有一个大小和一个可选的重力矢量</li>
<li>cpBody- 它是一个固态无弹力的刚体。它有一个坐标，以及其他物理属性，例如质量，运动和摩擦系数等等。</li>
<li>cpShape- 它是一个抽象的几何形状，用来检测碰撞。可以给结构体添加一个多边形，而且cpShape<br>有各种子类来代表不同形状的类型。</li>
</ul>
<p>在例子中，我们来对一个木箱建模，然后在重力的影响下下落。我们来创建一个Crate类，包含屏幕上的可视效果（一个UIImageView）和一个物理模型（一个cpBody和一个cpPolyShape，一个cpShape<br>的多边形子类来代表矩形木箱）。</p>
<p>用C版本的Chipmunk会带来一些挑战，因为它现在并不支持Objective-C的引用计数模型，所以我们需要准确的创建和释放对象。为了简化，我们把cpShape和cpBody的生命周期和Crate类进行绑定，然后在木箱的-init方法中创建，在-dealloc中释放。木箱物理属性的配置很复杂，所以阅读了Chipmunk文档会很有意义。</p>
<p>视图控制器用来管理cpSpace，还有和之前一样的计时器逻辑。在每一步中，我们更新cpSpace（用来进行物理计算和所有结构体的重新摆放）然后迭代对象，然后再更新我们的木箱视图的位置来匹配木箱的模型（在这里，实际上只有一个结构体，但是之后我们将要添加更多）。</p>
<p>Chipmunk使用了一个和UIKit颠倒的坐标系（Y轴向上为正方向）。为了使得物理模型和视图之间的同步更简单，我们需要通过使用geometryFlipped属性翻转容器视图的集合坐标（第3章中有提到），于是模型和视图都共享一个相同的坐标系。】</p>
<p> 具体的代码见清单11.3。注意到我们并没有在任何地方释放cpSpace对象。在这个例子中，内存空间将会在整个app的生命周期中一直存在，所以这没有问题。但是在现实世界的场景中，我们需要像创建木箱结构体和形状一样去管理我们的空间，封装在标准的Cocoa对象中，然后来管理Chipmunk对象的生命周期。图11.1展示了掉落的木箱。</p>
<p>#####清单11.3 使用物理学来对掉落的木箱建模<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &quot;chipmunk.h&quot;</div><div class="line">    </div><div class="line">    @interface Crate : UIImageView</div><div class="line">    </div><div class="line">    @property (nonatomic, assign) cpBody *body;</div><div class="line">    @property (nonatomic, assign) cpShape *shape;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation Crate</div><div class="line">    </div><div class="line">#define MASS 100</div><div class="line">    </div><div class="line">    - (id)initWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">            //set image</div><div class="line">            self.image = [UIImage imageNamed:@&quot;Crate.png&quot;];</div><div class="line">            self.contentMode = UIViewContentModeScaleAspectFill;</div><div class="line">            //create the body</div><div class="line">            self.body = cpBodyNew(MASS, cpMomentForBox(MASS, frame.size.width, frame.size.height));</div><div class="line">            //create the shape</div><div class="line">            cpVect corners[] = &#123;</div><div class="line">                cpv(0, 0),</div><div class="line">                cpv(0, frame.size.height),</div><div class="line">                cpv(frame.size.width, frame.size.height),</div><div class="line">                cpv(frame.size.width, 0),</div><div class="line">            &#125;;</div><div class="line">            self.shape = cpPolyShapeNew(self.body, 4, corners, cpv(-frame.size.width/2, -frame.size.height/2));</div><div class="line">            //set shape friction &amp; elasticity</div><div class="line">            cpShapeSetFriction(self.shape, 0.5);</div><div class="line">            cpShapeSetElasticity(self.shape, 0.8);</div><div class="line">            //link the crate to the shape</div><div class="line">            //so we can refer to crate from callback later on</div><div class="line">            self.shape-&gt;data = (__bridge void *)self;</div><div class="line">            //set the body position to match view</div><div class="line">            cpBodySetPos(self.body, cpv(frame.origin.x + frame.size.width/2, 300 - frame.origin.y - frame.size.height/2));</div><div class="line">        &#125;</div><div class="line">        return self;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)dealloc</div><div class="line">    &#123;</div><div class="line">        //release shape and body</div><div class="line">        cpShapeFree(_shape);</div><div class="line">        cpBodyFree(_body);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @property (nonatomic, assign) cpSpace *space;</div><div class="line">    @property (nonatomic, strong) CADisplayLink *timer;</div><div class="line">    @property (nonatomic, assign) CFTimeInterval lastStep;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">#define GRAVITY 1000</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        //invert view coordinate system to match physics</div><div class="line">        self.containerView.layer.geometryFlipped = YES;</div><div class="line">        //set up physics space</div><div class="line">        self.space = cpSpaceNew();</div><div class="line">        cpSpaceSetGravity(self.space, cpv(0, -GRAVITY));</div><div class="line">        //add a crate</div><div class="line">        Crate *crate = [[Crate alloc] initWithFrame:CGRectMake(100, 0, 100, 100)];</div><div class="line">        [self.containerView addSubview:crate];</div><div class="line">        cpSpaceAddBody(self.space, crate.body);</div><div class="line">        cpSpaceAddShape(self.space, crate.shape);</div><div class="line">        //start the timer</div><div class="line">        self.lastStep = CACurrentMediaTime();</div><div class="line">        self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                                 selector:@selector(step:)];</div><div class="line">        [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                         forMode:NSDefaultRunLoopMode];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void updateShape(cpShape *shape, void *unused)</div><div class="line">    &#123;</div><div class="line">        //get the crate object associated with the shape</div><div class="line">        Crate *crate = (__bridge Crate *)shape-&gt;data;</div><div class="line">        //update crate view position and angle to match physics shape</div><div class="line">        cpBody *body = shape-&gt;body;</div><div class="line">        crate.center = cpBodyGetPos(body);</div><div class="line">        crate.transform = CGAffineTransformMakeRotation(cpBodyGetAngle(body));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)step:(CADisplayLink *)timer</div><div class="line">    &#123;</div><div class="line">        //calculate step duration</div><div class="line">        CFTimeInterval thisStep = CACurrentMediaTime();</div><div class="line">        CFTimeInterval stepDuration = thisStep - self.lastStep;</div><div class="line">        self.lastStep = thisStep;</div><div class="line">        //update physics</div><div class="line">        cpSpaceStep(self.space, stepDuration);</div><div class="line">        //update all the shapes</div><div class="line">        cpSpaceEachShape(self.space, &amp;updateShape, NULL);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d283e91c630081dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.1.png"></p>
<p>#####添加用户交互<br> 下一步就是在视图周围添加一道不可见的墙，这样木箱就不会掉落出屏幕之外。或许你会用另一个矩形的cpPolyShape来实现，就和之前创建木箱那样，但是我们需要检测的是木箱何时离开视图，而不是何时碰撞，所以我们需要一个空心而不是固体矩形。</p>
<p>我们可以通过给cpSpace添加四个cpSegmentShape对象（cpSegmentShape代表一条直线，所以四个拼起来就是一个矩形）。然后赋给空间的staticBody属性（一个不被重力影响的结构体）而不是像木箱那样一个新的cpBody实例，因为我们不想让这个边框矩形滑出屏幕或者被一个下落的木箱击中而消失。</p>
<p>同样可以再添加一些木箱来做一些交互。最后再添加一个加速器，这样可以通过倾斜手机来调整重力矢量（为了测试需要在一台真实的设备上运行程序，因为模拟器不支持加速器事件，即使旋转屏幕）。清单11.4展示了更新后的代码，运行结果见图11.2。</p>
<p>由于示例只支持横屏模式，所以交换加速计矢量的x和y值。如果在竖屏下运行程序，请把他们换回来，不然重力方向就错乱了。试一下就知道了，木箱会沿着横向移动。</p>
<p>#####清单11.4 使用围墙和多个木箱的更新后的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    - (void)addCrateWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        Crate *crate = [[Crate alloc] initWithFrame:frame];</div><div class="line">        [self.containerView addSubview:crate];</div><div class="line">        cpSpaceAddBody(self.space, crate.body);</div><div class="line">        cpSpaceAddShape(self.space, crate.shape);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)addWallShapeWithStart:(cpVect)start end:(cpVect)end</div><div class="line">    &#123;</div><div class="line">        cpShape *wall = cpSegmentShapeNew(self.space-&gt;staticBody, start, end, 1);</div><div class="line">        cpShapeSetCollisionType(wall, 2);</div><div class="line">        cpShapeSetFriction(wall, 0.5);</div><div class="line">        cpShapeSetElasticity(wall, 0.8);</div><div class="line">        cpSpaceAddStaticShape(self.space, wall);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        //invert view coordinate system to match physics</div><div class="line">        self.containerView.layer.geometryFlipped = YES;</div><div class="line">        //set up physics space</div><div class="line">        self.space = cpSpaceNew();</div><div class="line">        cpSpaceSetGravity(self.space, cpv(0, -GRAVITY));</div><div class="line">        //add wall around edge of view</div><div class="line">        [self addWallShapeWithStart:cpv(0, 0) end:cpv(300, 0)];</div><div class="line">        [self addWallShapeWithStart:cpv(300, 0) end:cpv(300, 300)];</div><div class="line">        [self addWallShapeWithStart:cpv(300, 300) end:cpv(0, 300)];</div><div class="line">        [self addWallShapeWithStart:cpv(0, 300) end:cpv(0, 0)];</div><div class="line">        //add a crates</div><div class="line">        [self addCrateWithFrame:CGRectMake(0, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(32, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(64, 0, 64, 64)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(128, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(0, 32, 64, 64)];</div><div class="line">        //start the timer</div><div class="line">        self.lastStep = CACurrentMediaTime();</div><div class="line">        self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                                 selector:@selector(step:)];</div><div class="line">        [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                         forMode:NSDefaultRunLoopMode];</div><div class="line">        //update gravity using accelerometer</div><div class="line">        [UIAccelerometer sharedAccelerometer].delegate = self;</div><div class="line">        [UIAccelerometer sharedAccelerometer].updateInterval = 1/60.0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration</div><div class="line">    &#123;</div><div class="line">        //update gravity</div><div class="line">        cpSpaceSetGravity(self.space, cpv(acceleration.y * GRAVITY, -acceleration.x * GRAVITY));</div><div class="line">    &#125;</div><div class="line">   ``` </div><div class="line">    </div><div class="line">![11.2.png](http://upload-images.jianshu.io/upload_images/1694376-72bafe2f6175f44d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">#####模拟时间以及固定的时间步长</div><div class="line"></div><div class="line"> 对于实现动画的缓冲效果来说，计算每帧持续的时间是一个很好的解决方案，但是对模拟物理效果并不理想。通过一个可变的时间步长来实现有着两个弊端：</div><div class="line">- 如果时间步长不是固定的，精确的值，物理效果的模拟也就随之不确定。这意味着即使是传入相同的输入值，也可能在不同场合下有着不同的效果。有时候没多大影响，但是在基于物理引擎的游戏下，玩家就会由于相同的操作行为导致不同的结果而感到困惑。同样也会让测试变得麻烦。</div><div class="line">- 由于性能故常造成的丢帧或者像电话呼入的中断都可能会造成不正确的结果。考虑一个像子弹那样快速移动物体，每一帧的更新都需要移动子弹，检测碰撞。如果两帧之间的时间加长了，子弹就会在这一步移动更远的距离，穿过围墙或者是别的障碍，这样就丢失了碰撞。</div><div class="line"></div><div class="line"></div><div class="line">我们想得到的理想的效果就是通过固定的时间步长来计算物理效果，但是在屏幕发生重绘的时候仍然能够同步更新视图（可能会由于在我们控制范围之外造成不可预知的效果）。</div><div class="line"></div><div class="line">幸运的是，由于我们的模型（在这个例子中就是Chipmunk的cpSpace中的cpBody）被视图（就是屏幕上代表木箱的UIView对象）分离，于是就很简单了。我们只需要根据屏幕刷新的时间跟踪时间步长，然后根据每帧去计算一个或者多个模拟出来的效果。</div><div class="line">    </div><div class="line"> 我们可以通过一个简单的循环来实现。通过每次CADisplayLink的启动来通知屏幕将要刷新，然后记录下当前的CACurrentMediaTime()。我们需要在一个小增量中提前重复物理模拟（这里用120分之一秒）直到赶上显示的时间。然后更新我们的视图，在屏幕刷新的时候匹配当前物理结构体的显示位置。</div><div class="line"></div><div class="line">清单11.5展示了固定时间步长版本的代码</div><div class="line"></div><div class="line">#####清单11.5 固定时间步长的木箱模拟</div></pre></td></tr></table></figure></p>
<p>#define SIMULATION_STEP (1/120.0)</p>
<pre><code>- (void)step:(CADisplayLink *)timer
{
    //calculate frame step duration
    CFTimeInterval frameTime = CACurrentMediaTime();
    //update simulation
    while (self.lastStep &lt; frameTime) {
        cpSpaceStep(self.space, SIMULATION_STEP);
        self.lastStep += SIMULATION_STEP;
    }

    //update all the shapes
    cpSpaceEachShape(self.space, &amp;updateShape, NULL);
}
</code></pre><p>```</p>
<p>#####避免死亡螺旋<br> 当使用固定的模拟时间步长时候，有一件事情一定要注意，就是用来计算物理效果的现实世界的时间并不会加速模拟时间步长。在我们的例子中，我们随意选择了120分之一秒来模拟物理效果。Chipmunk很快，我们的例子也很简单，所以cpSpaceStep()会完成的很好，不会延迟帧的更新。</p>
<p>但是如果场景很复杂，比如有上百个物体之间的交互，物理计算就会很复杂，cpSpaceStep()的计算也可能会超出1/120秒。我们没有测量出物理步长的时间，因为我们假设了相对于帧刷新来说并不重要，但是如果模拟步长更久的话，就会延迟帧率。</p>
<p>如果帧刷新的时间延迟的话会变得很糟糕，我们的模拟需要执行更多的次数来同步真实的时间。这些额外的步骤就会继续延迟帧的更新，等等。这就是所谓的死亡螺旋，因为最后的结果就是帧率变得越来越慢，直到最后应用程序卡死了。</p>
<p>我们可以通过添加一些代码在设备上来对物理步骤计算真实世界的时间，然后自动调整固定时间步长，但是实际上它不可行。其实只要保证你给容错留下足够的边长，然后在期望支持的最慢的设备上进行测试就可以了。如果物理计算超过了模拟时间的50%，就需要考虑增加模拟时间步长（或者简化场景）。如果模拟时间步长增加到超过1/60秒（一个完整的屏幕更新时间），你就需要减少动画帧率到一秒30帧或者增加CADisplayLink的frameInterval来保证不会随机丢帧，不然你的动画将会看起来不平滑。</p>
<p>#####总结<br> 在这一章中，我们了解了如何通过一个计时器创建一帧帧的实时动画，包括缓冲，物理模拟等等一系列动画技术，以及用户输入（通过加速计）。</p>
<p>在第三部分中，我们将研究动画性能是如何被被设备限制所影响的，以及如何调整我们的代码来活的足够好的帧率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之显示动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之显示动画/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>如果想让事情变得顺利，只有靠自己 – 夏尔·纪尧姆</p>
</blockquote>
<p>上一章介绍了隐式动画的概念。隐式动画是在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>平台创建动态用户界面的一种直接方式，也是UIKit动画机制的基础，不过它并不能涵盖所有的动画类型。在这一章中，我们将要研究一下显式动画，它能够对一些属性做指定的自定义动画，或者创建非线性动画，比如沿着任意一条曲线移动。</p>
<p>#####属性动画<br>首先我们来探讨一下属性动画。属性动画作用于图层的某个单一属性，并指定了它的一个目标值，或者一连串将要做动画的值。属性动画分为两种：基础和关键帧。</p>
<p>#####基础动画<br>动画其实就是一段时间内发生的改变，最简单的形式就是从一个值改变到另一个值，这也是CABasicAnimation最主要的功能。CABasicAnimation是CAPropertyAnimation的一个子类，而CAPropertyAnimation的父类是CAAnimation，CAAnimation同时也是Core Animation所有动画类型的抽象基类。作为一个抽象类，CAAnimation本身并没有做多少工作，它提供了一个计时函数（见第十章“缓冲”），一个委托（用于反馈动画状态）以及一个removedOnCompletion，用于标识动画是否该在结束后自动释放（默认YES，为了防止内存泄露）。CAAnimation同时实现了一些协议，包括CAAction（允许CAAnimation的子类可以提供图层行为），以及CAMediaTiming（第九章“图层时间”将会详细解释）。</p>
<p>CAPropertyAnimation通过指定动画的keyPath作用于一个单一属性，CAAnimation通常应用于一个指定的CALayer，于是这里指的也就是一个图层的keyPath了。实际上它是一个关键路径（一些用点表示法可以在层级关系中指向任意嵌套的对象），而不仅仅是一个属性的名称，因为这意味着动画不仅可以作用于图层本身的属性，而且还包含了它的子成员的属性，甚至是一些虚拟的属性（后面会详细解释）。</p>
<p>CABasicAnimation继承于CAPropertyAnimation，并添加了如下属性:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">id fromValue </div><div class="line">id toValue </div><div class="line">id byValue</div></pre></td></tr></table></figure></p>
<p> 从命名就可以得到很好的解释：fromValue代表了动画开始之前属性的值，toValue代表了动画结束之后的值，byValue代表了动画执行过程中改变的值。</p>
<p>通过组合这三个属性就可以有很多种方式来指定一个动画的过程。它们被定义成id类型而不是一些具体的类型是因为属性动画可以用作很多不同种的属性类型，包括数字类型，矢量，变换矩阵，甚至是颜色或者图片。</p>
<p>id类型可以包含任意由NSObject派生的对象，但有时候你会希望对一些不直接从NSObject继承的属性类型做动画，这意味着你需要把这些值用一个对象来封装，或者强转成一个对象，就像某些功能和Objective-C对象类似的Core Foundation类型。但是如何从一个具体的数据类型转换成id看起来并不明显，一些普通的例子见表8.1。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-b656b6df2d935ca0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.1.png"><br> fromValue，toValue和byValue属性可以用很多种方式来组合，但为了防止冲突，不能一次性同时指定这三个值。例如，如果指定了fromValue等于2，toValue等于4，byValue等于3，那么Core Animation就不知道结果到底是4（toValue）还是5（fromValue + byValue）了。他们的用法在CABasicAnimation头文件中已经描述的很清楚了，所以在这里就不重复了。总的说来，就是只需要指定toValue或者byValue，剩下的值都可以通过上下文自动计算出来。</p>
<p>举个例子：我们修改一下第七章中的颜色渐变的动画，用显式的CABasicAnimation来取代之前的隐式动画，代码见清单8.1。</p>
<p>#####清单8.1 通过CABasicAnimation来设置图层背景色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"> </div><div class="line"> @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line"> @property (nonatomic, strong) IBOutlet CALayer *colorLayer;</div><div class="line"> </div><div class="line"> @end</div><div class="line"> </div><div class="line"> @implementation ViewController</div><div class="line"> </div><div class="line"> - (void)viewDidLoad</div><div class="line"> &#123;</div><div class="line">     [super viewDidLoad];</div><div class="line">     //create sublayer</div><div class="line">     self.colorLayer = [CALayer layer];</div><div class="line">     self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">     self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">     //add it to our view</div><div class="line">     [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line"> &#125;</div><div class="line"> </div><div class="line"> - (IBAction)changeColor</div><div class="line"> &#123;</div><div class="line">     ￼//create a new random color</div><div class="line">     CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">     CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">     CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">     UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];</div><div class="line">     //create a basic animation</div><div class="line">     CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">     animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">     animation.toValue = (__bridge id)color.CGColor;</div><div class="line">     //apply animation to layer</div><div class="line">     [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，结果有点差强人意，点击按钮，的确可以使图层动画过渡到一个新的颜色，然动画结束之后又立刻变回原始值。</p>
<p>这是因为动画并没有改变图层的模型，而只是呈现（第七章）。一旦动画结束并从图层上移除之后，图层就立刻恢复到之前定义的外观状态。我们从没改变过backgroundColor<br>属性，所以图层就返回到原始的颜色。</p>
<p>当之前在使用隐式动画的时候，实际上它就是用例子中CABasicAnimation来实现的（回忆第七章，我们在-actionForLayer:forKey:委托方法打印出来的结果就是CABasicAnimation）。但是在那个例子中，我们通过设置属性来打开动画。在这里我们做了相同的动画，但是并没有设置任何属性的值（这就是为什么会立刻变回初始状态的原因）。</p>
<p>把动画设置成一个图层的行为（然后通过改变属性值来启动动画）是到目前为止同步属性值和动画状态最简单的方式了，假设由于某些原因我们不能这么做（通常因为UIView关联的图层不能这么做动画），那么有两种可以更新属性值的方式：在动画开始之前或者动画结束之后。</p>
<p>动画之前改变属性的值是最简单的办法，但这意味着我们不能使用fromValue这么好的特性了，而且要手动将fromValue设置成图层当前的值。</p>
<p>于是在动画创建之前插入如下代码，就可以解决问题了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">animation.fromValue = (__bridge id)self.colorLayer.backgroundColor; </div><div class="line">self.colorLayer.backgroundColor = color.CGColor;</div></pre></td></tr></table></figure></p>
<p>这的确是可行的，但还是有些问题，如果这里已经正在进行一段动画，我们需要从呈现图层那里去获得fromValue，而不是模型图层。另外，由于这里的图层并不是UIView关联的图层，我们需要用CATransaction来禁用隐式动画行为，否则默认的图层行为会干扰我们的显式动画（实际上，显式动画通常会覆盖隐式动画，但在文章中并没有提到，所以为了安全最好这么做）。</p>
<p>更新之后的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">CALayer *layer = self.colorLayer.presentationLayer ?:self.colorLayer; </div><div class="line">animation.fromValue = (__bridge id)layer.backgroundColor;</div><div class="line">[CATransaction begin];</div><div class="line">[CATransaction setDisableActions:YES];</div><div class="line">self.colorLayer.backgroundColor = color.CGColor;[CATransaction commit];</div></pre></td></tr></table></figure></p>
<p> 如果给每个动画都添加这些，代码会显得特别臃肿。幸运的是，我们可以从CABasicAnimation去自动设置这些。于是可以创建一个可复用的代码。清单8.2修改了之前的示例，通过使用CABasicAnimation的一个函数来避免在每次动画时候都重复那些臃肿的代码。</p>
<p>#####清单8.2 修改动画立刻恢复到原始状态的一个可复用函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">- (void)applyBasicAnimation:(CABasicAnimation *)animation toLayer:(CALayer *)layer</div><div class="line">   &#123;</div><div class="line">       </div><div class="line">       //set the from value (using presentation layer if available)</div><div class="line">       animation.fromValue = [layer.presentationLayer ?: layer valueForKeyPath:animation.keyPath];</div><div class="line">       //update the property in advance</div><div class="line">       //note: this approach will only work if toValue != nil</div><div class="line">       [CATransaction begin];</div><div class="line">       [CATransaction setDisableActions:YES];</div><div class="line">       [layer setValue:animation.toValue forKeyPath:animation.keyPath];</div><div class="line">       [CATransaction commit];</div><div class="line">       //apply animation to layer</div><div class="line">       [layer addAnimation:animation forKey:nil];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (IBAction)changeColor</div><div class="line">   &#123;</div><div class="line">       //create a new random color</div><div class="line">       CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];</div><div class="line">       //create a basic animation</div><div class="line">       CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">       animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">       animation.toValue = (__bridge id)color.CGColor;</div><div class="line">       //apply animation without snap-back</div><div class="line">       [self applyBasicAnimation:animation toLayer:self.colorLayer];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p> 这种简单的实现方式通过toValue而不是byValue来处理动画，不过这已经是朝更好的解决方案迈出一大步了。你可以把它添加给CALayer作为一个分类，以方便更好地使用。</p>
<p>解决看起来如此简单的一个问题都着实麻烦，但是别的方案会更加复杂。如果不在动画开始之前去更新目标属性，那么就只能在动画完全结束或者取消的时候更新它。这意味着我们需要精准地在动画结束之后，图层返回到原始值之前更新属性。那么该如何找到这个点呢？</p>
<p>#####CAAnimationDelegate<br>在第七章使用隐式动画的时候，我们可以在CATransaction<br>完成块中检测到动画的完成。但是这种方式并不适用于显式动画，因为这里的动画和事务并没太多关联。</p>
<p>那么为了知道一个显式动画在何时结束，我们需要使用一个实现了CAAnimationDelegate协议的delegate。</p>
<p>CAAnimationDelegate在任何头文件中都找不到，但是可以在CAAnimation头文件或者苹果开发者文档中找到相关函数。在这个例子中，我们用-animationDidStop:finished:<br>方法在动画结束之后来更新图层的backgroundColor。</p>
<p>当更新属性的时候，我们需要设置一个新的事务，并且禁用图层行为。否则动画会发生两次，一个是因为显式的CABasicAnimation，另一次是因为隐式动画，具体实现见订单8.3。</p>
<p>#####清单8.3 动画完成之后修改图层的背景色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create sublayer</div><div class="line">    self.colorLayer = [CALayer layer];</div><div class="line">    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">    //add it to our view</div><div class="line">    [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)changeColor</div><div class="line">&#123;</div><div class="line">    //create a new random color</div><div class="line">    CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    UIColor *color = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];</div><div class="line">    //create a basic animation</div><div class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">    animation.toValue = (__bridge id)color.CGColor;</div><div class="line">    animation.delegate = self;</div><div class="line">    //apply animation to layer</div><div class="line">    [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    //set the backgroundColor property to match animation toValue</div><div class="line">    [CATransaction begin];</div><div class="line">    [CATransaction setDisableActions:YES];</div><div class="line">    self.colorLayer.backgroundColor = (__bridge CGColorRef)anim.toValue;</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>对CAAnimation而言，使用委托模式而不是一个完成块会带来一个问题，就是当你有多个动画的时候，无法在在回调方法中区分。在一个视图控制器中创建动画的时候，通常会用控制器本身作为一个委托（如清单8.3所示），但是所有的动画都会调用同一个回调方法，所以你就需要判断到底是那个图层的调用。</p>
<p> 考虑一下第三章的闹钟，“图层几何学”，我们通过简单地每秒更新指针的角度来实现一个钟，但如果指针动态地转向新的位置会更加真实。</p>
<p>我们不能通过隐式动画来实现因为这些指针都是UIView的实例，所以图层的隐式动画都被禁用了。我们可以简单地通过UIView的动画方法来实现。但如果想更好地控制动画时间，使用显式动画会更好（更多内容见第十章）。使用CABasicAnimation来做动画可能会更加复杂，因为我们需要在-animationDidStop:finished:中检测指针状态（用于设置结束的位置）。<br> 动画本身会作为一个参数传入委托的方法，也许你会认为可以控制器中把动画存储为一个属性，然后在回调用比较，但实际上并不起作用，因为委托传入的动画参数是原始值的一个深拷贝，从而不是同一个值。</p>
<p>当使用-addAnimation:forKey:把动画添加到图层，这里有一个到目前为止我们都设置为nil的key参数。这里的键是-animationForKey:方法找到对应动画的唯一标识符，而当前动画的所有键都可以用animationKeys获取。如果我们对每个动画都关联一个唯一的键，就可以对每个图层循环所有键，然后调用-animationForKey:来比对结果。尽管这不是一个优雅的实现。</p>
<p>幸运的是，还有一种更加简单的方法。像所有的NSObject子类一样，CAAnimation实现了KVC（键-值-编码）协议，于是你可以用-setValue:forKey:和-valueForKey:方法来存取属性。但是CAAnimation有一个不同的性能：它更像一个NSDictionary，可以让你随意设置键值对，即使和你使用的动画类所声明的属性并不匹配。</p>
<p>这意味着你可以对动画用任意类型打标签。在这里，我们给UIView类型的指针添加的动画，所以可以简单地判断动画到底属于哪个视图，然后在委托方法中用这个信息正确地更新钟的指针（清单8.4）。</p>
<p>#####清单8.4 使用KVC对动画打标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *hourHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *secondHand;</div><div class="line">@property (nonatomic, weak) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //adjust anchor points</div><div class="line">    self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">    self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">    self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">    //start timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">    //set initial hand positions</div><div class="line">    [self updateHandsAnimated:NO];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tick</div><div class="line">&#123;</div><div class="line">    [self updateHandsAnimated:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)updateHandsAnimated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    //convert time to hours, minutes and seconds</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">    CGFloat hourAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">    //calculate hour hand angle //calculate minute hand angle</div><div class="line">    CGFloat minuteAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">    //calculate second hand angle</div><div class="line">    CGFloat secondAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">    //rotate hands</div><div class="line">    [self setAngle:hourAngle forHand:self.hourHand animated:animated];</div><div class="line">    [self setAngle:minuteAngle forHand:self.minuteHand animated:animated];</div><div class="line">    [self setAngle:secondAngle forHand:self.secondHand animated:animated];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)setAngle:(CGFloat)angle forHand:(UIView *)handView animated:(BOOL)animated</div><div class="line">&#123;</div><div class="line">    //generate transform</div><div class="line">    CATransform3D transform = CATransform3DMakeRotation(angle, 0, 0, 1);</div><div class="line">    if (animated) &#123;</div><div class="line">        //create transform animation</div><div class="line">        CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">        [self updateHandsAnimated:NO];</div><div class="line">        animation.keyPath = @&quot;transform&quot;;</div><div class="line">        animation.toValue = [NSValue valueWithCATransform3D:transform];</div><div class="line">        animation.duration = 0.5;</div><div class="line">        animation.delegate = self;</div><div class="line">        [animation setValue:handView forKey:@&quot;handView&quot;];</div><div class="line">        [handView.layer addAnimation:animation forKey:nil];</div><div class="line">    &#125; else &#123;</div><div class="line">        //set transform directly</div><div class="line">        handView.layer.transform = transform;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animationDidStop:(CABasicAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    //set final position for hand view</div><div class="line">    UIView *handView = [anim valueForKey:@&quot;handView&quot;];</div><div class="line">    handView.layer.transform = [anim.toValue CATransform3DValue];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 我们成功的识别出每个图层停止动画的时间，然后更新它的变换到一个新值，很好。</p>
<p>不幸的是，即使做了这些，还是有个问题，清单8.4在模拟器上运行的很好，但当真正跑在iOS设备上时，我们发现在-animationDidStop:finished:委托方法调用之前，指针会迅速返回到原始值，这个清单8.3图层颜色发生的情况一样。</p>
<p>问题在于回调方法在动画完成之前已经被调用了，但不能保证这发生在属性动画返回初始状态之前。这同时也很好地说明了为什么要在真实的设备上测试动画代码，而不仅仅是模拟器。</p>
<p>我们可以用一个fillMode属性来解决这个问题，下一章会详细说明，这里知道在动画之前设置它比在动画结束之后更新属性更加方便。</p>
<p>#####关键帧动画<br>CABasicAnimation揭示了大多数隐式动画背后依赖的机制，这的确很有趣，但是显式地给图层添加CABasicAnimation<br>相较于隐式动画而言，只能说费力不讨好。</p>
<p>CAKeyframeAnimation是另一种UIKit没有暴露出来但功能强大的类。和CABasicAnimatio类似，CAKeyframeAnimation同样是CAPropertyAnimation<br>的一个子类，它依然作用于单一的一个属性，但是和CABasicAnimation不一样的是，它不限制于设置一个起始和结束的值，而是可以根据一连串随意的值来做动画。</p>
<p>关键帧起源于传动动画，意思是指主导的动画在显著改变发生时重绘当前帧（也就是关键帧），每帧之间剩下的绘制（可以通过关键帧推算出）将由熟练的艺术家来完成。CAKeyframeAnimation也是同样的道理：你提供了显著的帧，然后Core Animation在每帧之间进行插入。</p>
<p>我们可以用之前使用颜色图层的例子来演示，设置一个颜色的数组，然后通过关键帧动画播放出来（清单8.5）</p>
<p>#####清单8.5 使用CAKeyframeAnimation应用一系列颜色的变化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (IBAction)changeColor</div><div class="line">&#123;</div><div class="line">    //create a keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">    animation.duration = 2.0;</div><div class="line">    animation.values = @[</div><div class="line">                         (__bridge id)[UIColor blueColor].CGColor,</div><div class="line">                         (__bridge id)[UIColor redColor].CGColor,</div><div class="line">                         (__bridge id)[UIColor greenColor].CGColor,</div><div class="line">                         (__bridge id)[UIColor blueColor].CGColor ];</div><div class="line">    //apply animation to layer</div><div class="line">    [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意到序列中开始和结束的颜色都是蓝色，这是因为CAKeyframeAnimation并不能自动把当前值作为第一帧（就像CABasicAnimation那样把fromValue设为nil）。动画会在开始的时候突然跳转到第一帧的值，然后在动画结束的时候突然恢复到原始的值。所以为了动画的平滑特性，我们需要开始和结束的关键帧来匹配当前属性的值。</p>
<p>当然可以创建一个结束和开始值不同的动画，那样的话就需要在动画启动之前手动更新属性和最后一帧的值保持一致，就和之前讨论的一样。</p>
<p>我们用duration<br>属性把动画时间从默认的0.25秒增加到2秒，以便于动画做的不那么快。运行它，你会发现动画通过颜色不断循环，但效果看起来有些奇怪。原因在于动画以一个恒定的步调在运行。当在每个动画之间过渡的时候并没有减速，这就产生了一个略微奇怪的效果，为了让动画看起来更自然，我们需要调整一下缓冲，第十章将会详细说明。</p>
<p>提供一个数组的值就可以按照颜色变化做动画，但一般来说用数组来描述动画运动并不直观。CAKeyframeAnimation<br>有另一种方式去指定动画，就是使用CGPath。path<br>属性可以用一种直观的方式，使用Core Graphics函数定义运动序列来绘制动画。</p>
<p>我们来用一个宇宙飞船沿着一个简单曲线的实例演示一下。为了创建路径，我们需要使用一个三次贝塞尔曲线，它是一种使用开始点，结束点和另外两个控制点来定义形状的曲线，可以通过使用一个基于C的Core Graphics绘图指令来创建，不过用UIKit提供的UIBezierPath类会更简单。</p>
<p>我们这次用CAShapeLayer来在屏幕上绘制曲线，尽管对动画来说并不是必须的，但这会让我们的动画更加形象。绘制完CGPath之后，我们用它来创建一个CAKeyframeAnimation，然后用它来应用到我们的宇宙飞船。代码见清单8.6，结果见图8.1。</p>
<p>#####清单8.6 沿着一个贝塞尔曲线对图层做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a path</div><div class="line">    UIBezierPath *bezierPath = [[UIBezierPath alloc] init];</div><div class="line">    [bezierPath moveToPoint:CGPointMake(0, 150)];</div><div class="line">    [bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];</div><div class="line">    //draw the path using a CAShapeLayer</div><div class="line">    CAShapeLayer *pathLayer = [CAShapeLayer layer];</div><div class="line">    pathLayer.path = bezierPath.CGPath;</div><div class="line">    pathLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    pathLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    pathLayer.lineWidth = 3.0f;</div><div class="line">    [self.containerView.layer addSublayer:pathLayer];</div><div class="line">    //add the ship</div><div class="line">    CALayer *shipLayer = [CALayer layer];</div><div class="line">    shipLayer.frame = CGRectMake(0, 0, 64, 64);</div><div class="line">    shipLayer.position = CGPointMake(0, 150);</div><div class="line">    shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">    [self.containerView.layer addSublayer:shipLayer];</div><div class="line">    //create the keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 4.0;</div><div class="line">    animation.path = bezierPath.CGPath;</div><div class="line">    [shipLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-07bb86da115815c4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8..png"></p>
<p> 运行示例，你会发现飞船的动画有些不太真实，这是因为当它运动的时候永远指向右边，而不是指向曲线切线的方向。你可以调整它的affineTransform来对运动方向做动画，但很可能和其它的动画冲突。</p>
<p>幸运的是，苹果预见到了这点，并且给CAKeyFrameAnimation添加了一个rotationMode的属性。设置它为常量kCAAnimationRotateAuto（清单8.7），图层将会根据曲线的切线自动旋转（图8.2）。</p>
<p>#####清单8.7 通过rotationMode自动对齐图层到曲线<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a path</div><div class="line">    ...</div><div class="line">    //create the keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 4.0;</div><div class="line">    animation.path = bezierPath.CGPath;</div><div class="line">    animation.rotationMode = kCAAnimationRotateAuto;</div><div class="line">    [shipLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-304e99329e4d21fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.2.png"></p>
<p>#####虚拟属性<br>之前提到过属性动画实际上是针对于关键路径而不是一个键，这就意味着可以对子属性甚至是虚拟属性做动画。但是虚拟属性到底是什么呢？</p>
<p>考虑一个旋转的动画：如果想要对一个物体做旋转的动画，那就需要作用于transform属性，因为CALayer<br>没有显式提供角度或者方向之类的属性，代码如清单8.8所示</p>
<p>#####清单8.8 用transform属性对图层做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add the ship</div><div class="line">    CALayer *shipLayer = [CALayer layer];</div><div class="line">    shipLayer.frame = CGRectMake(0, 0, 128, 128);</div><div class="line">    shipLayer.position = CGPointMake(150, 150);</div><div class="line">    shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">    [self.containerView.layer addSublayer:shipLayer];</div><div class="line">    //animate the ship rotation</div><div class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;transform&quot;;</div><div class="line">    animation.duration = 2.0;</div><div class="line">    animation.toValue = [NSValue valueWithCATransform3D: CATransform3DMakeRotation(M_PI, 0, 0, 1)];</div><div class="line">    [shipLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>这么做是可行的，但看起来更因为是运气而不是设计的原因，如果我们把旋转的值从M_PI（180度）调整到2 * M_PI（360度），然后运行程序，会发现这时候飞船完全不动了。这是因为这里的矩阵做了一次360度的旋转，和做了0度是一样的，所以最后的值根本没变。</p>
<p>现在继续使用M_PI，但这次用byValue而不是toValue。也许你会认为这和设置toValue结果一样，因为0 + 90度 == 90度，但实际上飞船的图片变大了，并没有做任何旋转，这是因为变换矩阵不能像角度值那样叠加。</p>
<p>那么如果需要独立于角度之外单独对平移或者缩放做动画呢？由于都需要我们来修改transform属性，实时地重新计算每个时间点的每个变换效果，然后根据这些创建一个复杂的关键帧动画，这一切都是为了对图层的一个独立做一个简单的动画.</p>
<p>幸运的是，有一个更好的解决方案：为了旋转图层，我们可以对transform.rotation关键路径应用动画，而不是transform本身（清单8.9）。</p>
<p>#####清单8.9 对虚拟的transform.rotation属性做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add the ship</div><div class="line">    CALayer *shipLayer = [CALayer layer];</div><div class="line">    shipLayer.frame = CGRectMake(0, 0, 128, 128);</div><div class="line">    shipLayer.position = CGPointMake(150, 150);</div><div class="line">    shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">    [self.containerView.layer addSublayer:shipLayer];</div><div class="line">    //animate the ship rotation</div><div class="line">    CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;transform.rotation&quot;;</div><div class="line">    animation.duration = 2.0;</div><div class="line">    animation.byValue = @(M_PI * 2);</div><div class="line">    [shipLayer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>结果运行的特别好，用transform.rotation而不是transform做动画的好处如下：</p>
<ul>
<li>我们可以不通过关键帧一步旋转多于180度的动画。</li>
<li>可以用相对值而不是绝对值旋转（设置byValue而不是toValue）。</li>
<li>可以不用创建CATransform3D，而是使用一个简单的数值来指定角度。</li>
<li>不会和transform.position或者transform.scale冲突（同样是使用关键路径来做独立的动画属性）。</li>
</ul>
<p>transform.rotation属性有一个奇怪的问题是它其实并不存在。这是因为CATransform3D并不是一个对象，它实际上是一个结构体，也没有符合KVC相关属性，transform.rotation，实际上是一个CALayer用于处理动画变换的虚拟属性。</p>
<p>你不可以直接设置transform.rotation或者transform.scale，他们不能被直接使用。当你对他们做动画时，Core Animation自动地根据通过CAValueFunction来计算的值来更新transform属性</p>
<p> CAValueFunction用于把我们赋给虚拟的transform.rotation简单浮点值转换成真正的用于摆放图层的CATransform3D矩阵值。你可以通过设置CAPropertyAnimation的valueFunction属性来改变，于是你设置的函数将会覆盖默认的函数。</p>
<p>CAValueFunction看起来似乎是对那些不能简单相加的属性（例如变换矩阵）做动画的非常有用的机制，但由于CAValueFunction的实现细节是私有的，所以目前不能通过继承它来自定义。你可以通过使用苹果目前已近提供的常量（目前都是和变换矩阵的虚拟属性相关，所以没太多使用场景了，因为这些属性都有了默认的实现方式）。</p>
<p>#####动画组<br> CABasicAnimation和CAKeyframeAnimation仅仅作用于单独的属性，而CAAnimationGroup可以把这些动画组合在一起。CAAnimationGroup是另一个继承于CAAnimation的子类，它添加了一个animations数组的属性，用来组合别的动画。我们把清单8.6那种关键帧动画和调整图层背景色的基础动画组合起来（清单8.10），结果如图8.3所示。</p>
<p>#####清单8.10 组合关键帧动画和基础动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a path</div><div class="line">    UIBezierPath *bezierPath = [[UIBezierPath alloc] init];</div><div class="line">    [bezierPath moveToPoint:CGPointMake(0, 150)];</div><div class="line">    [bezierPath addCurveToPoint:CGPointMake(300, 150) controlPoint1:CGPointMake(75, 0) controlPoint2:CGPointMake(225, 300)];</div><div class="line">    //draw the path using a CAShapeLayer</div><div class="line">    CAShapeLayer *pathLayer = [CAShapeLayer layer];</div><div class="line">    pathLayer.path = bezierPath.CGPath;</div><div class="line">    pathLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    pathLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    pathLayer.lineWidth = 3.0f;</div><div class="line">    [self.containerView.layer addSublayer:pathLayer];</div><div class="line">    //add a colored layer</div><div class="line">    CALayer *colorLayer = [CALayer layer];</div><div class="line">    colorLayer.frame = CGRectMake(0, 0, 64, 64);</div><div class="line">    colorLayer.position = CGPointMake(0, 150);</div><div class="line">    colorLayer.backgroundColor = [UIColor greenColor].CGColor;</div><div class="line">    [self.containerView.layer addSublayer:colorLayer];</div><div class="line">    //create the position animation</div><div class="line">    CAKeyframeAnimation *animation1 = [CAKeyframeAnimation animation];</div><div class="line">    animation1.keyPath = @&quot;position&quot;;</div><div class="line">    animation1.path = bezierPath.CGPath;</div><div class="line">    animation1.rotationMode = kCAAnimationRotateAuto;</div><div class="line">    //create the color animation</div><div class="line">    CABasicAnimation *animation2 = [CABasicAnimation animation];</div><div class="line">    animation2.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">    animation2.toValue = (__bridge id)[UIColor redColor].CGColor;</div><div class="line">    //create group animation</div><div class="line">    CAAnimationGroup *groupAnimation = [CAAnimationGroup animation];</div><div class="line">    groupAnimation.animations = @[animation1, animation2];</div><div class="line">    groupAnimation.duration = 4.0;</div><div class="line">    //add the animation to the color layer</div><div class="line">    [colorLayer addAnimation:groupAnimation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6a0f100cbb16306c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.3.png"></p>
<p>#####过渡<br> 有时候对于iOS应用程序来说，希望能通过属性动画来对比较难做动画的布局进行一些改变。比如交换一段文本和图片，或者用一段网格视图来替换，等等。属性动画只对图层的可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片），或者从层级关系中添加或者移除图层，属性动画将不起作用。</p>
<p>于是就有了过渡的概念。过渡并不像属性动画那样平滑地在两个值之间做动画，而是影响到整个图层的变化。过渡动画首先展示之前的图层外观，然后通过一个交换过渡到新的外观。</p>
<p>为了创建一个过渡动画，我们将使用CATransition，同样是另一个CAAnimation的子类，和别的子类不同，CATransition有一个type和subtype来标识变换效果。type属性是一个NSString类型，可以被设置成如下类型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">kCATransitionFromRight </div><div class="line">kCATransitionFromLeft </div><div class="line">kCATransitionFromTop </div><div class="line">kCATransitionFromBottom</div></pre></td></tr></table></figure></p>
<p> 一个简单的用CATransition来对非动画属性做动画的例子如清单8.11所示，这里我们对UIImage的image属性做修改，但是隐式动画或者CAPropertyAnimation都不能对它做动画，因为Core Animation不知道如何在插图图片。通过对图层应用一个淡入淡出的过渡，我们可以忽略它的内容来做平滑动画（图8.4），我们来尝试修改过渡的type常量来观察其它效果。</p>
<p>#####清单8.11 使用CATransition来对UIImageView做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *imageView;</div><div class="line">@property (nonatomic, copy) NSArray *images;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //set up images</div><div class="line">    self.images = @[[UIImage imageNamed:@&quot;Anchor.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Cone.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Igloo.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Spaceship.png&quot;]];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">- (IBAction)switchImage</div><div class="line">&#123;</div><div class="line">    //set up crossfade transition</div><div class="line">    CATransition *transition = [CATransition animation];</div><div class="line">    transition.type = kCATransitionFade;</div><div class="line">    //apply transition to imageview backing layer</div><div class="line">    [self.imageView.layer addAnimation:transition forKey:nil];</div><div class="line">    //cycle to next image</div><div class="line">    UIImage *currentImage = self.imageView.image;</div><div class="line">    NSUInteger index = [self.images indexOfObject:currentImage];</div><div class="line">    index = (index + 1) % [self.images count];</div><div class="line">    self.imageView.image = self.images[index];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>你可以从代码中看出，过渡动画和之前的属性动画或者动画组添加到图层上的方式一致，都是通过-addAnimation:forKey:方法。但是和属性动画不同的是，对指定的图层一次只能使用一次CATransition，因此，无论你对动画的键设置什么值，过渡动画都会对它的键设置成“transition”，也就是常量kCATransition。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-9855be160cbe4c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.4.png"></p>
<p>#####隐式过渡<br> CATransision可以对图层任何变化平滑过渡的事实使得它成为那些不好做动画的属性图层行为的理想候选。苹果当然意识到了这点，并且当设置了CALayer的content属性的时候，CATransition的确是默认的行为。但是对于视图关联的图层，或者是其他隐式动画的行为，这个特性依然是被禁用的，但是对于你自己创建的图层，这意味着对图层contents图片做的改动都会自动附上淡入淡出的动画。</p>
<p>我们在第七章使用CATransition作为一个图层行为来改变图层的背景色，当然backgroundColor属性可以通过正常的CAPropertyAnimation来实现，但这不是说不可以用CATransition来实行。</p>
<p>#####对图层树的动画<br>CATransition并不作用于指定的图层属性，这就是说你可以在即使不能准确得知改变了什么的情况下对图层做动画，例如，在不知道UITableView哪一行被添加或者删除的情况下，直接就可以平滑地刷新它，或者在不知道UIViewController内部的视图层级的情况下对两个不同的实例做过渡动画。</p>
<p>这些例子和我们之前所讨论的情况完全不同，因为它们不仅涉及到图层的属性，而且是整个图层树的改变–我们在这种动画的过程中手动在层级关系中添加或者移除图层。</p>
<p>这里用到了一个小诡计，要确保CATransition添加到的图层在过渡动画发生时不会在树状结构中被移除，否则CATransition将会和图层一起被移除。一般来说，你只需要将动画添加到被影响图层的superlayer。</p>
<p>在清单8.2中，我们展示了如何在UITabBarController切换标签的时候添加淡入淡出的动画。这里我们建立了默认的标签应用程序模板，然后用UITabBarControllerDelegate的-tabBarController:didSelectViewController:方法来应用过渡动画。我们把动画添加UITabBarController的视图图层上，于是在标签被替换的时候动画不会被移除。</p>
<p>#####清单8.12 对UITabBarController做动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#import &quot;AppDelegate.h&quot;</div><div class="line">#import &quot;FirstViewController.h&quot;</div><div class="line">#import &quot;SecondViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">    @implementation AppDelegate</div><div class="line">    - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</div><div class="line">    &#123;</div><div class="line">        self.window = [[UIWindow alloc] initWithFrame: [[UIScreen mainScreen] bounds]];</div><div class="line">        UIViewController *viewController1 = [[FirstViewController alloc] init];</div><div class="line">        UIViewController *viewController2 = [[SecondViewController alloc] init];</div><div class="line">        self.tabBarController = [[UITabBarController alloc] init];</div><div class="line">        self.tabBarController.viewControllers = @[viewController1, viewController2];</div><div class="line">        self.tabBarController.delegate = self;</div><div class="line">        self.window.rootViewController = self.tabBarController;</div><div class="line">        [self.window makeKeyAndVisible];</div><div class="line">        return YES;</div><div class="line">    &#125;</div><div class="line">    - (void)tabBarController:(UITabBarController *)tabBarController didSelectViewController:(UIViewController *)viewController</div><div class="line">    &#123;</div><div class="line">        ￼//set up crossfade transition</div><div class="line">        CATransition *transition = [CATransition animation];</div><div class="line">        transition.type = kCATransitionFade;</div><div class="line">        //apply transition to tab bar controller&apos;s view</div><div class="line">        [self.tabBarController.view.layer addAnimation:transition forKey:nil];</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p>#####自定义动画<br>我们证实了过渡是一种对那些不太好做平滑动画属性的强大工具，但是CATransition的提供的动画类型太少了。</p>
<p>更奇怪的是苹果通过<br>UIView+transitionFromView:toView:duration:options:completion:和+transitionWithView:duration:options:animations:<br>方法提供了Core Animation的过渡特性。但是这里的可用的过渡选项和CATransition的type属性提供的常量完全不同。UIView过渡方法中options参数可以由如下常量指定：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">UIViewAnimationOptionTransitionFlipFromLeft </div><div class="line">UIViewAnimationOptionTransitionFlipFromRight</div><div class="line">UIViewAnimationOptionTransitionCurlUp </div><div class="line">UIViewAnimationOptionTransitionCurlDown</div><div class="line">UIViewAnimationOptionTransitionCrossDissolve </div><div class="line">UIViewAnimationOptionTransitionFlipFromTop </div><div class="line">UIViewAnimationOptionTransitionFlipFromBottom</div></pre></td></tr></table></figure></p>
<p>除了UIViewAnimationOptionTransitionCrossDissolve之外，剩下的值和CATransition类型完全没关系。你可以用之前例子修改过的版本来测试一下（见清单8.13）。</p>
<p>#####清单8.13 使用UIKit提供的方法来做过渡动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *imageView;</div><div class="line">@property (nonatomic, copy) NSArray *images;</div><div class="line">@end</div><div class="line">@implementation ViewController</div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad]; //set up images</div><div class="line">    self.images = @[[UIImage imageNamed:@&quot;Anchor.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Cone.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Igloo.png&quot;],</div><div class="line">                    [UIImage imageNamed:@&quot;Spaceship.png&quot;]];</div><div class="line">    - (IBAction)switchImage</div><div class="line">    &#123;</div><div class="line">        [UIView transitionWithView:self.imageView duration:1.0</div><div class="line">                           options:UIViewAnimationOptionTransitionFlipFromLeft</div><div class="line">                        animations:^&#123;</div><div class="line">                            //cycle to next image</div><div class="line">                            UIImage *currentImage = self.imageView.image;</div><div class="line">                            NSUInteger index = [self.images indexOfObject:currentImage];</div><div class="line">                            index = (index + 1) % [self.images count];</div><div class="line">                            self.imageView.image = self.images[index];</div><div class="line">                        &#125;</div><div class="line">                        completion:NULL];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p>文档暗示过在iOS5（带来了Core Image框架）之后，可以通过CATransition的filter属性，用CIFilter来创建其它的过渡效果。然是直到iOS6都做不到这点。试图对CATransition使用Core Image的滤镜完全没效果（但是在Mac OS中是可行的，也许文档是想表达这个意思）。<br> 因此，根据要实现的效果，你只用关心是用CATransition还是用UIView的过渡方法就可以了。希望下个版本的iOS系统可以通过CATransition很好的支持Core Image的过渡滤镜效果（或许甚至会有新的方法）。</p>
<p>但这并不意味着在iOS上就不能实现自定义的过渡效果了。这只是意味着你需要做一些额外的工作。就像之前提到的那样，过渡动画做基础的原则就是对原始的图层外观截图，然后添加一段动画，平滑过渡到图层改变之后那个截图的效果。如果我们知道如何对图层截图，我们就可以使用属性动画来代替CATransition或者是UIKit的过渡方法来实现动画。</p>
<p> 事实证明，对图层做截图还是很简单的。CALayer有一个-renderInContext:方法，可以通过把它绘制到Core Graphics的上下文中捕获当前内容的图片，然后在另外的视图中显示出来。如果我们把这个截屏视图置于原始视图之上，就可以遮住真实视图的所有变化，于是重新创建了一个简单的过渡效果。</p>
<p>清单8.14演示了一个基本的实现。我们对当前视图状态截图，然后在我们改变原始视图的背景色的时候对截图快速转动并且淡出，图8.5展示了我们自定义的过渡效果。</p>
<p>为了让事情更简单，我们用UIView -animateWithDuration:completion:方法来实现。虽然用CABasicAnimation可以达到同样的效果，但是那样的话我们就需要对图层的变换和不透明属性创建单独的动画，然后当动画结束的是哦户在CAAnimationDelegate中把coverView从屏幕中移除。</p>
<p>#####清单8.14 用renderInContext:创建自定义过渡效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">   - (IBAction)performTransition</div><div class="line">   &#123;</div><div class="line">       //preserve the current view snapshot</div><div class="line">       UIGraphicsBeginImageContextWithOptions(self.view.bounds.size, YES, 0.0);</div><div class="line">       [self.view.layer renderInContext:UIGraphicsGetCurrentContext()];</div><div class="line">       UIImage *coverImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">       //insert snapshot view in front of this one</div><div class="line">       UIView *coverView = [[UIImageView alloc] initWithImage:coverImage];</div><div class="line">       coverView.frame = self.view.bounds;</div><div class="line">       [self.view addSubview:coverView];</div><div class="line">       //update the view (we&apos;ll simply randomize the layer background color)</div><div class="line">       CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       self.view.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0];</div><div class="line">       //perform animation (anything you like)</div><div class="line">       [UIView animateWithDuration:1.0 animations:^&#123;</div><div class="line">           //scale, rotate and fade the view</div><div class="line">           CGAffineTransform transform = CGAffineTransformMakeScale(0.01, 0.01);</div><div class="line">           transform = CGAffineTransformRotate(transform, M_PI_2);</div><div class="line">           coverView.transform = transform;</div><div class="line">           coverView.alpha = 0.0;</div><div class="line">       &#125; completion:^(BOOL finished) &#123;</div><div class="line">           //remove the cover view now we&apos;re finished with it</div><div class="line">           [coverView removeFromSuperview];</div><div class="line">       &#125;];</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-aa8e3c239a61eb22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.5.png"></p>
<p>这里有个警告：-renderInContext:捕获了图层的图片和子图层，但是不能对子图层正确地处理变换效果，而且对视频和OpenGL内容也不起作用。但是用CATransition，或者用私有的截屏方式就没有这个限制了。</p>
<p>#####在动画过程中取消动画<br>之前提到过，你可以用-addAnimation:forKey:方法中的key参数来在添加动画之后检索一个动画，使用如下方法：</p>
<p><code>- (CAAnimation *)animationForKey:(NSString *)key;</code></p>
<p> 但并不支持在动画运行过程中修改动画，所以这个方法主要用来检测动画的属性，或者判断它是否被添加到当前图层中。</p>
<p>为了终止一个指定的动画，你可以用如下方法把它从图层移除掉：</p>
<p><code>- (void)removeAnimationForKey:(NSString *)key;</code><br>或者移除所有动画：</p>
<p><code>- (void)removeAllAnimations;</code></p>
<p> 动画一旦被移除，图层的外观就立刻更新到当前的模型图层的值。一般说来，动画在结束之后被自动移除，除非设置removedOnCompletion为NO，如果你设置动画在结束之后不被自动移除，那么当它不需要的时候你要手动移除它；否则它会一直存在于内存中，直到图层被销毁。</p>
<p>我们来扩展之前旋转飞船的示例，这里添加一个按钮来停止或者启动动画。这一次我们用一个非nil的值作为动画的键，以便之后可以移除它。-animationDidStop:finished:方法中的flag参数表明了动画是自然结束还是被打断，我们可以在控制台打印出来。如果你用停止按钮来终止动画，它会打印NO，如果允许它完成，它会打印YES。</p>
<p>清单8.15是更新后的示例代码，图8.6显示了结果。</p>
<p>#####清单8.15 开始和停止一个动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">   @property (nonatomic, strong) CALayer *shipLayer;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //add the ship</div><div class="line">       self.shipLayer = [CALayer layer];</div><div class="line">       self.shipLayer.frame = CGRectMake(0, 0, 128, 128);</div><div class="line">       self.shipLayer.position = CGPointMake(150, 150);</div><div class="line">       self.shipLayer.contents = (__bridge id)[UIImage imageNamed: @&quot;Ship.png&quot;].CGImage;</div><div class="line">       [self.containerView.layer addSublayer:self.shipLayer];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (IBAction)start</div><div class="line">   &#123;</div><div class="line">       //animate the ship rotation</div><div class="line">       CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">       animation.keyPath = @&quot;transform.rotation&quot;;</div><div class="line">       animation.duration = 2.0;</div><div class="line">       animation.byValue = @(M_PI * 2);</div><div class="line">       animation.delegate = self;</div><div class="line">       [self.shipLayer addAnimation:animation forKey:@&quot;rotateAnimation&quot;];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (IBAction)stop</div><div class="line">   &#123;</div><div class="line">       [self.shipLayer removeAnimationForKey:@&quot;rotateAnimation&quot;];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">   &#123;</div><div class="line">       //log that the animation stopped</div><div class="line">       NSLog(@&quot;The animation stopped (finished: %@)&quot;, flag? @&quot;YES&quot;: @&quot;NO&quot;);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-acf5535f7530a9ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8.6.png"></p>
<p>#####总结<br> 这一章中，我们涉及了属性动画（你可以对单独的图层属性动画有更加具体的控制），动画组（把多个属性动画组合成一个独立单元）以及过度（影响整个图层，可以用来对图层的任何内容做任何类型的动画，包括子图层的添加和移除）。</p>
<p>在第九章中，我们继续学习CAMediaTiming协议，来看一看Core Animation是怎样处理逝去的时间。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之专用图层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之专用图层/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>复杂的组织都是专门化的<br>Catharine R. Stimpson</p>
</blockquote>
<p>到目前为止，我们已经探讨过CALayer类了，同时我们也了解到了一些非常有用的绘图和动画功能。但是Core Animation图层不仅仅能作用于图片和颜色而已。本章就会学习其他的一些图层类，进一步扩展使用Core Animation绘图的能力</p>
<ul>
<li>####<strong>CAShapeLayer</strong></li>
</ul>
<p> 在第四章『视觉效果』我们学习到了不使用图片的情况下用CGPath去构造任意形状的阴影。如果我们能用同样的方式创建相同形状的图层就好了。<br>CAShapeLayer是一个通过矢量图形而不是bitmap来绘制的图层子类。你指定诸如颜色和线宽等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就自动渲染出来了。当然，你也可以用Core Graphics直接向原始的CALyer的内容中绘制一个路径，相比直下，使用CAShapeLayer有以下一些优点：</p>
<ul>
<li>渲染快速。CAShapeLayer使用了硬件加速，绘制同一图形会比用Core Graphics快很多。</li>
<li>高效使用内存。一个CAShapeLayer不需要像普通CALayer一样创建一个寄宿图形，所以无论有多大，都不会占用太多的内存。</li>
<li>不会被图层边界剪裁掉。一个CAShapeLayer可以在边界之外绘制。你的图层路径不会像在使用Core Graphics的普通CALayer一样被剪裁掉（如我们在第二章所见）。</li>
<li>不会出现像素化。当你给CAShapeLayer做3D变换时，它不像一个有寄宿图的普通图层一样变得像素化。</li>
</ul>
<p><strong>创建一个CGPath</strong><br> CAShapeLayer可以用来绘制所有能够通过CGPath来表示的形状。这个形状不一定要闭合，图层路径也不一定要不可破，事实上你可以在一个图层上绘制好几个不同的形状。你可以控制一些属性比如lineWith（线宽，用点表示单位），lineCap（线条结尾的样子），和lineJoin（线条之间的结合点的样子）；但是在图层层面你只有一次机会设置这些属性。如果你想用不同颜色或风格来绘制多个形状，就不得不为每个形状准备一个图层了。</p>
<p>清单6.1 的代码用一个CAShapeLayer渲染一个简单的火柴人。CAShapeLayer属性是CGPathRef类型，但是我们用UIBezierPath帮助类创建了图层路径，这样我们就不用考虑人工释放CGPath了。图6.1是代码运行的结果。虽然还不是很完美，但是总算知道了大意对吧！</p>
<p>#####清单6.1 用CAShapeLayer绘制一个火柴人<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#import &quot;DrawingView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">    </div><div class="line">    @interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create path</div><div class="line">        UIBezierPath *path = [[UIBezierPath alloc] init];</div><div class="line">        [path moveToPoint:CGPointMake(175, 100)];</div><div class="line">        ￼</div><div class="line">        [path addArcWithCenter:CGPointMake(150, 100) radius:25 startAngle:0 endAngle:2*M_PI clockwise:YES];</div><div class="line">        [path moveToPoint:CGPointMake(150, 125)];</div><div class="line">        [path addLineToPoint:CGPointMake(150, 175)];</div><div class="line">        [path addLineToPoint:CGPointMake(125, 225)];</div><div class="line">        [path moveToPoint:CGPointMake(150, 175)];</div><div class="line">        [path addLineToPoint:CGPointMake(175, 225)];</div><div class="line">        [path moveToPoint:CGPointMake(100, 150)];</div><div class="line">        [path addLineToPoint:CGPointMake(200, 150)];</div><div class="line">        </div><div class="line">        //create shape layer</div><div class="line">        CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">        shapeLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">        shapeLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">        shapeLayer.lineWidth = 5;</div><div class="line">        shapeLayer.lineJoin = kCALineJoinRound;</div><div class="line">        shapeLayer.lineCap = kCALineCapRound;</div><div class="line">        shapeLayer.path = path.CGPath;</div><div class="line">        //add it to our view</div><div class="line">        [self.containerView.layer addSublayer:shapeLayer];</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-7d3000c3c6b9099d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.1.png"><br><strong>圆角</strong><br> 第二章里面提到了CAShapeLayer为创建圆角视图提供了一个方法，就是CALayer的cornerRadius属性（译者注：其实是在第四章提到的）。虽然使用CAShapeLayer类需要更多的工作，但是它有一个优势就是可以单独指定每个角。</p>
<p>我们创建圆角举行其实就是人工绘制单独的直线和弧度，但是事实上UIBezierPath有自动绘制圆角矩形的构造方法，下面这段代码绘制了一个有三个圆角一个直角的矩形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">//define path parameters</div><div class="line">CGRect rect = CGRectMake(50, 50, 100, 100);</div><div class="line">CGSize radii = CGSizeMake(20, 20);</div><div class="line">UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft;</div><div class="line">//create path</div><div class="line">UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect byRoundingCorners:corners cornerRadii:radii];</div></pre></td></tr></table></figure></p>
<p>我们可以通过这个图层路径绘制一个既有直角又有圆角的视图。如果我们想依照此图形来剪裁视图内容，我们可以把CAShapeLayer作为视图的宿主图层，而不是添加一个子视图（图层蒙板的详细解释见第四章『视觉效果』）。</p>
<ul>
<li>####<strong>CATextLayer</strong></li>
</ul>
<p>用户界面是无法从一个单独的图片里面构建的。一个设计良好的图标能够很好地表现一个按钮或控件的意图，不过你迟早都要需要一个不错的老式风格的文本标签。<br>如果你想在一个图层里面显示文字，完全可以借助图层代理直接将字符串使用Core Graphics写入图层的内容（这就是UILabel的精髓）。如果越过寄宿于图层的视图，直接在图层上操作，那其实相当繁琐。你要为每一个显示文字的图层创建一个能像图层代理一样工作的类，还要逻辑上判断哪个图层需要显示哪个字符串，更别提还要记录不同的字体，颜色等一系列乱七八糟的东西。<br>万幸的是这些都是不必要的，Core Animation提供了一个CALayer的子类CATextLayer，它以图层的形式包含了UILabel<br>几乎所有的绘制特性，并且额外提供了一些新的特性。</p>
<p>同样，CATextLayer也要比UILabel渲染得快得多。很少有人知道在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a> 6及之前的本，UILabel<br>其实是通过WebKit来实现绘制的，这样就造成了当有很多文字的时候就会有极大的性能压力。而CATextLayer使用了Core text，并且渲染得非常快。<br>让我们来尝试用CATextLayer来显示一些文字。清单6.2的代码实现了这一功能，结果如图6.2所示。</p>
<p>#####清单6.2 用CATextLayer来实现一个UILabel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">  </div><div class="line">  @property (nonatomic, weak) IBOutlet UIView *labelView;</div><div class="line">  </div><div class="line">  @end</div><div class="line">  </div><div class="line">  @implementation ViewController</div><div class="line">  - (void)viewDidLoad</div><div class="line">  &#123;</div><div class="line">      [super viewDidLoad];</div><div class="line">      </div><div class="line">      //create a text layer</div><div class="line">      CATextLayer *textLayer = [CATextLayer layer];</div><div class="line">      textLayer.frame = self.labelView.bounds;</div><div class="line">      [self.labelView.layer addSublayer:textLayer];</div><div class="line">      </div><div class="line">      //set text attributes</div><div class="line">      textLayer.foregroundColor = [UIColor blackColor].CGColor;</div><div class="line">      textLayer.alignmentMode = kCAAlignmentJustified;</div><div class="line">      textLayer.wrapped = YES;</div><div class="line">      </div><div class="line">      //choose a font</div><div class="line">      UIFont *font = [UIFont systemFontOfSize:15];</div><div class="line">      </div><div class="line">      //set layer font</div><div class="line">      CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">      CGFontRef fontRef = CGFontCreateWithFontName(fontName);</div><div class="line">      textLayer.font = fontRef;</div><div class="line">      textLayer.fontSize = font.pointSize;</div><div class="line">      CGFontRelease(fontRef);</div><div class="line">      </div><div class="line">      //choose some text</div><div class="line">      NSString *text = @&quot;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&quot;;</div><div class="line">      </div><div class="line">      //set layer text</div><div class="line">      textLayer.string = text;</div><div class="line">  &#125;</div><div class="line">  @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-3d0e66a31fbaa91b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.2.png"><br>如果你仔细看这个文本，你会发现一个奇怪的地方：这些文本有一些像素化了。这是因为并没有以Retina的方式渲染，第二章提到了这个contentScale属性，用来决定图层内容应该以怎样的分辨率来渲染。contentsScale并不关心屏幕的拉伸因素而总是默认为1.0。如果我们想以Retina的质量来显示文字，我们就得手动地设置CATextLayer的contentsScale属性，如下：<br><code>textLayer.contentsScale = [UIScreen mainScreen].scale;</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d646738dc883b658.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.3.png"></p>
<pre><code>设置contentsScale来匹配屏幕
</code></pre><p> CATextLayer的font属性不是一个UIFont类型，而是一个CFTypeRef类型。这样可以根据你的具体需要来决定字体属性应该是用CGFontRef类型还是CTFontRef类型（Core Text字体）。同时字体大小也是用fontSize属性单独设置的，因为CTFontRef和CGFontRef并不像UIFont一样包含点大小。这个例子会告诉你如何将UIFont转换成CGFontRef。</p>
<p>另外，CATextLayer的string属性并不是你想象的NSString类型，而是id类型。这样你既可以用NSString也可以用NSAttributedString来指定文本了（注意，NSAttributedString并不是NSString的子类）。属性化字符串是iOS用来渲染字体风格的机制，它以特定的方式来决定指定范围内的字符串的原始信息，比如字体，颜色，字重，斜体等。</p>
<p><strong>富文本</strong><br> iOS 6中，Apple给UILabel和其他UIKit文本视图添加了直接的属性化字符串的支持，应该说这是一个很方便的特性。不过事实上从iOS3.2开始CATextLayer就已经支持属性化字符串了。这样的话，如果你想要支持更低版本的iOS系统，CATextLayer无疑是你向界面中增加富文本的好办法，而且也不用去跟复杂的Core Text打交道，也省了用UIWebView的麻烦。</p>
<p>让我们编辑一下示例使用到NSAttributedString（见清单6.3）.iOS 6及以上我们可以用新的NSTextAttributeName实例来设置我们的字符串属性，但是练习的目的是为了演示在iOS 5及以下，所以我们用了Core Text，也就是说你需要把Core Text framework添加到你的项目中。否则，编译器是无法识别属性常量的。</p>
<p>图6.4是代码运行结果（注意那个红色的下划线文本）</p>
<p>####清单6.3 用NSAttributedString实现一个富文本标签。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">#import &quot;DrawingView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &lt;CoreText/CoreText.h&gt;</div><div class="line">    </div><div class="line">    @interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *labelView;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //create a text layer</div><div class="line">        CATextLayer *textLayer = [CATextLayer layer];</div><div class="line">        textLayer.frame = self.labelView.bounds;</div><div class="line">        textLayer.contentsScale = [UIScreen mainScreen].scale;</div><div class="line">        [self.labelView.layer addSublayer:textLayer];</div><div class="line">        </div><div class="line">        //set text attributes</div><div class="line">        textLayer.alignmentMode = kCAAlignmentJustified;</div><div class="line">        textLayer.wrapped = YES;</div><div class="line">        </div><div class="line">        //choose a font</div><div class="line">        UIFont *font = [UIFont systemFontOfSize:15];</div><div class="line">        </div><div class="line">        //choose some text</div><div class="line">        NSString *text = @&quot;Lorem ipsum dolor sit amet, consectetur adipiscing \ elit. Quisque massa arcu, eleifend vel varius in, facilisis pulvinar \ leo. Nunc quis nunc at mauris pharetra condimentum ut ac neque. Nunc \ elementum, libero ut porttitor dictum, diam odio congue lacus, vel \ fringilla sapien diam at purus. Etiam suscipit pretium nunc sit amet \ lobortis&quot;;</div><div class="line">        ￼</div><div class="line">        //create attributed string</div><div class="line">        NSMutableAttributedString *string = nil;</div><div class="line">        string = [[NSMutableAttributedString alloc] initWithString:text];</div><div class="line">        </div><div class="line">        //convert UIFont to a CTFont</div><div class="line">        CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">        CGFloat fontSize = font.pointSize;</div><div class="line">        CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);</div><div class="line">        </div><div class="line">        //set text attributes</div><div class="line">        NSDictionary *attribs = @&#123;</div><div class="line">                                  (__bridge id)kCTForegroundColorAttributeName:(__bridge id)[UIColor blackColor].CGColor,</div><div class="line">                                  (__bridge id)kCTFontAttributeName: (__bridge id)fontRef</div><div class="line">                                  &#125;;</div><div class="line">        </div><div class="line">        [string setAttributes:attribs range:NSMakeRange(0, [text length])];</div><div class="line">        attribs = @&#123;</div><div class="line">                    (__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,</div><div class="line">                    (__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),</div><div class="line">                    (__bridge id)kCTFontAttributeName: (__bridge id)fontRef</div><div class="line">                    &#125;;</div><div class="line">        [string setAttributes:attribs range:NSMakeRange(6, 5)];</div><div class="line">        </div><div class="line">        //release the CTFont we created earlier</div><div class="line">        CFRelease(fontRef);</div><div class="line">        </div><div class="line">        //set layer text</div><div class="line">        textLayer.string = string;</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-2fe48e0d4e7ac423.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.4.png"></p>
<p><strong>行距和字距</strong></p>
<p> 有必要提一下的是，由于绘制的实现机制不同（Core Text和WebKit），用CATextLayer渲染和用UILabel渲染出的文本行距和字距也不是不尽相同的。</p>
<p>二者的差异程度（由使用的字体和字符决定）总的来说挺小，但是如果你想正确的显示普通便签和CATextLayer就一定要记住这一点</p>
<p><strong>UILabel的替代品</strong><br> 我们已经证实了CATextLayer比UILabel有着更好的性能表现，同时还有额外的布局选项并且在iOS 5上支持富文本。但是与一般的标签比较而言会更加繁琐一些。如果我们真的在需求一个UILabel的可用替代品，最好是能够在Interface Builder上创建我们的标签，而且尽可能地像一般的视图一样正常工作。</p>
<p>我们应该继承UILabel，然后添加一个子图层CATextLayer并重写显示文本的方法。但是仍然会有由UILabel的-drawRect:方法创建的空寄宿图。而且由于CALayer不支持自动缩放和自动布局，子视图并不是主动跟踪视图边界的大小，所以每次视图大小被更改，我们不得不手动更新子图层的边界。</p>
<p>我们真正想要的是一个用CATextLayer作为宿主图层的UILabel子类，这样就可以随着视图自动调整大小而且也没有冗余的寄宿图啦。</p>
<p>就像我们在第一章『图层树』讨论的一样，每一个UIView都是寄宿在一个CALayer的示例上。这个图层是由视图自动创建和管理的，那我们可以用别的图层类型替代它么？一旦被创建，我们就无法代替这个图层了。但是如果我们继承了UIView，那我们就可以重写+layerClass方法使得在创建的时候能返回一个不同的图层子类。UIView会在初始化的时候调用+layerClass方法，然后用它的返回类型来创建宿主图层。</p>
<p>清单6.4 演示了一个UILabel子类LayerLabel用CATextLayer绘制它的问题，而不是调用一般的UILabel使用的较慢的-drawRect：方法。LayerLabel示例既可以用代码实现，也可以在Interface Builder实现，只要把普通的标签拖入视图之中，然后设置它的类是LayerLabel就可以了。</p>
<p>#####清单6.4 使用CATextLayer的UILabel子类：LayerLabel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">#import &quot;LayerLabel.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">    </div><div class="line">    @implementation LayerLabel</div><div class="line">    + (Class)layerClass</div><div class="line">    &#123;</div><div class="line">        //this makes our label create a CATextLayer //instead of a regular CALayer for its backing layer</div><div class="line">        return [CATextLayer class];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (CATextLayer *)textLayer</div><div class="line">    &#123;</div><div class="line">        return (CATextLayer *)self.layer;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)setUp</div><div class="line">    &#123;</div><div class="line">        //set defaults from UILabel settings</div><div class="line">        self.text = self.text;</div><div class="line">        self.textColor = self.textColor;</div><div class="line">        self.font = self.font;</div><div class="line">        </div><div class="line">        //we should really derive these from the UILabel settings too</div><div class="line">        //but that&apos;s complicated, so for now we&apos;ll just hard-code them</div><div class="line">        [self textLayer].alignmentMode = kCAAlignmentJustified;</div><div class="line">        ￼</div><div class="line">        [self textLayer].wrapped = YES;</div><div class="line">        [self.layer display];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (id)initWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        //called when creating label programmatically</div><div class="line">        if (self = [super initWithFrame:frame]) &#123;</div><div class="line">            [self setUp];</div><div class="line">        &#125;</div><div class="line">        return self;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)awakeFromNib</div><div class="line">    &#123;</div><div class="line">        //called when creating label using Interface Builder</div><div class="line">        [self setUp];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)setText:(NSString *)text</div><div class="line">    &#123;</div><div class="line">        super.text = text;</div><div class="line">        //set layer text</div><div class="line">        [self textLayer].string = text;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)setTextColor:(UIColor *)textColor</div><div class="line">    &#123;</div><div class="line">        super.textColor = textColor;</div><div class="line">        //set layer text color</div><div class="line">        [self textLayer].foregroundColor = textColor.CGColor;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)setFont:(UIFont *)font</div><div class="line">    &#123;</div><div class="line">        super.font = font;</div><div class="line">        //set layer font</div><div class="line">        CFStringRef fontName = (__bridge CFStringRef)font.fontName;</div><div class="line">        CGFontRef fontRef = CGFontCreateWithFontName(fontName);</div><div class="line">        [self textLayer].font = fontRef;</div><div class="line">        [self textLayer].fontSize = font.pointSize;</div><div class="line">        ￼</div><div class="line">        CGFontRelease(fontRef);</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p> 如果你运行代码，你会发现文本并没有像素化，而我们也没有设置contentsScale属性。把CATextLayer作为宿主图层的另一好处就是视图自动设置了contentsScale属性。</p>
<p>在这个简单的例子中，我们只是实现了UILabel的一部分风格和布局属性，不过稍微再改进一下我们就可以创建一个支持UILabel所有功能甚至更多功能的LayerLabel类（你可以在一些线上的开源项目中找到）。</p>
<p>如果你打算支持iOS 6及以上，基于CATextLayer的标签可能就有有些局限性。但是总得来说，如果想在app里面充分利用CALayer子类，用+layerClass来创建基于不同图层的视图是一个简单可复用的方法。</p>
<ul>
<li>####<strong>CATransformLayer</strong></li>
</ul>
<p> 当我们在构造复杂的3D事物的时候，如果能够组织独立元素就太方便了。比如说，你想创造一个孩子的手臂：你就需要确定哪一部分是孩子的手腕，哪一部分是孩子的前臂，哪一部分是孩子的肘，哪一部分是孩子的上臂，哪一部分是孩子的肩膀等等。</p>
<p>当然是允许独立地移动每个区域的啦。以肘为指点会移动前臂和手，而不是肩膀。Core Animation图层很容易就可以让你在2D环境下做出这样的层级体系下的变换，但是3D情况下就不太可能，因为所有的图层都把他的孩子都平面化到一个场景中（第五章『变换』有提到）。</p>
<p>CATransformLayer解决了这个问题，CATransformLayer不同于普通的CALayer，因为它不能显示它自己的内容。只有当存在了一个能作用域子图层的变换它才真正存在。CATransformLayer并不平面化它的子图层，所以它能够用于构造一个层级的3D结构，比如我的手臂示例。</p>
<p>用代码创建一个手臂需要相当多的代码，所以我就演示得更简单一些吧：在第五章的立方体示例，我们将通过旋转camara来解决图层平面化问题而不是像立方体示例代码中用的sublayerTransform。这是一个非常不错的技巧，但是只能作用域单个对象上，如果你的场景包含两个立方体，那我们就不能用这个技巧单独旋转他们了。</p>
<p>那么，就让我们来试一试CATransformLayer吧，第一个问题就来了：在第五章，我们是用多个视图来构造了我们的立方体，而不是单独的图层。我们不能在不打乱已有的视图层次的前提下在一个本身不是有寄宿图的图层中放置一个寄宿图图层。我们可以创建一个新的UIView子类寄宿在CATransformLayer（用+layerClass方法）之上。但是，为了简化案例，我们仅仅重建了一个单独的图层，而不是使用视图。这意味着我们不能像第五章一样在立方体表面显示按钮和标签，不过我们现在也用不到这个特性。</p>
<p>清单6.5就是代码。我们以我们在第五章使用过的相同基本逻辑放置立方体。但是并不像以前那样直接将立方面添加到容器视图的宿主图层，我们将他们放置到一个CATransformLayer中创建一个独立的立方体对象，然后将两个这样的立方体放进容器中。我们随机地给立方面染色以将他们区分开来，这样就不用靠标签或是光亮来区分他们。图6.5是运行结果。</p>
<p>#####清单6.5 用CATransformLayer装配一个3D图层体系<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (CALayer *)faceWithTransform:(CATransform3D)transform</div><div class="line">&#123;</div><div class="line">    //create cube face layer</div><div class="line">    CALayer *face = [CALayer layer];</div><div class="line">    face.frame = CGRectMake(-50, -50, 100, 100);</div><div class="line">    </div><div class="line">    //apply a random color</div><div class="line">    CGFloat red = (rand() / (double)INT_MAX);</div><div class="line">    CGFloat green = (rand() / (double)INT_MAX);</div><div class="line">    CGFloat blue = (rand() / (double)INT_MAX);</div><div class="line">    face.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">    </div><div class="line">    ￼//apply the transform and return</div><div class="line">    face.transform = transform;</div><div class="line">    return face;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (CALayer *)cubeWithTransform:(CATransform3D)transform</div><div class="line">&#123;</div><div class="line">    //create cube layer</div><div class="line">    CATransformLayer *cube = [CATransformLayer layer];</div><div class="line">    </div><div class="line">    //add cube face 1</div><div class="line">    CATransform3D ct = CATransform3DMakeTranslation(0, 0, 50);</div><div class="line">    [cube addSublayer:[self faceWithTransform:ct]];</div><div class="line">    </div><div class="line">    //add cube face 2</div><div class="line">    ct = CATransform3DMakeTranslation(50, 0, 0);</div><div class="line">    ct = CATransform3DRotate(ct, M_PI_2, 0, 1, 0);</div><div class="line">    [cube addSublayer:[self faceWithTransform:ct]];</div><div class="line">    </div><div class="line">    //add cube face 3</div><div class="line">    ct = CATransform3DMakeTranslation(0, -50, 0);</div><div class="line">    ct = CATransform3DRotate(ct, M_PI_2, 1, 0, 0);</div><div class="line">    [cube addSublayer:[self faceWithTransform:ct]];</div><div class="line">    </div><div class="line">    //add cube face 4</div><div class="line">    ct = CATransform3DMakeTranslation(0, 50, 0);</div><div class="line">    ct = CATransform3DRotate(ct, -M_PI_2, 1, 0, 0);</div><div class="line">    [cube addSublayer:[self faceWithTransform:ct]];</div><div class="line">    </div><div class="line">    //add cube face 5</div><div class="line">    ct = CATransform3DMakeTranslation(-50, 0, 0);</div><div class="line">    ct = CATransform3DRotate(ct, -M_PI_2, 0, 1, 0);</div><div class="line">    [cube addSublayer:[self faceWithTransform:ct]];</div><div class="line">    </div><div class="line">    //add cube face 6</div><div class="line">    ct = CATransform3DMakeTranslation(0, 0, -50);</div><div class="line">    ct = CATransform3DRotate(ct, M_PI, 0, 1, 0);</div><div class="line">    [cube addSublayer:[self faceWithTransform:ct]];</div><div class="line">    </div><div class="line">    //center the cube layer within the container</div><div class="line">    CGSize containerSize = self.containerView.bounds.size;</div><div class="line">    cube.position = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div><div class="line">    </div><div class="line">    //apply the transform and return</div><div class="line">    cube.transform = transform;</div><div class="line">    return cube;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;￼</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //set up the perspective transform</div><div class="line">    CATransform3D pt = CATransform3DIdentity;</div><div class="line">    pt.m34 = -1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = pt;</div><div class="line">    </div><div class="line">    //set up the transform for cube 1 and add it</div><div class="line">    CATransform3D c1t = CATransform3DIdentity;</div><div class="line">    c1t = CATransform3DTranslate(c1t, -100, 0, 0);</div><div class="line">    CALayer *cube1 = [self cubeWithTransform:c1t];</div><div class="line">    [self.containerView.layer addSublayer:cube1];</div><div class="line">    </div><div class="line">    //set up the transform for cube 2 and add it</div><div class="line">    CATransform3D c2t = CATransform3DIdentity;</div><div class="line">    c2t = CATransform3DTranslate(c2t, 100, 0, 0);</div><div class="line">    c2t = CATransform3DRotate(c2t, -M_PI_4, 1, 0, 0);</div><div class="line">    c2t = CATransform3DRotate(c2t, -M_PI_4, 0, 1, 0);</div><div class="line">    CALayer *cube2 = [self cubeWithTransform:c2t];</div><div class="line">    [self.containerView.layer addSublayer:cube2];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"> </div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;￼</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //set up the perspective transform</div><div class="line">    CATransform3D pt = CATransform3DIdentity;</div><div class="line">    pt.m34 = -1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = pt;</div><div class="line">    </div><div class="line">    //set up the transform for cube 1 and add it</div><div class="line">    CATransform3D c1t = CATransform3DIdentity;</div><div class="line">    c1t = CATransform3DTranslate(c1t, -100, 0, 0);</div><div class="line">    CALayer *cube1 = [self cubeWithTransform:c1t];</div><div class="line">    [self.containerView.layer addSublayer:cube1];</div><div class="line">    </div><div class="line">    //set up the transform for cube 2 and add it</div><div class="line">    CATransform3D c2t = CATransform3DIdentity;</div><div class="line">    c2t = CATransform3DTranslate(c2t, 100, 0, 0);</div><div class="line">    c2t = CATransform3DRotate(c2t, -M_PI_4, 1, 0, 0);</div><div class="line">    c2t = CATransform3DRotate(c2t, -M_PI_4, 0, 1, 0);</div><div class="line">    CALayer *cube2 = [self cubeWithTransform:c2t];</div><div class="line">    [self.containerView.layer addSublayer:cube2];</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"> </div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;￼</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //set up the perspective transform</div><div class="line">    CATransform3D pt = CATransform3DIdentity;</div><div class="line">    pt.m34 = -1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = pt;</div><div class="line">    </div><div class="line">    //set up the transform for cube 1 and add it</div><div class="line">    CATransform3D c1t = CATransform3DIdentity;</div><div class="line">    c1t = CATransform3DTranslate(c1t, -100, 0, 0);</div><div class="line">    CALayer *cube1 = [self cubeWithTransform:c1t];</div><div class="line">    [self.containerView.layer addSublayer:cube1];</div><div class="line">    </div><div class="line">    //set up the transform for cube 2 and add it</div><div class="line">    CATransform3D c2t = CATransform3DIdentity;</div><div class="line">    c2t = CATransform3DTranslate(c2t, 100, 0, 0);</div><div class="line">    c2t = CATransform3DRotate(c2t, -M_PI_4, 1, 0, 0);</div><div class="line">    c2t = CATransform3DRotate(c2t, -M_PI_4, 0, 1, 0);</div><div class="line">    CALayer *cube2 = [self cubeWithTransform:c2t];</div><div class="line">    [self.containerView.layer addSublayer:cube2];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c10f0db680af8c9f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.5.png"></p>
<ul>
<li>####<em>*CAGradientLayer</em></li>
</ul>
<p>CAGradientLayer是用来生成两种或更多颜色平滑渐变的。用Core Graphics复制一个CAGradientLayer并将内容绘制到一个普通图层的寄宿图也是有可能的，但是CAGradientLayer的真正好处在于绘制使用了硬件加速。</p>
<p><strong>基础渐变</strong></p>
<p>我们将从一个简单的红变蓝的对角线渐变开始（见清单6.6）.这些渐变色彩放在一个数组中，并赋给colors属性。这个数组成员接受CGColorRef类型的值（并不是从NSObject派生而来），所以我们要用通过bridge转换以确保编译正常。</p>
<p>CAGradientLayer也有startPoint和endPoint属性，他们决定了渐变的方向。这两个参数是以单位坐标系进行的定义，所以左上角坐标是{0, 0}，右下角坐标是{1, 1}。代码运行结果如图6.6</p>
<p>#####清单6.6 简单的两种颜色的对角线渐变<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //create gradient layer and add it to our container view</div><div class="line">       CAGradientLayer *gradientLayer = [CAGradientLayer layer];</div><div class="line">       gradientLayer.frame = self.containerView.bounds;</div><div class="line">       [self.containerView.layer addSublayer:gradientLayer];</div><div class="line">       </div><div class="line">       //set gradient colors</div><div class="line">       gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id)[UIColor blueColor].CGColor];</div><div class="line">       </div><div class="line">       //set gradient start and end points</div><div class="line">       gradientLayer.startPoint = CGPointMake(0, 0);</div><div class="line">       gradientLayer.endPoint = CGPointMake(1, 1);</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-9d6f27a9846fb2b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.6.png"></p>
<p>####多重渐变<br> 如果你愿意，colors属性可以包含很多颜色，所以创建一个彩虹一样的多重渐变也是很简单的。默认情况下，这些颜色在空间上均匀地被渲染，但是我们可以用locations属性来调整空间。locations属性是一个浮点数值的数组（以NSNumber包装）。这些浮点数定义了colors属性中每个不同颜色的位置，同样的，也是以单位坐标系进行标定。0.0代表着渐变的开始，1.0代表着结束。</p>
<p>locations数组并不是强制要求的，但是如果你给它赋值了就一定要确保locations的数组大小和colors数组大小一定要相同，否则你将会得到一个空白的渐变。</p>
<p>清单6.7展示了一个基于清单6.6的对角线渐变的代码改造。现在变成了从红到黄最后到绿色的渐变。locations数组指定了0.0，0.25和0.5三个数值，这样这三个渐变就有点像挤在了左上角。（如图6.7）.</p>
<p>#####清单6.7 在渐变上使用locations<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //create gradient layer and add it to our container view</div><div class="line">    CAGradientLayer *gradientLayer = [CAGradientLayer layer];</div><div class="line">    gradientLayer.frame = self.containerView.bounds;</div><div class="line">    [self.containerView.layer addSublayer:gradientLayer];</div><div class="line">    </div><div class="line">    //set gradient colors</div><div class="line">    gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor, (__bridge id) [UIColor yellowColor].CGColor, (__bridge id)[UIColor greenColor].CGColor];</div><div class="line">    </div><div class="line">    //set locations</div><div class="line">    gradientLayer.locations = @[@0.0, @0.25, @0.5];</div><div class="line">    </div><div class="line">    //set gradient start and end points</div><div class="line">    gradientLayer.startPoint = CGPointMake(0, 0);</div><div class="line">    gradientLayer.endPoint = CGPointMake(1, 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-f02ef8f49c4a9e7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.7.png"></p>
<ul>
<li>####<strong>CAReplicatorLayer</strong></li>
</ul>
<p>CAReplicatorLayer的目的是为了高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并在每个复制体上应用不同的变换。看上去演示能够更加解释这些，我们来写个例子吧。</p>
<p>####重复图层（Repeating Layers）</p>
<p> 清单6.8中，我们在屏幕的中间创建了一个小白色方块图层，然后用CAReplicatorLayer生成十个图层组成一个圆圈。instanceCount属性指定了图层需要重复多少次。instanceTransform指定了一个CATransform3D3D变换（这种情况下，下一图层的位移和旋转将会移动到圆圈的下一个点）。</p>
<p>变换是逐步增加的，每个实例都是相对于前一实例布局。这就是为什么这些复制体最终不会出现在同意位置上，图6.8是代码运行结果。</p>
<p>清单6.8 用CAReplicatorLayer重复图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"> </div><div class="line"> @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line"> </div><div class="line"> @end</div><div class="line"> </div><div class="line"> @implementation ViewController</div><div class="line"> - (void)viewDidLoad</div><div class="line"> &#123;</div><div class="line">     [super viewDidLoad];</div><div class="line">     //create a replicator layer and add it to our view</div><div class="line">     CAReplicatorLayer *replicator = [CAReplicatorLayer layer];</div><div class="line">     replicator.frame = self.containerView.bounds;</div><div class="line">     [self.containerView.layer addSublayer:replicator];</div><div class="line">     </div><div class="line">     //configure the replicator</div><div class="line">     replicator.instanceCount = 10;</div><div class="line">     </div><div class="line">     //apply a transform for each instance</div><div class="line">     CATransform3D transform = CATransform3DIdentity;</div><div class="line">     transform = CATransform3DTranslate(transform, 0, 200, 0);</div><div class="line">     transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);</div><div class="line">     transform = CATransform3DTranslate(transform, 0, -200, 0);</div><div class="line">     replicator.instanceTransform = transform;</div><div class="line">     </div><div class="line">     //apply a color shift for each instance</div><div class="line">     replicator.instanceBlueOffset = -0.1;</div><div class="line">     replicator.instanceGreenOffset = -0.1;</div><div class="line">     </div><div class="line">     //create a sublayer and place it inside the replicator</div><div class="line">     CALayer *layer = [CALayer layer];</div><div class="line">     layer.frame = CGRectMake(100.0f, 100.0f, 100.0f, 100.0f);</div><div class="line">     layer.backgroundColor = [UIColor whiteColor].CGColor;</div><div class="line">     [replicator addSublayer:layer];</div><div class="line"> &#125;</div><div class="line"> @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-80bd262bd9d26a56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.8.png"><br>注意到当图层在重复的时候，他们的颜色也在变化：这是用instanceBlueOffset和instanceGreenOffset属性实现的。通过逐步减少蓝色和绿色通道，我们逐渐将图层颜色转换成了红色。这个复制效果看起来很酷，但是CAReplicatorLayer真正应用到实际程序上的场景比如：一个游戏中导弹的轨迹云，或者粒子爆炸（尽管iOS 5已经引入了CAEmitterLayer，它更适合创建任意的粒子效果）。除此之外，还有一个实际应用是：反射。</p>
<p>####反射<br> 使用CAReplicatorLayer并应用一个负比例变换于一个复制图层，你就可以创建指定视图（或整个视图层次）内容的镜像图片，这样就创建了一个实时的『反射』效果。让我们来尝试实现这个创意：指定一个继承于UIView的ReflectionView，它会自动产生内容的反射效果。实现这个效果的代码很简单（见清单6.9），实际上用ReflectionView实现这个效果会更简单，我们只需要把ReflectionView的实例放置于Interface Builder（见图6.9），它就会实时生成子视图的反射，而不需要别的代码（见图6.10）.</p>
<p>清单6.9 用CAReplicatorLayer自动绘制反射<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">#import &quot;ReflectionView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">    </div><div class="line">    @implementation ReflectionView</div><div class="line">    </div><div class="line">    + (Class)layerClass</div><div class="line">    &#123;</div><div class="line">        return [CAReplicatorLayer class];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)setUp</div><div class="line">    &#123;</div><div class="line">        //configure replicator</div><div class="line">        CAReplicatorLayer *layer = (CAReplicatorLayer *)self.layer;</div><div class="line">        layer.instanceCount = 2;</div><div class="line">        </div><div class="line">        //move reflection instance below original and flip vertically</div><div class="line">        CATransform3D transform = CATransform3DIdentity;</div><div class="line">        CGFloat verticalOffset = self.bounds.size.height + 2;</div><div class="line">        transform = CATransform3DTranslate(transform, 0, verticalOffset, 0);</div><div class="line">        transform = CATransform3DScale(transform, 1, -1, 0);</div><div class="line">        layer.instanceTransform = transform;</div><div class="line">        </div><div class="line">        //reduce alpha of reflection layer</div><div class="line">        layer.instanceAlphaOffset = -0.6;</div><div class="line">    &#125;</div><div class="line">    ￼</div><div class="line">    - (id)initWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        //this is called when view is created in code</div><div class="line">        if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">            [self setUp];</div><div class="line">        &#125;</div><div class="line">        return self;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)awakeFromNib</div><div class="line">    &#123;</div><div class="line">        //this is called when view is created from a nib</div><div class="line">        [self setUp];</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-501f6ce2ff19b320.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.9.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-93aaab6c38bcfcc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6.10.png"></p>
<ul>
<li>####<em>*CAScrollLayer</em><br>对于一个未转换的图层，它的bounds和它的frame是一样的，frame属性是由bounds属性自动计算而出的，所以更改任意一个值都会更新其他值。</li>
</ul>
<p>但是如果你只想显示一个大图层里面的一小部分呢。比如说，你可能有一个很大的图片，你希望用户能够随意滑动，或者是一个数据或文本的长列表。在一个典型的iOS应用中，你可能会用到UITableView或是UIScrollView，但是对于独立的图层来说，什么会等价于刚刚提到的UITableView和UIScrollView呢？</p>
<p>在第二章中，我们探索了图层的contentsRect属性的用法，它的确是能够解决在图层中小地方显示大图片的解决方法。但是如果你的图层包含子图层那它就不是一个非常好的解决方案，因为，这样做的话每次你想『滑动』可视区域的时候，你就需要手工重新计算并更新所有的子图层位置。</p>
<p>这个时候就需要CAScrollLayer了。CAScrollLayer有一个-scrollToPoint:方法，它自动适应bounds的原点以便图层内容出现在滑动的地方。注意，这就是它做的所有事情。前面提到过，Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹（当视图滑动超多了它的边界的将会反弹回正确的地方）。</p>
<p>让我们来用CAScrollLayer来常见一个基本的UIScrollView替代品。我们将会用CAScrollLayer作为视图的宿主图层，并创建一个自定义的UIView，然后用UIPanGestureRecognizer实现触摸事件响应。这段代码见清单6.10. 图6.11是运行效果：ScrollView显示了一个大于它的frame的UIImageView。</p>
<p>####清单6.10 用CAScrollLayer实现滑动视图<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#import &quot;ScrollView.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt; @implementation ScrollView</div><div class="line"></div><div class="line">    + (Class)layerClass</div><div class="line">    &#123;</div><div class="line">        return [CAScrollLayer class];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)setUp</div><div class="line">    &#123;</div><div class="line">        //enable clipping</div><div class="line">        self.layer.masksToBounds = YES;</div><div class="line">        </div><div class="line">        //attach pan gesture recognizer</div><div class="line">        UIPanGestureRecognizer *recognizer = nil;</div><div class="line">        recognizer = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(pan:)];</div><div class="line">        [self addGestureRecognizer:recognizer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (id)initWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        //this is called when view is created in code</div><div class="line">        if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">            [self setUp];</div><div class="line">        &#125;</div><div class="line">        return self;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)awakeFromNib &#123;</div><div class="line">        //this is called when view is created from a nib</div><div class="line">        [self setUp];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)pan:(UIPanGestureRecognizer *)recognizer</div><div class="line">    &#123;</div><div class="line">        //get the offset by subtracting the pan gesture</div><div class="line">        //translation from the current bounds origin</div><div class="line">        CGPoint offset = self.bounds.origin;</div><div class="line">        offset.x -= [recognizer translationInView:self].x;</div><div class="line">        offset.y -= [recognizer translationInView:self].y;</div><div class="line">        </div><div class="line">        //scroll the layer</div><div class="line">        [(CAScrollLayer *)self.layer scrollToPoint:offset];</div><div class="line">        </div><div class="line">        //reset the pan gesture translation</div><div class="line">        [recognizer setTranslation:CGPointZero inView:self];</div><div class="line">    &#125;</div><div class="line">    @end</div><div class="line">``` </div><div class="line">不同于UIScrollView，我们定制的滑动视图类并没有实现任何形式的边界检查（bounds checking）。图层内容极有可能滑出视图的边界并无限滑下去。CAScrollLayer并没有等同于UIScrollView中contentSize的属性，所以当CAScrollLayer滑动的时候完全没有一个全局的可滑动区域的概念，也无法自适应它的边界原点至你指定的值。它之所以不能自适应边界大小是因为它不需要，内容完全可以超过边界。</div><div class="line"></div><div class="line">那你一定会奇怪用CAScrollLayer的意义到底何在，因为你可以简单地用一个普通的CALayer然后手动适应边界原点啊。真相其实并不复杂，UIScrollView并没有用CAScrollLayer，事实上，就是简单的通过直接操作图层边界来实现滑动。</div><div class="line"></div><div class="line">CAScrollLayer有一个潜在的有用特性。如果你查看CAScrollLayer的头文件，你就会注意到有一个扩展分类实现了一些方法和属性：</div></pre></td></tr></table></figure></p>
<ul>
<li>(void)scrollPoint:(CGPoint)p;</li>
<li>(void)scrollRectToVisible:(CGRect)r;<br>@property(readonly) CGRect visibleRect;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">看到这些方法和属性名，你也许会以为这些方法给每个CALayer实例增加了滑动功能。但是事实上他们只是放置在CAScrollLayer中的图层的实用方法。scrollPoint:方法从图层树中查找并找到第一个可用的CAScrollLayer，然后滑动它使得指定点成为可视的。scrollRectToVisible:方法实现了同样的事情只不过是作用在一个矩形上的。visibleRect属性决定图层（如果存在的话）的哪部分是当前的可视区域。如果你自己实现这些方法就会相对容易明白一点，但是CAScrollLayer帮你省了这些麻烦，所以当涉及到实现图层滑动的时候就可以用上了。</div><div class="line"></div><div class="line">-  ####**CATiledLayer**</div><div class="line"></div><div class="line"></div><div class="line"> 有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。</div><div class="line"></div><div class="line">能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048*2048，或4096*4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU（见第12章『速度的曲调』，和第13章『高效绘图』，它更加详细地解释了软件绘制和硬件绘制）。</div><div class="line"></div><div class="line">CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入。让我们用实验来证明一下。</div><div class="line">#####小片裁剪</div><div class="line"> 这个示例中，我们将会从一个2048*2048分辨率的雪人图片入手。为了能够从CATiledLayer中获益，我们需要把这个图片裁切成许多小一些的图片。你可以通过代码来完成这件事情，但是如果你在运行时读入整个图片并裁切，那CATiledLayer这些所有的性能优点就损失殆尽了。理想情况下来说，最好能够逐个步骤来实现。</div><div class="line"></div><div class="line">清单6.11 演示了一个简单的Mac OS命令行程序，它用CATiledLayer将一个图片裁剪成小图并存储到不同的文件中。</div><div class="line"></div><div class="line">#####清单6.11 裁剪图片成小图的终端程序</div></pre></td></tr></table></figure>
</li>
</ul>
<p>#import <appkit appkit.h=""></appkit></p>
<pre><code>int main(int argc, const char * argv[])
{
    @autoreleasepool{
        ￼//handle incorrect arguments
        if (argc &lt; 2) {
            NSLog(@&quot;TileCutter arguments: inputfile&quot;);
            return 0;
        }

        //input file
        NSString *inputFile = [NSString stringWithCString:argv[1] encoding:NSUTF8StringEncoding];

        //tile size
        CGFloat tileSize = 256; //output path
        NSString *outputPath = [inputFile stringByDeletingPathExtension];

        //load image
        NSImage *image = [[NSImage alloc] initWithContentsOfFile:inputFile];
        NSSize size = [image size];
        NSArray *representations = [image representations];
        if ([representations count]){
            NSBitmapImageRep *representation = representations[0];
            size.width = [representation pixelsWide];
            size.height = [representation pixelsHigh];
        }
        NSRect rect = NSMakeRect(0.0, 0.0, size.width, size.height);
        CGImageRef imageRef = [image CGImageForProposedRect:&amp;rect context:NULL hints:nil];

        //calculate rows and columns
        NSInteger rows = ceil(size.height / tileSize);
        NSInteger cols = ceil(size.width / tileSize);

        //generate tiles
        for (int y = 0; y &lt; rows; ++y) {
            for (int x = 0; x &lt; cols; ++x) {
                //extract tile image
                CGRect tileRect = CGRectMake(x*tileSize, y*tileSize, tileSize, tileSize);
                CGImageRef tileImage = CGImageCreateWithImageInRect(imageRef, tileRect);

                //convert to jpeg data
                NSBitmapImageRep *imageRep = [[NSBitmapImageRep alloc] initWithCGImage:tileImage];
                NSData *data = [imageRep representationUsingType: NSJPEGFileType properties:nil];
                CGImageRelease(tileImage);

                //save file
                NSString *path = [outputPath stringByAppendingFormat: @&quot;_%02i_%02i.jpg&quot;, x, y];
                [data writeToFile:path atomically:NO];
            }
        }
    }
    return 0;
}
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">这个程序将2048*2048分辨率的雪人图案裁剪成了64个不同的256*256的小图。（256*256是CATiledLayer的默认小图大小，默认大小可以通过tileSize属性更改）。程序接受一个图片路径作为命令行的第一个参数。我们可以在编译的scheme将路径参数硬编码然后就可以在Xcode中运行了，但是以后作用在另一个图片上就不方便了。所以，我们编译了这个程序并把它保存到敏感的地方，然后从终端调用，如下面所示：</div><div class="line">`&gt; path/to/TileCutterApp path/to/Snowman.jpg`</div><div class="line"></div><div class="line"> The app is very basic, but could easily be extended to support additional arguments such as tile size, or to export images in formats other than JPEG. The result of running it is a sequence of 64 new images, named as follows:</div><div class="line"></div><div class="line">这个程序相当基础，但是能够轻易地扩展支持额外的参数比如小图大小，或者导出格式等等。运行结果是64个新图的序列，如下面命名：</div></pre></td></tr></table></figure>
<p>Snowman_00_00.jpg<br>Snowman_00_01.jpg<br>Snowman_00_02.jpg<br>…<br>Snowman_07_07.jpg<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> 既然我们有了裁切后的小图，我们就要让iOS程序用到他们。CATiledLayer很好地和UIScrollView集成在一起。除了设置图层和滑动视图边界以适配整个图片大小，我们真正要做的就是实现-drawLayer:inContext:方法，当需要载入新的小图时，CATiledLayer就会调用到这个方法。</div><div class="line"></div><div class="line">清单6.12演示了代码。图6.12是代码运行结果。</div><div class="line"></div><div class="line">#####清单6.12 一个简单的滚动CATiledLayer实现</div></pre></td></tr></table></figure></p>
<p>#import “ViewController.h”</p>
<p>#import <quartzcore quartzcore.h=""></quartzcore></p>
<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIScrollView *scrollView;

@end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    //add the tiled layer
    CATiledLayer *tileLayer = [CATiledLayer layer];￼
    tileLayer.frame = CGRectMake(0, 0, 2048, 2048);
    tileLayer.delegate = self; [self.scrollView.layer addSublayer:tileLayer];

    //configure the scroll view
    self.scrollView.contentSize = tileLayer.frame.size;

    //draw layer
    [tileLayer setNeedsDisplay];
}

- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx
{
    //determine tile coordinate
    CGRect bounds = CGContextGetClipBoundingBox(ctx);
    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);

    //load tile image
    NSString *imageName = [NSString stringWithFormat: @&quot;Snowman_%02i_%02i&quot;, x, y];
    NSString *imagePath = [[NSBundle mainBundle] pathForResource:imageName ofType:@&quot;jpg&quot;];
    UIImage *tileImage = [UIImage imageWithContentsOfFile:imagePath];

    //draw tile
    UIGraphicsPushContext(ctx);
    [tileImage drawInRect:bounds];
    UIGraphicsPopContext();
}
@end
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">![6.12.png](http://upload-images.jianshu.io/upload_images/1694376-c8f16b06249d1b70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">当你滑动这个图片，你会发现当CATiledLayer载入小图的时候，他们会淡入到界面中。这是CATiledLayer的默认行为。（你可能已经在iOS 6之前的苹果地图程序中见过这个效果）你可以用fadeDuration属性改变淡入时长或直接禁用掉。CATiledLayer（不同于大部分的UIKit和Core Animation方法）支持多线程绘制，-drawLayer:inContext:方法可以在多个线程中同时地并发调用，所以请小心谨慎地确保你在这个方法中实现的绘制代码是线程安全的。</div><div class="line">#####Retina小图</div><div class="line">你也许已经注意到了这些小图并不是以Retina的分辨率显示的。为了以屏幕的原生分辨率来渲染CATiledLayer</div><div class="line">，我们需要设置图层的contentsScale来匹配UIScreen的scale</div><div class="line">属性：</div><div class="line">`tileLayer.contentsScale = [UIScreen mainScreen].scale;`</div><div class="line"></div><div class="line">有趣的是，tileSize是以像素为单位，而不是点，所以增大了contentsScale就自动有了默认的小图尺寸（现在它是128*128的点而不是256*256）.所以，我们不需要手工更新小图的尺寸或是在Retina分辨率下指定一个不同的小图。我们需要做的是适应小图渲染代码以对应安排scale的变化，然而：</div></pre></td></tr></table></figure>
<p>//determine tile coordinate<br>CGRect bounds = CGContextGetClipBoundingBox(ctx);<br>CGFloat scale = [UIScreen mainScreen].scale;<br>NSInteger x = floor(bounds.origin.x / layer.tileSize.width <em> scale);<br>NSInteger y = floor(bounds.origin.y / layer.tileSize.height </em> scale);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">通过这个方法纠正scale也意味着我们的雪人图将以一半的大小渲染在Retina设备上（总尺寸是1024*1024，而不是2048*2048）。这个通常都不会影响到用CATiledLayer正常显示的图片类型（比如照片和地图，他们在设计上就是要支持放大缩小，能够在不同的缩放条件下显示），但是也需要在心里明白。</div><div class="line"></div><div class="line">-  ####**CAEmitterLayer**</div><div class="line"></div><div class="line"> 在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</div><div class="line"></div><div class="line">CAEmitterLayer看上去像是许多CAEmitterCell的容器，这些CAEmitierCell定义了一个例子效果。你将会为不同的例子效果定义一个或多个CAEmitterCell作为模版，同时CAEmitterLayer负责基于这些模版实例化一个粒子流。一个CAEmitterCell类似于一个CALayer：它有一个contents属性可以定义为一个CGImage，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在CAEmitterCell类的头文件中找到。</div><div class="line"></div><div class="line">我们来举个例子。我们将利用在一圆中发射不同速度和透明度的粒子创建一个火爆炸的效果。清单6.13包含了生成爆炸的代码。图6.13是运行结果</div><div class="line"></div><div class="line">#####清单6.13 用CAEmitterLayer创建爆炸效果</div></pre></td></tr></table></figure></p>
<p>#import “ViewController.h”</p>
<p>#import <quartzcore quartzcore.h=""></quartzcore></p>
<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView;

@end


@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    ￼
    //create particle emitter layer
    CAEmitterLayer *emitter = [CAEmitterLayer layer];
    emitter.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:emitter];

    //configure emitter
    emitter.renderMode = kCAEmitterLayerAdditive;
    emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0);

    //create a particle template
    CAEmitterCell *cell = [[CAEmitterCell alloc] init];
    cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage;
    cell.birthRate = 150;
    cell.lifetime = 5.0;
    cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor;
    cell.alphaSpeed = -0.4;
    cell.velocity = 50;
    cell.velocityRange = 50;
    cell.emissionRange = M_PI * 2.0;

    //add particle template to emitter
    emitter.emitterCells = @[cell];
}
@end
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"> CAEMitterCell的属性基本上可以分为三种：</div><div class="line"></div><div class="line">   - 这种粒子的某一属性的初始值。比如，color属性指定了一个可以混合图片内容颜色的混合色。在示例中，我们将它设置为桔色。</div><div class="line">   - 例子某一属性的变化范围。比如emissionRange属性的值是2π，这意味着例子可以从360度任意位置反射出来。如果指定一个小一些的值，就可以创造出一个圆锥形</div><div class="line"></div><div class="line">- 指定值在时间线上的变化。比如，在示例中，我们将alphaSpeed设置为-0.4，就是说例子的透明度每过一秒就是减少0.4，这样就有发射出去之后逐渐小时的效果。</div><div class="line"></div><div class="line"></div><div class="line"> CAEmitterLayer的属性它自己控制着整个例子系统的位置和形状。一些属性比如birthRate，lifetime和celocity，这些属性在CAEmitterCell中也有。这些属性会以相乘的方式作用在一起，这样你就可以用一个值来加速或者扩大整个例子系统。其他值得提到的属性有以下这些：</div><div class="line">    </div><div class="line">   -  renderMode，控制着在视觉上粒子图片是如何混合的。你可能已经注意到了示例中我们把它设置为kCAEmitterLayerAdditive，它实现了这样一个效果：合并例子重叠部分的亮度使得看上去更亮。如果我们把它设置为默认的kCAEmitterLayerUnordered，效果就没那么好看了（见图6.14）</div><div class="line"></div><div class="line">- preservesDepth，是否将3D例子系统平面化到一个图层（默认值）或者可以在3D空间中混合其他的图层</div><div class="line"></div><div class="line">![6.14.png](http://upload-images.jianshu.io/upload_images/1694376-b5d6b3f19d48ab17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line">-  ####**CAEAGLLayer**</div><div class="line"></div><div class="line"></div><div class="line"> 当iOS要处理高性能图形绘制，必要时就是OpenGL。应该说它应该是最后的杀手锏，至少对于非游戏的应用来说是的。因为相比Core Animation和UIkit框架，它不可思议地复杂。</div><div class="line"></div><div class="line">OpenGL提供了Core Animation的基础，它是底层的C接口，直接和iPhone，iPad的硬件通信，极少地抽象出来的方法。OpenGL没有对象或是图层的继承概念。它只是简单地处理三角形。OpenGL中所有东西都是3D空间中有颜色和纹理的三角形。用起来非常复杂和强大，但是用OpenGL绘制iOS用户界面就需要很多很多的工作了。</div><div class="line"></div><div class="line">为了能够以高性能使用Core Animation，你需要判断你需要绘制哪种内容（矢量图形，例子，文本，等等），但后选择合适的图层去呈现这些内容，Core Animation中只有一些类型的内容是被高度优化的；所以如果你想绘制的东西并不能找到标准的图层类，想要得到高性能就比较费事情了。</div><div class="line"></div><div class="line">因为OpenGL根本不会对你的内容进行假设，它能够绘制得相当快。利用OpenGL，你可以绘制任何你知道必要的集合信息和形状逻辑的内容。所以很多游戏都喜欢用OpenGL（这些情况下，Core Animation的限制就明显了：它优化过的内容类型并不一定能满足需求），但是这样依赖，方便的高度抽象接口就没了。</div><div class="line"></div><div class="line">在iOS 5中，苹果引入了一个新的框架叫做GLKit，它去掉了一些设置OpenGL的复杂性，提供了一个叫做CLKView的UIView的子类，帮你处理大部分的设置和绘制工作。前提是各种各样的OpenGL绘图缓冲的底层可配置项仍然需要你用CAEAGLLayer完成，它是CALayer的一个子类，用来显示任意的OpenGL图形。</div><div class="line"></div><div class="line">大部分情况下你都不需要手动设置CAEAGLLayer（假设用GLKView），过去的日子就不要再提了。特别的，我们将设置一个OpenGL ES 2.0的上下文，它是现代的iOS设备的标准做法。</div><div class="line"></div><div class="line">尽管不需要GLKit也可以做到这一切，但是GLKit囊括了很多额外的工作，比如设置顶点和片段着色器，这些都以类C语言叫做GLSL自包含在程序中，同时在运行时载入到图形硬件中。编写GLSL代码和设置EAGLayer没有什么关系，所以我们将用GLKBaseEffect类将着色逻辑抽象出来。其他的事情，我们还是会有以往的方式。</div><div class="line"></div><div class="line">在开始之前，你需要将GLKit和OpenGLES框架加入到你的项目中，然后就可以实现清单6.14中的代码，里面是设置一个GAEAGLLayer的最少工作，它使用了OpenGL ES 2.0 的绘图上下文，并渲染了一个有色三角（见图6.15）.</div><div class="line"></div><div class="line">#####清单6.14 用CAEAGLLayer绘制一个三角形</div></pre></td></tr></table></figure>
<p>#import “ViewController.h”</p>
<p>#import <quartzcore quartzcore.h=""></quartzcore></p>
<p>#import <glkit glkit.h=""></glkit></p>
<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *glView;
@property (nonatomic, strong) EAGLContext *glContext;
@property (nonatomic, strong) CAEAGLLayer *glLayer;
@property (nonatomic, assign) GLuint framebuffer;
@property (nonatomic, assign) GLuint colorRenderbuffer;
@property (nonatomic, assign) GLint framebufferWidth;
@property (nonatomic, assign) GLint framebufferHeight;
@property (nonatomic, strong) GLKBaseEffect *effect;
￼
@end

@implementation ViewController

- (void)setUpBuffers
{
    //set up frame buffer
    glGenFramebuffers(1, &amp;_framebuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);

    //set up color render buffer
    glGenRenderbuffers(1, &amp;_colorRenderbuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext renderbufferStorage:GL_RENDERBUFFER fromDrawable:self.glLayer];
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH, &amp;_framebufferWidth);
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT, &amp;_framebufferHeight);

    //check success
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        NSLog(@&quot;Failed to make complete framebuffer object: %i&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER));
    }
}

- (void)tearDownBuffers
{
    if (_framebuffer) {
        //delete framebuffer
        glDeleteFramebuffers(1, &amp;_framebuffer);
        _framebuffer = 0;
    }

    if (_colorRenderbuffer) {
        //delete color render buffer
        glDeleteRenderbuffers(1, &amp;_colorRenderbuffer);
        _colorRenderbuffer = 0;
    }
}

- (void)drawFrame {
    //bind framebuffer &amp; set viewport
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);
    glViewport(0, 0, _framebufferWidth, _framebufferHeight);

    //bind shader program
    [self.effect prepareToDraw];

    //clear the screen
    glClear(GL_COLOR_BUFFER_BIT); glClearColor(0.0, 0.0, 0.0, 1.0);

    //set up vertices
    GLfloat vertices[] = {
        -0.5f, -0.5f, -1.0f, 0.0f, 0.5f, -1.0f, 0.5f, -0.5f, -1.0f,
    };

    //set up colors
    GLfloat colors[] = {
        0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f,
    };

    //draw triangle
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribPosition, 3, GL_FLOAT, GL_FALSE, 0, vertices);
    glVertexAttribPointer(GLKVertexAttribColor,4, GL_FLOAT, GL_FALSE, 0, colors);
    glDrawArrays(GL_TRIANGLES, 0, 3);

    //present render buffer
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext presentRenderbuffer:GL_RENDERBUFFER];
}

- (void)viewDidLoad
{
    [super viewDidLoad];
    //set up context
    self.glContext = [[EAGLContext alloc] initWithAPI: kEAGLRenderingAPIOpenGLES2];
    [EAGLContext setCurrentContext:self.glContext];

    //set up layer
    self.glLayer = [CAEAGLLayer layer];
    self.glLayer.frame = self.glView.bounds;
    [self.glView.layer addSublayer:self.glLayer];
    self.glLayer.drawableProperties = @{kEAGLDrawablePropertyRetainedBacking:@NO, kEAGLDrawablePropertyColorFormat: kEAGLColorFormatRGBA8};

    //set up base effect
    self.effect = [[GLKBaseEffect alloc] init];

    //set up buffers
    [self setUpBuffers];

    //draw frame
    [self drawFrame];
}

- (void)viewDidUnload
{
    [self tearDownBuffers];
    [super viewDidUnload];
}

- (void)dealloc
{
    [self tearDownBuffers];
    [EAGLContext setCurrentContext:nil];
}
</code></pre><p>@end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">![6.15.png](http://upload-images.jianshu.io/upload_images/1694376-b294eff9d46ed561.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">在一个真正的OpenGL应用中，我们可能会用NSTimer或CADisplayLink周期性地每秒钟调用-drawRrame方法60次，同时会将几何图形生成和绘制分开以便不会每次都重新生成三角形的顶点（这样也可以让我们绘制其他的一些东西而不是一个三角形而已），不过上面这个例子已经足够演示了绘图原则了。</div><div class="line">-  ####**AVPlayerLayer**</div><div class="line"></div><div class="line"></div><div class="line"> 最后一个图层类型是AVPlayerLayer。尽管它不是Core Animation框架的一部分（AV前缀看上去像），AVPlayerLayer是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。</div><div class="line"></div><div class="line">AVPlayerLayer是用来在iOS上播放视频的。他是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。AVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。</div><div class="line"></div><div class="line">在我们开始之前，我们需要添加AVFoundation到我们的项目中。然后，清单6.15创建了一个简单的电影播放器，图6.16是代码运行结果。</div><div class="line"></div><div class="line">#####清单6.15 用AVPlayerLayer播放视频</div></pre></td></tr></table></figure></p>
<p>#import “ViewController.h”</p>
<p>#import <quartzcore quartzcore.h=""></quartzcore></p>
<p>#import <avfoundation avfoundation.h=""></avfoundation></p>
<pre><code>@interface ViewController ()

@property (nonatomic, weak) IBOutlet UIView *containerView; @end

@implementation ViewController

- (void)viewDidLoad
{
    [super viewDidLoad];
    //get video URL
    NSURL *URL = [[NSBundle mainBundle] URLForResource:@&quot;Ship&quot; withExtension:@&quot;mp4&quot;];

    //create player and player layer
    AVPlayer *player = [AVPlayer playerWithURL:URL];
    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];

    //set player layer frame and attach it to our view
    playerLayer.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:playerLayer];

    //play the video
    [player play];
}
@end
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">![6.16.png](http://upload-images.jianshu.io/upload_images/1694376-12991c0de2393529.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line"></div><div class="line"> 我们用代码创建了一个AVPlayerLayer，但是我们仍然把它添加到了一个容器视图中，而不是直接在controller中的主视图上添加。这样其实是为了可以使用自动布局限制使得图层在最中间；否则，一旦设备被旋转了我们就要手动重新放置位置，因为Core Animation并不支持自动大小和自动布局（见第三章『图层几何学』）。</div><div class="line"></div><div class="line">当然，因为AVPlayerLayer是CALayer的子类，它继承了父类的所有特性。我们并不会受限于要在一个矩形中播放视频；清单6.16演示了在3D，圆角，有色边框，蒙板，阴影等效果（见图6.17）.</div><div class="line">#####清单6.16 给视频增加变换，边框和圆角</div></pre></td></tr></table></figure>
<pre><code>- (void)viewDidLoad
{
    ...
    //set player layer frame and attach it to our view
    playerLayer.frame = self.containerView.bounds;
    [self.containerView.layer addSublayer:playerLayer];

    //transform layer
    CATransform3D transform = CATransform3DIdentity;
    transform.m34 = -1.0 / 500.0;
    transform = CATransform3DRotate(transform, M_PI_4, 1, 1, 0);
    playerLayer.transform = transform;
    ￼
    //add rounded corners and border
    playerLayer.masksToBounds = YES;
    playerLayer.cornerRadius = 20.0;
    playerLayer.borderColor = [UIColor redColor].CGColor;
    playerLayer.borderWidth = 5.0;

    //play the video
    [player play];
}
</code></pre><p>```</p>
<p>#####总结</p>
<p>这一章我们简要概述了一些专用图层以及用他们实现的一些效果，我们只是了解到这些图层的皮毛，像CATiledLayer和CAEMitterLayer这些类可以单独写一章的。但是，重点是记住CALayer是用处很大的，而且它并没有为所有可能的场景进行优化。为了获得Core Animation最好的性能，你需要为你的工作选对正确的工具，希望你能够挖掘这些不同的CALayer子类的功能。 这一章我们通过CAEmitterLayer和AVPlayerLayer类简单地接触到了一些动画，在第二章，我们将继续深入研究动画，就从隐式动画开始。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之转场之圆圈缩放动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之转场之圆圈缩放动画/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先看动画效果：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-c980b1f7307547e7.gif?imageMogr2/auto-orient/strip" alt="圆圈转场动画.gif"></p>
<p>间客的APP上之前是有这个动画的，拜读了大神的文章：<a href="http://www.kittenyang.com/pingtransition/" target="_blank" rel="noopener">iOS自定义转场详解03——实现通过圆圈放大缩小的转场动画</a>,博客里面很详细。</p>
<blockquote>
<p>因为要自定义转场，所以我们需要一个新的对象集成NSObject，并且遵守转场动画的协议,<code>UIViewControllerAnimatedTransitioning</code></p>
</blockquote>
<p>介绍个知识点：</p>
<p>1、CGRectInsetCGRect<br>    CGRectInset (<br>        CGRect rect,<br>        CGFloat dx,<br>        CGFloat dy);<br>该结构体的应用是以原rect为中心，再参考dx，dy，进行缩放或者放大。
　　</p>
<p>2、CGRectOffsetCGRect<br>   CGRectOffset(<br>      CGRect rect,<br>      CGFloat dx,<br>      CGFloat dy);　<br>相对于源矩形原点rect（左上角的点）沿x轴和y轴偏移, 再rect基础上沿x轴和y轴偏移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// This is used for percent driven interactive transitions, as well as for</div><div class="line">// container controllers that have companion animations that might need to</div><div class="line">// synchronize with the main animation.</div><div class="line">设置转场动画的时间。</div><div class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div><div class="line"></div><div class="line">// This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.</div><div class="line">转场的上下文</div><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div></pre></td></tr></table></figure>
<p>关于这个参数transitionContext， 该参数是一个实现了 UIViewControllerContextTransitioning可以让我们访问一些实现过渡所必须的对象。<br>    UIViewControllerContextTransitioning 协议中有一些方法：</p>
<ul>
<li>(UIView *)containerView;<br>  //转场动画发生的容器</li>
<li>(UIViewController <em>)viewControllerForKey:(NSString </em>)key;<br>  // 我们可以通过它拿到过渡的两个 ViewController。</li>
</ul>
<p>大致思路是这样从，我们画两个内塞尔曲线的圆，第一个小圆的frame和右上角圆形按钮的大小一样，第二个大圆则是覆盖了整个屏幕。然后，去设置view.layer.mask属性，让这个mask从小圆动画到大圆。</p>
<p>以push 动画为例：pop动画不过是起终点的mask路径相反罢了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123;</div><div class="line"></div><div class="line">   </div><div class="line">    ViewController * fromVC = (ViewController *)[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">    DetailViewController *toVC = (DetailViewController *)[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">    UIView *contView = [transitionContext containerView];</div><div class="line"></div><div class="line">    UIButton *button = fromVC.button;</div><div class="line">    </div><div class="line">    </div><div class="line">    UIBezierPath *maskStartBP =  [UIBezierPath bezierPathWithOvalInRect:button.frame];    </div><div class="line">    [contView addSubview:fromVC.view];</div><div class="line">    [contView addSubview:toVC.view];</div><div class="line"></div><div class="line">    </div><div class="line">    </div><div class="line">    //创建两个圆形的 UIBezierPath 实例；一个是 button 的 size ，另外一个则拥有足够覆盖屏幕的半径。最终的动画则是在这两个贝塞尔路径之间进行的</div><div class="line">    </div><div class="line">    CGPoint finalPoint;</div><div class="line">    //判断触发点在那个象限</div><div class="line">    if(button.frame.origin.x &gt; (toVC.view.bounds.size.width / 2))&#123;</div><div class="line">        if (button.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">            //第一象限</div><div class="line">            finalPoint = CGPointMake(button.center.x - 0, button.center.y - CGRectGetMaxY(toVC.view.bounds)+30);</div><div class="line">        &#125;else&#123;</div><div class="line">            //第四象限</div><div class="line">            finalPoint = CGPointMake(button.center.x - 0, button.center.y - 0);</div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;</div><div class="line">        if (button.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">            //第二象限</div><div class="line">            finalPoint = CGPointMake(button.center.x - CGRectGetMaxX(toVC.view.bounds), button.center.y - CGRectGetMaxY(toVC.view.bounds)+30);</div><div class="line">        &#125;else&#123;</div><div class="line">            //第三象限</div><div class="line">            finalPoint = CGPointMake(button.center.x - CGRectGetMaxX(toVC.view.bounds), button.center.y - 0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    CGFloat radius = sqrt((finalPoint.x * finalPoint.x) + (finalPoint.y * finalPoint.y));</div><div class="line">    UIBezierPath *maskFinalBP = [UIBezierPath bezierPathWithOvalInRect:CGRectInset(button.frame, -radius, -radius)];</div><div class="line">    </div><div class="line">    </div><div class="line">    //创建一个 CAShapeLayer 来负责展示圆形遮盖</div><div class="line">    CAShapeLayer *maskLayer = [CAShapeLayer layer];</div><div class="line">    maskLayer.path = maskFinalBP.CGPath; //将它的 path 指定为最终的 path 来避免在动画完成后会回弹</div><div class="line">    toVC.view.layer.mask = maskLayer;</div><div class="line">    maskLayer.backgroundColor =[UIColor redColor].CGColor;</div><div class="line">    </div><div class="line">    CABasicAnimation *maskLayerAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">    maskLayerAnimation.fromValue = (__bridge id)(maskStartBP.CGPath);</div><div class="line">    maskLayerAnimation.toValue = (__bridge id)((maskFinalBP.CGPath));</div><div class="line">    maskLayerAnimation.duration = [self transitionDuration:transitionContext];</div><div class="line">    maskLayerAnimation.timingFunction = [CAMediaTimingFunction  functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    maskLayerAnimation.delegate = self;</div><div class="line">    </div><div class="line">    [maskLayer addAnimation:maskLayerAnimation forKey:@&quot;path&quot;];</div></pre></td></tr></table></figure></p>
<p> 结束动画后设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#pragma mark - CABasicAnimation的Delegate</div><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</div><div class="line"></div><div class="line">    //告诉 iOS 这个 transition 完成</div><div class="line">    [self.transitionContext completeTransition:![self. transitionContext transitionWasCancelled]];</div><div class="line">    //清除 fromVC 的 mask</div><div class="line">    [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey].view.layer.mask = nil;</div><div class="line">    [self.transitionContext viewControllerForKey:UITransitionContextToViewControllerKey].view.layer.mask = nil;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>自定义完push 动画后我们需要进行设置，因为所有的子控制器由UINavgationController进行管理，所有我们需要在ViewCotroller中实现代理;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()&lt;UINavigationControllerDelegate&gt;</div></pre></td></tr></table></figure>
<p>最好在<code>viewWillAppear</code>中设置代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(void)viewWillAppear:(BOOL)animated&#123;</div><div class="line">    self.navigationController.delegate = self;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#pragma mark - UINavigationControllerDelegate</div><div class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC&#123;</div><div class="line">    if (operation == UINavigationControllerOperationPush) &#123;</div><div class="line">        </div><div class="line">        PingTransition *ping = [PingTransition new];</div><div class="line">        return ping;</div><div class="line">    &#125;else&#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本文demo地址：<a href="https://github.com/liuxinixn/CircleZoomView/tree/master" target="_blank" rel="noopener">圆圈转场动画</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation寄宿图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation寄宿图/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>###寄宿图</p>
</blockquote>
<p>我们在第一章『图层树』中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。</p>
<ul>
<li>####<strong>contents属性</strong></li>
</ul>
<p>CALayer 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。<br>contents这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。<br>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的contents，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。<br>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：<br><code>layer.contents = (__bridge id)image.CGImage;</code><br> 如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！</p>
<p>让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的contents属性设置成图片。</p>
<p>#####清单2.1 更新后的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad]; //load an image</div><div class="line">        UIImage *image = [UIImage imageNamed:@&quot;Snowman&quot;];</div><div class="line">        //add it directly to our view&apos;s layer</div><div class="line">        self.layerView.layer.contents = (__bridge id)image.CGImage;</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-693d5c2da9328e26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图.png"></p>
<pre><code>在UIView的宿主图层中显示一张图片
</code></pre><p>我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。</p>
<ul>
<li>####<strong>contentGravity属性</strong></li>
</ul>
<p>你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把contentMode属性设置成更合适的值，像这样：<br><code>view.contentMode = UIViewContentModeScaleAspectFit;</code></p>
<p>这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。</p>
<p>CALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。contentsGravity可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<p>和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</p>
<p><code>self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6c0ffcad9d3f428c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<ul>
<li>####<strong>contentsScale属性</strong></li>
</ul>
<p>contentsScale属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p>contentsScale的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为contents由于设置了contentsGravity<br>属性，所以它已经被拉伸以适应图层的边界。</p>
<p>如果你只是单纯地想放大图层的contents图片，你可以通过使用图层的transform和affineTransform属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是contengsScale的目的所在.</p>
<p>contentsScale属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设contentsGravity<br>属性）。UIView有一个类似功能但是非常少用到contentScaleFactor<br>属性。</p>
<p>如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。</p>
<p>这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把contentsGravity设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化（如图2.3）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-e88c0aaf84f3b8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.3.png"></p>
<pre><code>用错误的contentsScale属性显示Retina图片
</code></pre><p>如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置contentsScale来修复这个问题（如2.2清单），图2.4是结果</p>
<p>#####清单2.4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad]; //load an image</div><div class="line">        UIImage *image = [UIImage imageNamed:@&quot;Snowman.png&quot;]; //add it directly to our view&apos;s layer</div><div class="line">        self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image</div><div class="line">        self.layerView.layer.contentsGravity = kCAGravityCenter;</div><div class="line">        </div><div class="line">        //set the contentsScale to match image</div><div class="line">        self.layerView.layer.contentsScale = image.scale;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d6cc02bde6e0ac3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.4.正确的contentsScale之后"><br>当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的contentsScale属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：<br><code>layer.contentsScale = [UIScreen mainScreen].scale;</code></p>
<ul>
<li>####<strong>maskToBounds属性</strong></li>
</ul>
<p>现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。</p>
<p>UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES，雪人就在边界里啦～（如图2.5）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-f3fe22588c2a354e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.5.png"></p>
<ul>
<li>####<strong>contentsRect属性</strong></li>
</ul>
<p>CALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要contentsGravity<br>灵活多了和bounds，frame不同，contentsRect不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<p>默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d1c60386893f5477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.6.png"></p>
<p>事实上给contentsRect设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p>contentsRect在app中最有趣的地方在于一个叫做image sprites（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。</p>
<p>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等</p>
<p>2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用contentsRect</p>
<p>首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-064197033685be51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.7.png"></p>
<p> 接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的contents，然后设置每个图层的contentsRect来去掉我们不想显示的部分。</p>
<p>我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果</p>
<p>#####清单2.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *coneView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *shipView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *iglooView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *anchorView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect ￼toLayer:(CALayer *)layer //set image</div><div class="line">&#123;</div><div class="line">    layer.contents = (__bridge id)image.CGImage;</div><div class="line">    </div><div class="line">    //scale contents to fit</div><div class="line">    layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">    </div><div class="line">    //set contentsRect</div><div class="line">    layer.contentsRect = rect;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad]; //load sprite sheet</div><div class="line">    UIImage *image = [UIImage imageNamed:@&quot;Sprites.png&quot;];</div><div class="line">    //set igloo sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];</div><div class="line">    //set cone sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];</div><div class="line">    //set anchor sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];</div><div class="line">    //set spaceship sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-df8cb36dcbaefaa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.8.png"></p>
<p>拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。<br>Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置contentsRect，这样开发者就不用手动写代码来摆放位置了。<br>这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（<a href="https://github.com/nicklockwood/LayerSprites" target="_blank" rel="noopener">https://github.com/nicklockwood/LayerSprites</a>)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。</p>
<ul>
<li>####<strong>contentsCenter属性</strong></li>
</ul>
<p> 本章我们介绍的最后一个和内容有关的属性是contentsCenter，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。contentsCenter其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<p>默认情况下，contentsCenter是{0, 0, 1, 1}，这意味着如果大小（由conttensGravity决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了contentsCenter设置为{0.25, 0.25, 0.5, 0.5}的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-ba74d68cdfe19927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.9.png"><br>这意味着我们可以随意重设尺寸，边框仍然会是连续的。他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d062cb97b49f705c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.10.png"></p>
<p> 清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11</p>
<p>####清单2.4</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-ba4b083cc0841e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.11.png"></p>
<ul>
<li>####<strong>Custome Drawing属性</strong></li>
</ul>
<p> 给contents赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现-drawRect:方法来自定义绘制。</p>
<p>-drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值。</p>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。</p>
<p>当视图在屏幕上出现的时候 -drawRect:方法就会被自动调用。-drawRect:方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了-setNeedsDisplay方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性）。虽然-drawRect:方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>CALayer有一个可选的delegate属性，实现了CALayerDelegate协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（delegate属性被声明为id类型，所有的代理方法都是可选的）。</p>
<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:<br><code>(void)displayLayer:(CALayerCALayer *)layer;</code></p>
<p>趁着这个机会，如果代理想直接设置contents属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现-displayLayer:方法，CALayer就会转而尝试调用下面这个方法：<br><code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</code></p>
<p> 在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>
<p>让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是他的结果</p>
<p>#####清单2.5实现CALayerDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        ￼</div><div class="line">        //create sublayer</div><div class="line">        CALayer *blueLayer = [CALayer layer];</div><div class="line">        blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">        blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">        </div><div class="line">        //set controller as layer delegate</div><div class="line">        blueLayer.delegate = self;</div><div class="line">        </div><div class="line">        //ensure that layer backing image uses correct scale</div><div class="line">        blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view</div><div class="line">        [self.layerView.layer addSublayer:blueLayer];</div><div class="line">        </div><div class="line">        //force layer to redraw</div><div class="line">        [blueLayer display];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</div><div class="line">    &#123;</div><div class="line">        //draw a thick red circle</div><div class="line">        CGContextSetLineWidth(ctx, 10.0f);</div><div class="line">        CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);</div><div class="line">        CGContextStrokeEllipseInRect(ctx, layer.bounds);</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0d39dd147e3b14af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.12.png"></p>
<p> 注意一下一些有趣的事情：</p>
<ul>
<li>我们在blueLayer上显式地调用了-display。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>尽管我们没有用masksToBounds属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<p>现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个-displayLayer:的实现，那所有的问题就都没了。</p>
<p>当使用寄宿了视图的图层的时候，你也不必实现-displayLayer:和-drawLayer:inContext:方法来绘制你的寄宿图。通常做法是实现UIView的-drawRect:方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用-display方法。</p>
<p>####总结<br> 本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。</p>
<p>在第三章，”图层几何学”中，我们将会探讨一下图层的几何，观察他们是如何放置和改变相互的尺寸的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之缓冲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之缓冲/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>生活和艺术一样，最美的永远是曲线。 – 爱德华布尔沃 - 利顿</p>
</blockquote>
<p>在第九章“图层时间”中，我们讨论了动画时间和CAMediaTiming<br>协议。现在我们来看一下另一个和时间相关的机制–所谓的缓冲。Core Animation使用缓冲来使动画移动更平滑更自然，而不是看起来的那种机械和人工，在这一章我们将要研究如何对你的动画控制和自定义缓冲曲线。</p>
<p>#####动画速度<br>动画实际上就是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。速率由以下公式计算而来：</p>
<p><code>velocity = change / time</code></p>
<p>这里的变化可以指的是一个物体移动的距离，时间指动画持续的时长，用这样的一个移动可以更加形象的描述（比如position<br>和bounds属性的动画），但实际上它应用于任意可以做动画的属性（比如color和opacity）。</p>
<p>上面的等式假设了速度在整个动画过程中都是恒定不变的（就如同第八章“显式动画”的情况），对于这种恒定速度的动画我们称之为“线性步调”，而且从技术的角度而言这也是实现动画最简单的方式，但也是完全不真实的一种效果。</p>
<p>考虑一个场景，一辆车行驶在一定距离内，它并不会一开始就以60mph的速度行驶，然后到达终点后突然变成0mph。一是因为需要无限大的加速度（即使是最好的车也不会在0秒内从0跑到60），另外不然的话会干死所有乘客。在现实中，它会慢慢地加速到全速，然后当它接近终点的时候，它会慢慢地减速，直到最后停下来。</p>
<p>那么对于一个掉落到地上的物体又会怎样呢？它会首先停在空中，然后一直加速到落到地面，然后突然停止（然后由于积累的动能转换伴随着一声巨响，砰！）。</p>
<p>现实生活中的任何一个物体都会在运动中加速或者减速。那么我们如何在动画中实现这种加速度呢？一种方法是使用物理引擎来对运动物体的摩擦和动量来建模，然而这会使得计算过于复杂。我们称这种类型的方程为缓冲函数，幸运的是，Core Animation内嵌了一系列标准函数提供给我们使用。</p>
<p>#####CAMediaTimingFunction<br> 那么该如何使用缓冲方程式呢？首先需要设置CAAnimation的timingFunction属性，是CAMediaTimingFunction类的一个对象。如果想改变隐式动画的计时函数，同样也可以使用CATransaction的+setAnimationTimingFunction:方法。</p>
<p>这里有一些方式来创建CAMediaTimingFunction，最简单的方式是调用+timingFunctionWithName:的构造方法。这里传入如下几个常量之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kCAMediaTimingFunctionLinear </div><div class="line">kCAMediaTimingFunctionEaseIn </div><div class="line">kCAMediaTimingFunctionEaseOut </div><div class="line">kCAMediaTimingFunctionEaseInEaseOut</div><div class="line">kCAMediaTimingFunctionDefault</div></pre></td></tr></table></figure></p>
<p>kCAMediaTimingFunctionLinear选项创建了一个线性的计时函数，同样也是CAAnimation的timingFunction属性为空时候的默认函数。线性步调对于那些立即加速并且保持匀速到达终点的场景会有意义（例如射出枪膛的子弹），但是默认来说它看起来很奇怪，因为对大多数的动画来说确实很少用到。</p>
<p>kCAMediaTimingFunctionEaseIn常量创建了一个慢慢加速然后突然停止的方法。对于之前提到的自由落体的例子来说很适合，或者比如对准一个目标的导弹的发射。</p>
<p>kCAMediaTimingFunctionEaseOut则恰恰相反，它以一个全速开始，然后慢慢减速停止。它有一个削弱的效果，应用的场景比如一扇门慢慢地关上，而不是砰地一声。</p>
<p>kCAMediaTimingFunctionEaseInEaseOut创建了一个慢慢加速然后再慢慢减速的过程。这是现实世界大多数物体移动的方式，也是大多数动画来说最好的选择。如果只可以用一种缓冲函数的话，那就必须是它了。那么你会疑惑为什么这不是默认的选择，实际上当使用UIView的动画方法时，他的确是默认的，但当创建CAAnimation<br>的时候，就需要手动设置它了。</p>
<p>最后还有一个kCAMediaTimingFunctionDefault，它和kCAMediaTimingFunctionEaseInEaseOut很类似，但是加速和减速的过程都稍微有些慢。它kCAMediaTimingFunctionEaseInEaseOut<br>的区别很难察觉，可能是苹果觉得它对于隐式动画来说更适合（然后对UIKit就改变了想法，而是使用kCAMediaTimingFunctionEaseInEaseOut作为默认效果），虽然它的名字说是默认的，但还是要记住当创建显式的CAAnimation<br>它并不是默认选项（换句话说，默认的图层行为动画用kCAMediaTimingFunctionDefault作为它们的计时方法）。</p>
<p>你可以使用一个简单的测试工程来实验一下（清单10.1），在运行之前改变缓冲函数的代码，然后点击任何地方来观察图层是如何通过指定的缓冲移动的。</p>
<p>#####清单10.1 缓冲函数的简单测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) CALayer *colorLayer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a red layer</div><div class="line">    self.colorLayer = [CALayer layer];</div><div class="line">    self.colorLayer.frame = CGRectMake(0, 0, 100, 100);</div><div class="line">    self.colorLayer.position = CGPointMake(self.view.bounds.size.width/2.0, self.view.bounds.size.height/2.0);</div><div class="line">    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;</div><div class="line">    [self.view.layer addSublayer:self.colorLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //configure the transaction</div><div class="line">    [CATransaction begin];</div><div class="line">    [CATransaction setAnimationDuration:1.0];</div><div class="line">    [CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];</div><div class="line">    //set the position</div><div class="line">    self.colorLayer.position = [[touches anyObject] locationInView:self.view];</div><div class="line">    //commit transaction</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>#####UIView的动画缓冲<br>UIKit的动画也同样支持这些缓冲方法的使用，尽管语法和常量有些不同，为了改变UIView动画的缓冲选项，给options参数添加如下常量之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIViewAnimationOptionCurveEaseInOut </div><div class="line">UIViewAnimationOptionCurveEaseIn </div><div class="line">UIViewAnimationOptionCurveEaseOut </div><div class="line">UIViewAnimationOptionCurveLinear</div></pre></td></tr></table></figure></p>
<p> 它们和CAMediaTimingFunction紧密关联，UIViewAnimationOptionCurveEaseInOut是默认值（这里没有kCAMediaTimingFunctionDefault相对应的值了）。</p>
<p>具体使用方法见清单10.2（注意到这里不再使用UIView额外添加的图层，因为UIKit的动画并不支持这类图层）。</p>
<p>#####清单10.2 使用UIKit动画的缓冲测试工程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) UIView *colorView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a red layer</div><div class="line">    self.colorView = [[UIView alloc] init];</div><div class="line">    self.colorView.bounds = CGRectMake(0, 0, 100, 100);</div><div class="line">    self.colorView.center = CGPointMake(self.view.bounds.size.width / 2, self.view.bounds.size.height / 2);</div><div class="line">    self.colorView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:self.colorView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //perform the animation</div><div class="line">    [UIView animateWithDuration:1.0 delay:0.0</div><div class="line">                        options:UIViewAnimationOptionCurveEaseOut</div><div class="line">                     animations:^&#123;</div><div class="line">                         //set the position</div><div class="line">                         self.colorView.center = [[touches anyObject] locationInView:self.view];</div><div class="line">                     &#125;</div><div class="line">                     completion:NULL];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>#####缓冲和关键帧动画<br>或许你会回想起第八章里面颜色切换的关键帧动画由于线性变换的原因（见清单8.5）看起来有些奇怪，使得颜色变换非常不自然。为了纠正这点，我们来用更加合适的缓冲方法，例如kCAMediaTimingFunctionEaseIn，给图层的颜色变化添加一点脉冲效果，让它更像现实中的一个彩色灯泡。</p>
<p>我们不想给整个动画过程应用这个效果，我们希望对每个动画的过程重复这样的缓冲，于是每次颜色的变换都会有脉冲效果。</p>
<p>CAKeyframeAnimation有一个NSArray类型的timingFunctions<br>属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于keyframes数组的元素个数减一，因为它是描述每一帧之间动画速度的函数。</p>
<p>在这个例子中，我们自始至终想使用同一个缓冲函数，但我们同样需要一个函数的数组来告诉动画不停地重复每个步骤，而不是在整个动画序列只做一次缓冲，我们简单地使用包含多个相同函数拷贝的数组就可以了（见清单10.3）。</p>
<p>运行更新后的代码，你会发现动画看起来更加自然了。</p>
<p>#####清单10.3 对CAKeyframeAnimation使用CAMediaTimingFunction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    @property (nonatomic, weak) IBOutlet CALayer *colorLayer;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create sublayer</div><div class="line">        self.colorLayer = [CALayer layer];</div><div class="line">        self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">        self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">        //add it to our view</div><div class="line">        [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (IBAction)changeColor</div><div class="line">    &#123;</div><div class="line">        //create a keyframe animation</div><div class="line">        CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">        animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">        animation.duration = 2.0;</div><div class="line">        animation.values = @[</div><div class="line">                             (__bridge id)[UIColor blueColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor redColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor greenColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor blueColor].CGColor ];</div><div class="line">        //add timing function</div><div class="line">        CAMediaTimingFunction *fn = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn];</div><div class="line">        animation.timingFunctions = @[fn, fn, fn];</div><div class="line">        //apply animation to layer</div><div class="line">        [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>#####自定义缓冲函数<br> 在第八章中，我们给时钟项目添加了动画。看起来很赞，但是如果有合适的缓冲函数就更好了。在显示世界中，钟表指针转动的时候，通常起步很慢，然后迅速啪地一声，最后缓冲到终点。但是标准的缓冲函数在这里每一个适合它，那该如何创建一个新的呢？</p>
<p>除了+functionWithName:之外，CAMediaTimingFunction同样有另一个构造函数，一个有四个浮点参数的+functionWithControlPoints::::（注意这里奇怪的语法，并没有包含具体每个参数的名称，这在objective-C中是合法的，但是却违反了苹果对方法命名的指导方针，而且看起来是一个奇怪的设计）。</p>
<p>使用这个方法，我们可以创建一个自定义的缓冲函数，来匹配我们的时钟动画，为了理解如何使用这个方法，我们要了解一些CAMediaTimingFunction是如何工作的。</p>
<p>#####三次贝塞尔曲线<br>CAMediaTimingFunction函数的主要原则在于它把输入的时间转换成起点和终点之间成比例的改变。我们可以用一个简单的图标来解释，横轴代表时间，纵轴代表改变的量，于是线性的缓冲就是一条从起点开始的简单的斜线（图10.1）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-dcd616ebc1d7d817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.1.png"></p>
<p>这条曲线的斜率代表了速度，斜率的改变代表了加速度，原则上来说，任何加速的曲线都可以用这种图像来表示，但是CAMediaTimingFunction使用了一个叫做三次贝塞尔曲线的函数，它只可以产出指定缓冲函数的子集（我们之前在第八章中创建CAKeyframeAnimation路径的时候提到过三次贝塞尔曲线）。</p>
<p>你或许会回想起，一个三次贝塞尔曲线通过四个点来定义，第一个和最后一个点代表了曲线的起点和终点，剩下中间两个点叫做控制点，因为它们控制了曲线的形状，贝塞尔曲线的控制点其实是位于曲线之外的点，也就是说曲线并不一定要穿过它们。你可以把它们想象成吸引经过它们曲线的磁铁。</p>
<p>图10.2展示了一个三次贝塞尔缓冲函数的例子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-b85f8cfe5566baaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.2.png"></p>
<p> 实际上它是一个很奇怪的函数，先加速，然后减速，最后快到达终点的时候又加速，那么标准的缓冲函数又该如何用图像来表示呢？</p>
<p>CAMediaTimingFunction有一个叫做-getControlPointAtIndex:values:的方法，可以用来检索曲线的点，这个方法的设计的确有点奇怪（或许也就只有苹果能回答为什么不简单返回一个CGPoint），但是使用它我们可以找到标准缓冲函数的点，然后用UIBezierPath和CAShapeLayer来把它画出来。</p>
<p>曲线的起始和终点始终是{0, 0}和{1, 1}，于是我们只需要检索曲线的第二个和第三个点（控制点）。具体代码见清单10.4。所有的标准缓冲函数的图像见图10.3。</p>
<p>#####清单10.4 使用UIBezierPath绘制CAMediaTimingFunction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create timing function</div><div class="line">        CAMediaTimingFunction *function = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut];</div><div class="line">        //get control points</div><div class="line">        CGPoint controlPoint1, controlPoint2;</div><div class="line">        [function getControlPointAtIndex:1 values:(float *)&amp;controlPoint1];</div><div class="line">        [function getControlPointAtIndex:2 values:(float *)&amp;controlPoint2];</div><div class="line">        //create curve</div><div class="line">        UIBezierPath *path = [[UIBezierPath alloc] init];</div><div class="line">        [path moveToPoint:CGPointZero];</div><div class="line">        [path addCurveToPoint:CGPointMake(1, 1)</div><div class="line">                controlPoint1:controlPoint1 controlPoint2:controlPoint2];</div><div class="line">        //scale the path up to a reasonable size for display</div><div class="line">        [path applyTransform:CGAffineTransformMakeScale(200, 200)];</div><div class="line">        //create shape layer</div><div class="line">        CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">        shapeLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">        shapeLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">        shapeLayer.lineWidth = 4.0f;</div><div class="line">        shapeLayer.path = path.CGPath;</div><div class="line">        [self.layerView.layer addSublayer:shapeLayer];</div><div class="line">        //flip geometry so that 0,0 is in the bottom-left</div><div class="line">        self.layerView.layer.geometryFlipped = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-54afa74cbf2aa63d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.3.png"></p>
<p>那么对于我们自定义时钟指针的缓冲函数来说，我们需要初始微弱，然后迅速上升，最后缓冲到终点的曲线，通过一些实验之后，最终结果如下：<br><code>[CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];</code></p>
<p>如果把它转换成缓冲函数的图像，最后如图10.4所示，如果把它添加到时钟的程序，就形成了之前一直期待的非常赞的效果（见代清单10.5）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c0827049652cabd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.4.png"></p>
<p>###清单10.5 添加了自定义缓冲函数的时钟程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)setAngle:(CGFloat)angle forHand:(UIView *)handView ￼animated:(BOOL)animated</div><div class="line">  &#123;</div><div class="line">      //generate transform</div><div class="line">      CATransform3D transform = CATransform3DMakeRotation(angle, 0, 0, 1);</div><div class="line">      if (animated) &#123;</div><div class="line">          //create transform animation</div><div class="line">          CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">          animation.keyPath = @&quot;transform&quot;;</div><div class="line">          animation.fromValue = [handView.layer.presentationLayer valueForKey:@&quot;transform&quot;];</div><div class="line">          animation.toValue = [NSValue valueWithCATransform3D:transform];</div><div class="line">          animation.duration = 0.5;</div><div class="line">          animation.delegate = self;</div><div class="line">          animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];</div><div class="line">          //apply animation</div><div class="line">          handView.layer.transform = transform;</div><div class="line">          [handView.layer addAnimation:animation forKey:nil];</div><div class="line">      &#125; else &#123;</div><div class="line">          //set transform directly</div><div class="line">          handView.layer.transform = transform;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>#####更加复杂的动画曲线<br>考虑一个橡胶球掉落到坚硬的地面的场景，当开始下落的时候，它会持续加速知道落到地面，然后经过几次反弹，最后停下来。如果用一张图来说明，它会如图10.5所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-272872ff5eb96c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.5.png"></p>
<p>这种效果没法用一个简单的三次贝塞尔曲线表示，于是不能用CAMediaTimingFunction来完成。但如果想要实现这样的效果，可以用如下几种方法：</p>
<ul>
<li>用CAKeyframeAnimation创建一个动画，然后分割成几个步骤，每个小步骤使用自己的计时函数（具体下节介绍）。</li>
<li>使用定时器逐帧更新实现动画（见第11章，“基于定时器的动画”）。<br>#####基于关键帧的缓冲<br>为了使用关键帧实现反弹动画，我们需要在缓冲曲线中对每一个显著的点创建一个关键帧（在这个情况下，关键点也就是每次反弹的峰值），然后应用缓冲函数把每段曲线连接起来。同时，我们也需要通过keyTimes<br>来指定每个关键帧的时间偏移，由于每次反弹的时间都会减少，于是关键帧并不会均匀分布。<br>清单10.6展示了实现反弹球动画的代码（见图10.6）<br>#####清单10.6 使用关键帧实现反弹球的动画<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add ball image view</div><div class="line">    UIImage *ballImage = [UIImage imageNamed:@&quot;Ball.png&quot;];</div><div class="line">    self.ballView = [[UIImageView alloc] initWithImage:ballImage];</div><div class="line">    [self.containerView addSubview:self.ballView];</div><div class="line">    //animate</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //replay animation on tap</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = @[</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 32)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 140)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 220)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 250)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)]</div><div class="line">                         ];</div><div class="line">    </div><div class="line">    animation.timingFunctions = @[</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn]</div><div class="line">                                  ];</div><div class="line">    </div><div class="line">    animation.keyTimes = @[@0.0, @0.3, @0.5, @0.7, @0.8, @0.9, @0.95, @1.0];</div><div class="line">    //apply animation</div><div class="line">    self.ballView.layer.position = CGPointMake(150, 268);</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-256c3ef34723c976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.6.png"><br>这种方式还算不错，但是实现起来略显笨重（因为要不停地尝试计算各种关键帧和时间偏移）并且和动画强绑定了（因为如果要改变动画的一个属性，那就意味着要重新计算所有的关键帧）。那该如何写一个方法，用缓冲函数来把任何简单的属性动画转换成关键帧动画呢，下面我们来实现它</p>
<p>#####流程自动化<br>在清单10.6中，我们把动画分割成相当大的几块，然后用Core Animation的缓冲进入和缓冲退出函数来大约形成我们想要的曲线。但如果我们把动画分割成更小的几部分，那么我们就可以用直线来拼接这些曲线（也就是线性缓冲）。为了实现自动化，我们需要知道如何做如下两件事情：</p>
<ul>
<li>自动把任意属性动画分割成多个关键帧</li>
<li>用一个数学函数表示弹性动画，使得可以对帧做便宜</li>
</ul>
<p>为了解决第一个问题，我们需要复制Core Animation的插值机制。这是一个传入起点和终点，然后在这两个点之间指定时间点产出一个新点的机制。对于简单的浮点起始值，公式如下（假设时间从0到1）：<br><code>value = (endValue – startValue) × time + startValue;</code></p>
<p> 那么如果要插入一个类似于CGPoint，CGColorRef或者CATransform3D这种更加复杂类型的值，我们可以简单地对每个独立的元素应用这个方法（也就CGPoint中的x和y值，CGColorRef中的红，蓝，绿，透明值，或者是CATransform3D中独立矩阵的坐标）。我们同样需要一些逻辑在插值之前对对象拆解值，然后在插值之后在重新封装成对象，也就是说需要实时地检查类型。</p>
<p>一旦我们可以用代码获取属性动画的起始值之间的任意插值，我们就可以把动画分割成许多独立的关键帧，然后产出一个线性的关键帧动画。清单10.7展示了相关代码。</p>
<p>注意到我们用了60 x 动画时间（秒做单位）作为关键帧的个数，这时因为Core Animation按照每秒60帧去渲染屏幕更新，所以如果我们每秒生成60个关键帧，就可以保证动画足够的平滑（尽管实际上很可能用更少的帧率就可以达到很好的效果）。</p>
<p>我们在示例中仅仅引入了对CGPoint类型的插值代码。但是，从代码中很清楚能看出如何扩展成支持别的类型。作为不能识别类型的备选方案，我们仅仅在前一半返回了fromValue，在后一半返回了toValue。</p>
<p>清单10.7 使用插入的值创建一个关键帧动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">float interpolate(float from, float to, float time)</div><div class="line">&#123;</div><div class="line">    return (to - from) * time + from;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)interpolateFromValue:(id)fromValue toValue:(id)toValue time:(float)time</div><div class="line">&#123;</div><div class="line">    if ([fromValue isKindOfClass:[NSValue class]]) &#123;</div><div class="line">        //get type</div><div class="line">        const char *type = [fromValue objCType];</div><div class="line">        if (strcmp(type, @encode(CGPoint)) == 0) &#123;</div><div class="line">            CGPoint from = [fromValue CGPointValue];</div><div class="line">            CGPoint to = [toValue CGPointValue];</div><div class="line">            CGPoint result = CGPointMake(interpolate(from.x, to.x, time), interpolate(from.y, to.y, time));</div><div class="line">            return [NSValue valueWithCGPoint:result];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //provide safe default implementation</div><div class="line">    return (time &lt; 0.5)? fromValue: toValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //set up animation parameters</div><div class="line">    NSValue *fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    NSValue *toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    CFTimeInterval duration = 1.0;</div><div class="line">    //generate keyframes</div><div class="line">    NSInteger numFrames = duration * 60;</div><div class="line">    NSMutableArray *frames = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; numFrames; i++) &#123;</div><div class="line">        float time = 1 / (float)numFrames * i;</div><div class="line">        [frames addObject:[self interpolateFromValue:fromValue toValue:toValue time:time]];</div><div class="line">    &#125;</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = frames;</div><div class="line">    //apply animation</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这可以起到作用，但效果并不是很好，到目前为止我们所完成的只是一个非常复杂的方式来使用线性缓冲复制CABasicAnimation的行为。这种方式的好处在于我们可以更加精确地控制缓冲，这也意味着我们可以应用一个完全定制的缓冲函数。那么该如何做呢？</p>
<p>缓冲背后的数学并不很简单，但是幸运的是我们不需要一一实现它。罗伯特·彭纳有一个网页关于缓冲函数（<a href="http://www.robertpenner.com/easing" target="_blank" rel="noopener">http://www.robertpenner.com/easing</a>），包含了大多数普遍的缓冲函数的多种编程语言的实现的链接，包括C。这里是一个缓冲进入缓冲退出函数的示例（实际上有很多不同的方式去实现它）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">float quadraticEaseInOut(float t)</div><div class="line">&#123;</div><div class="line">    return (t &lt; 0.5)? (2 * t * t): (-2 * t * t) + (4 * t) - 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">对我们的弹性球来说，我们可以使用bounceEaseOut函数：</div><div class="line"></div><div class="line">float bounceEaseOut(float t)</div><div class="line">&#123;</div><div class="line">    if (t &lt; 4/11.0) &#123;</div><div class="line">        return (121 * t * t)/16.0;</div><div class="line">    &#125; else if (t &lt; 8/11.0) &#123;</div><div class="line">        return (363/40.0 * t * t) - (99/10.0 * t) + 17/5.0;</div><div class="line">    &#125; else if (t &lt; 9/10.0) &#123;</div><div class="line">        return (4356/361.0 * t * t) - (35442/1805.0 * t) + 16061/1805.0;</div><div class="line">    &#125;</div><div class="line">    return (54/5.0 * t * t) - (513/25.0 * t) + 268/25.0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果修改清单10.7的代码来引入bounceEaseOut方法，我们的任务就是仅仅交换缓冲函数，现在就可以选择任意的缓冲类型创建动画了（见清单10.8）。</div><div class="line"></div><div class="line">清单10.8 用关键帧实现自定义的缓冲函数</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //set up animation parameters</div><div class="line">    NSValue *fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    NSValue *toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    CFTimeInterval duration = 1.0;</div><div class="line">    //generate keyframes</div><div class="line">    NSInteger numFrames = duration * 60;</div><div class="line">    NSMutableArray *frames = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; numFrames; i++) &#123;</div><div class="line">        float time = 1/(float)numFrames * i;</div><div class="line">        //apply easing</div><div class="line">        time = bounceEaseOut(time);</div><div class="line">        //add keyframe</div><div class="line">        [frames addObject:[self interpolateFromValue:fromValue toValue:toValue time:time]];</div><div class="line">    &#125;</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = frames;</div><div class="line">    //apply animation</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#####总结<br> 在这一章中，我们了解了有关缓冲和CAMediaTimingFunction类，它可以允许我们创建自定义的缓冲函数来完善我们的动画，同样了解了如何用CAKeyframeAnimation来避开CAMediaTimingFunction的限制，创建完全自定义的缓冲函数。</p>
<p>在下一章中，我们将要研究基于定时器的动画–另一个给我们对动画更多控制的选择，并且实现对动画的实时操纵。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之锚点（anchorPoint）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之锚点（anchorPoint）/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>解释锚点最好的例子就是钟表：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-36287b3c6345777e.gif?imageMogr2/auto-orient/strip" alt="1.gif"></p>
<p>三个重叠View ，通过改变anchorPoint 改变他们的旋转中心，说白了锚点就是旋转的句柄，把手。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">self.containView =[[UIView alloc]init];</div><div class="line">self.containView.frame = CGRectMake(200 , 200, 5, 200);</div><div class="line">self.containView.backgroundColor =[UIColor redColor];</div><div class="line">[self.view addSubview:self.containView];</div><div class="line"></div><div class="line"></div><div class="line">self.containViewOne =[[UIView alloc]init];</div><div class="line">self.containViewOne.frame = CGRectMake(200 , 200, 5, 200);</div><div class="line">self.containViewOne.backgroundColor =[UIColor blueColor];</div><div class="line">[self.view addSubview:self.containViewOne];</div><div class="line"></div><div class="line"></div><div class="line">self.containViewTwo =[[UIView alloc]init];</div><div class="line">self.containViewTwo.frame = CGRectMake(200 , 200, 5, 200);</div><div class="line">self.containViewTwo.backgroundColor =[UIColor greenColor];</div><div class="line">[self.view addSubview:self.containViewTwo];</div><div class="line"></div><div class="line">self.containView.layer.anchorPoint = CGPointMake(0.5f, 0.95f);</div><div class="line">self.containViewOne.layer.anchorPoint = CGPointMake(0.5f, 0.95f);</div><div class="line">self.containViewTwo.layer.anchorPoint = CGPointMake(0.5f, 0.95f);</div><div class="line"></div><div class="line"></div><div class="line">self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">    //set initial hand positions</div><div class="line">[self tick];</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)tick</div><div class="line">&#123;</div><div class="line">    //convert time to hours, minutes and seconds</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">    //calculate hour hand angle //calculate minute hand angle</div><div class="line">    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">    //calculate second hand angle</div><div class="line">    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">    //rotate hands</div><div class="line">    self.containView.transform = CGAffineTransformMakeRotation(hoursAngle);</div><div class="line">    self.containViewOne.transform = CGAffineTransformMakeRotation(minsAngle);</div><div class="line">    self.containViewTwo.transform = CGAffineTransformMakeRotation(secsAngle);</div><div class="line">    self.containView.layer.shouldRasterize = YES;</div><div class="line">    self.containViewOne.layer.shouldRasterize = YES;</div><div class="line">    self.containViewTwo.layer.shouldRasterize = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>postion</p>
</blockquote>
<p> 确切地说，position是layer中的anchorPoint点在superLayer中的位置坐标。因此可以说,position点是相对suerLayer的，anchorPoint点是相对layer的，两者是相对不同的坐标空间的一个重合点。<br>   再来看看position的原始定义： The layer’sposition in its superlayer’s coordinate space。 中文可以理解成为position是layer相对superLayer坐标空间的位置，很显然，这里的位置是根据anchorPoint来确定的.</p>
<blockquote>
<p><strong>anchorPoint、position、frame
</strong></p>
</blockquote>
<p>anchorPoint的默认值为(0.5,0.5)，也就是anchorPoint默认在layer的中心点。默认情况下，使用addSublayer函数添加layer时，如果已知layer的frame值，根据上面的结论，那么position的值便可以用下面的公式计算:<br>position.x = frame.origin.x + 0.5 <em> bounds.size.width；<br>position.y = frame.origin.y + 0.5 </em> bounds.size.height；</p>
<p>里面的0.5是因为anchorPoint取默认值，更通用的公式应该是下面的：</p>
<p>position.x = frame.origin.x + anchorPoint.x  <em>bounds.size.width；<br> position.y = frame.origin.y + anchorPoint.y </em>bounds.size.height；</p>
<p>下面再来看另外两个问题，如果单方面修改layer的position位置，会对anchorPoint有什么影响呢？修改anchorPoint又如何影响position呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">self.containView =[[UIView alloc]init];</div><div class="line">   self.containView.frame = CGRectMake(200 , 200,100, 200);</div><div class="line">   self.containView.backgroundColor =[UIColor redColor];</div><div class="line">   [self.view addSubview:self.containView];</div><div class="line">   NSLog(@&quot;%@&quot;,NSStringFromCGPoint(self.containView.layer.anchorPoint));</div><div class="line">   </div><div class="line">   self.containView.layer.position = CGPointMake(50, 50);</div><div class="line">    NSLog(@&quot;%@&quot;,NSStringFromCGPoint(self.containView.layer.anchorPoint));</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-2078fa5f7669f074.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="03.png"></p>
<p>根据代码测试，两者互不影响，受影响的只会是frame.origin，也就是layer坐标原点相对superLayer会有所改变。换句话说，frame.origin由position和anchorPoint共同决定，上面的公式可以变换成下面这样的：<br>frame.origin.x = position.x - anchorPoint.x <em>bounds.size.width；<br> frame.origin.y = position.y - anchorPoint.y </em>bounds.size.height；<br>这就解释了为什么修改anchorPoint会移动layer，因为position不受影响，只能是frame.origin做相应的改变，因而会移动layer。</p>
<p>因为 position点和anchorPoint点是独立的，自己不会因为另外一个的改变而发生变化<br>参考文章 (<a href="http://blog.sina.com.cn/s/blog_155083d9e0102wi0r.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_155083d9e0102wi0r.html</a>)<br>这篇文章描述锚点描述的很清楚(<a href="http://www.jianshu.com/p/7703e6fc6191" target="_blank" rel="noopener">http://www.jianshu.com/p/7703e6fc6191</a>)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之隐式动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之隐式动画/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>按照我的意思去做，而不是我说的。 – 埃德娜，辛普森</p>
</blockquote>
<p>我们在第一部分讨论了Core Animation除了动画之外可以做到的任何事情。但是动画师Core Animation库一个非常显著的特性。这一章我们来看看它是怎么做到的。具体来说，我们先来讨论框架自动完成的隐式动画（除非你明确禁用了这个功能）。</p>
<p>####事务<br> Core Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。动画并不需要你在Core Animation中手动打开，相反需要明确地关闭，否则他会一直存在。</p>
<p>当你改变CALayer的一个可做动画的属性，它并不能立刻在屏幕上体现出来。相反，它是从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作。</p>
<p>这看起来这太棒了，似乎不太真实，我们来用一个demo解释一下：首先和第一章“图层树”一样创建一个蓝色的方块，然后添加一个按钮，随机改变它的颜色。代码见清单7.1。点击按钮，你会发现图层的颜色平滑过渡到一个新值，而不是跳变（图7.1）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-20bb31a74640830f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.png"></p>
<p>#####清单7.1 随机改变图层颜色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    @property (nonatomic, weak) IBOutlet CALayer *colorLayer;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create sublayer</div><div class="line">        self.colorLayer = [CALayer layer];</div><div class="line">        self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">        self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">        //add it to our view</div><div class="line">        [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (IBAction)changeColor</div><div class="line">    &#123;</div><div class="line">        //randomize the layer background color</div><div class="line">        CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">        CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">        CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">        self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;                                                                                       </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p>这其实就是所谓的隐式动画。之所以叫隐式是因为我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画。CoreAnimaiton同样支持显式动画，下章详细说明。</p>
<p>但当你改变一个属性，Core Animation是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。</p>
<p>事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。</p>
<p>事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction<br>没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。</p>
<p>任何可以做动画的图层属性都会被添加到栈顶的事务，你可以通过+setAnimationDuration:方法设置当前事务的动画时间，或者通过+animationDuration方法来获取值（默认0.25秒）。</p>
<p>Core Animation在每个run loop周期中自动开始一次新的事务（run loop是<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>负责收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显式的用[CATransaction begin]开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。</p>
<p>明白这些之后，我们就可以轻松修改变色动画的时间了。我们当然可以用当前事务的+setAnimationDuration:方法来修改动画时间，但在这里我们首先起一个新的事务，于是修改时间就不会有别的副作用。因为修改当前事务的时间可能会导致同一时刻别的动画（如屏幕旋转），所以最好还是在调整动画之前压入一个新的事务。</p>
<p>修改后的代码见清单7.2。运行程序，你会发现色块颜色比之前变得更慢了。</p>
<p>#####清单7.2 使用CATransaction控制动画时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (IBAction)changeColor</div><div class="line">&#123;</div><div class="line">    //begin a new transaction</div><div class="line">    [CATransaction begin];</div><div class="line">    //set the animation duration to 1 second</div><div class="line">    [CATransaction setAnimationDuration:1.0];</div><div class="line">    //randomize the layer background color</div><div class="line">    CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">    //commit the transaction</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 如果你用过UIView的动画方法做过一些动画效果，那么应该对这个模式不陌生。UIView有两个方法，+beginAnimations:context:和+commitAnimations，和CATransaction的+begin和+commit方法类似。实际上在+beginAnimations:context:和+commitAnimations之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因。</p>
<p>在iOS4中，苹果对UIView添加了一种基于block的动画方法：+animateWithDuration:animations:。这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。</p>
<p>CATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对+begin和+commit匹配的失误造成的风险。</p>
<p>#####完成块<br>基于UIView的block的动画允许你在动画结束的时候提供一个完成的动作。CATranscation接口提供的+setCompletionBlock:方法也有同样的功能。我们来调整上个例子，在颜色变化结束之后执行一些操作。我们来添加一个完成之后的block，用来在每次颜色变化结束之后切换到另一个旋转90的动画。代码见清单7.3，运行结果见图7.2。</p>
<p>#####清单7.3 在颜色动画完成之后添加一个回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (IBAction)changeColor</div><div class="line">   &#123;</div><div class="line">       //begin a new transaction</div><div class="line">       [CATransaction begin];</div><div class="line">       //set the animation duration to 1 second</div><div class="line">       [CATransaction setAnimationDuration:1.0];</div><div class="line">       //add the spin animation on completion</div><div class="line">       [CATransaction setCompletionBlock:^&#123;</div><div class="line">           //rotate the layer 90 degrees</div><div class="line">           CGAffineTransform transform = self.colorLayer.affineTransform;</div><div class="line">           transform = CGAffineTransformRotate(transform, M_PI_2);</div><div class="line">           self.colorLayer.affineTransform = transform;</div><div class="line">       &#125;];</div><div class="line">       //randomize the layer background color</div><div class="line">       CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">       //commit the transaction</div><div class="line">       [CATransaction commit];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0b504d64ca403949.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2.png"><br>注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。</p>
<p>#####图层行为<br> 现在来做个实验，试着直接对UIView关联的图层做动画而不是一个单独的图层。清单7.4是对清单7.2代码的一点修改，移除了colorLayer，并且直接设置layerView关联图层的背景色。</p>
<p>#####清单7.4 直接设置图层的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //set the color of our layerView backing layer directly</div><div class="line">       self.layerView.layer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (IBAction)changeColor</div><div class="line">   &#123;</div><div class="line">       //begin a new transaction</div><div class="line">       [CATransaction begin];</div><div class="line">       //set the animation duration to 1 second</div><div class="line">       [CATransaction setAnimationDuration:1.0];</div><div class="line">       //randomize the layer background color</div><div class="line">       CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       self.layerView.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">       //commit the transaction</div><div class="line">       [CATransaction commit];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，你会发现当按下按钮，图层颜色瞬间切换到新的值，而不是之前平滑过渡的动画。发生了什么呢？隐式动画好像被UIView关联图层给禁用了。</p>
<p>试想一下，如果UIView的属性都有动画特性的话，那么无论在什么时候修改它，我们都应该能注意到的。所以，如果说UIKit建立在Core Animation（默认对所有东西都做动画）之上，那么隐式动画是如何被UIKit禁用掉呢？</p>
<p>我们知道Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView把它关联的图层的这个特性关闭了。为了更好说明这一点，我们需要知道隐式动画是如何实现的。</p>
<p>我们把改变属性时CALayer自动应用的动画称作行为，当CALayer的属性被修改时候，它会调用-actionForKey:方法，传递属性的名称。剩下的操作都在CALayer的头文件中有详细的说明，实质上是如下几步：</p>
<ul>
<li>图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。</li>
<li>如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。</li>
<li>如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。</li>
<li>最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。<br>所以一轮完整的搜索结束之后，-actionForKey:要么返回空（这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。</li>
</ul>
<p>于是这就解释了UIKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。我们可以用一个demo做个简单的实验（清单7.5）</p>
<p>#####清单7.5 测试UIView的actionForLayer:forKey:实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //test layer action when outside of animation block</div><div class="line">        NSLog(@&quot;Outside: %@&quot;, [self.layerView actionForLayer:self.layerView.layer forKey:@&quot;backgroundColor&quot;]);</div><div class="line">        //begin animation block</div><div class="line">        [UIView beginAnimations:nil context:nil];</div><div class="line">        //test layer action when inside of animation block</div><div class="line">        NSLog(@&quot;Inside: %@&quot;, [self.layerView actionForLayer:self.layerView.layer forKey:@&quot;backgroundColor&quot;]);</div><div class="line">        //end animation block</div><div class="line">        [UIView commitAnimations];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p>运行程序，控制台显示结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ LayerTest[21215:c07] Outside: &lt;null&gt;</div><div class="line">$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;</div></pre></td></tr></table></figure></p>
<p> 于是我们可以预言，当属性在动画块之外发生改变，UIView直接通过返回nil来禁用隐式动画。但如果在动画块范围之内，根据动画具体类型返回相应的属性，在这个例子就是CABasicAnimation（第八章“显式动画”将会提到）。</p>
<p>当然返回nil并不是禁用隐式动画唯一的办法，CATransacition有个方法叫做+setDisableActions:，可以用来对所有属性打开或者关闭隐式动画。如果在清单7.2的[CATransaction begin]之后添加下面的代码，同样也会阻止动画的发生：<br><code>[CATransaction setDisableActions:YES];</code><br>总结一下，我们知道了如下几点:</p>
<ul>
<li>UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画（具体细节见第八章）。</li>
<li>对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。</li>
</ul>
<p>我们来对颜色渐变的例子使用一个不同的行为，通过给colorLayer设置一个自定义的actions字典。我们也可以使用委托来实现，但是actions字典可以写更少的代码。那么到底改如何创建一个合适的行为对象呢？</p>
<p>行为通常是一个被Core Animation隐式调用的显式动画对象。这里我们使用的是一个实现了CATransaction的实例，叫做推进过渡。</p>
<p>第八章中将会详细解释过渡，不过对于现在，知道CATransition响应CAAction协议，并且可以当做一个图层行为就足够了。结果很赞，不论在什么时候改变背景颜色，新的色块都是从左侧滑入，而不是默认的渐变效果。</p>
<p>#####清单7.6 实现自定义行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">@property (nonatomic, weak) IBOutlet CALayer *colorLayer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //create sublayer</div><div class="line">    self.colorLayer = [CALayer layer];</div><div class="line">    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">    //add a custom action</div><div class="line">    CATransition *transition = [CATransition animation];</div><div class="line">    transition.type = kCATransitionPush;</div><div class="line">    transition.subtype = kCATransitionFromLeft;</div><div class="line">    self.colorLayer.actions = @&#123;@&quot;backgroundColor&quot;: transition&#125;;</div><div class="line">    //add it to our view</div><div class="line">    [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)changeColor</div><div class="line">&#123;</div><div class="line">    //randomize the layer background color</div><div class="line">    CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-e5f1538ed0a19aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.3.png"></p>
<p>#####呈现与模型<br>CALayer<br>的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。这是怎么做到的呢？<br>当你改变一个图层的属性，属性值的确是立刻更新的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改变。这是因为你设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。<br>当设置CALayer的属性，实际上是在定义当前事务结束之后图层如何显示的模型。Core Animation扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。</p>
<p>我们讨论的就是一个典型的微型MVC模式。CALayer<br>是一个连接用户界面（就是MVC中的view）虚构的类，但是在界面本身这个场景下，CALayer的行为更像是存储了视图如何显示和动画的数据模型。实际上，在苹果自己的文档中，图层树通常都是值的图层树模型。</p>
<p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着CALayer<br>除了“真实”值（就是你设置的值）之外，必须要知道当前显示在屏幕上的属性值的记录。</p>
<p>每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中，他可以通过-presentationLayer方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值（图7.4）。</p>
<p>我们在第一章中提到除了图层树，另外还有呈现树。呈现树通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被提交（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用-presentationLayer<br>将会返回nil。</p>
<p>你可能注意到有一个叫做–modelLayer的方法。在呈现图层上调用–modelLayer将会返回它正在呈现所依赖的CALayer<br>。通常在一个图层上调用-modelLayer会返回–self(实际上我们已经创建的原始图层就是一种数据模型）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-842f562b2414851f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.4.png"></p>
<p>大多数情况下，你不需要直接访问呈现图层，你可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下呈现图层会变得很有用，一个是同步动画，一个是处理用户交互。</p>
<ul>
<li>如果你在实现一个基于定时器的动画（见第11章“基于定时器的动画”），而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li>
<li>如果你想让你做动画的图层响应用户输入，你可以使用-hitTest:<br>方法（见第三章“图层几何学”）来判断指定图层是否被触摸，这时候对呈现图层而不是模型图层调用-hitTest:<br>会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li>
</ul>
<p>我们可以用一个简单的案例来证明后者（见清单7.7）。在这个例子中，点击屏幕上的任意位置将会让图层平移到那里。点击图层本身可以随机改变它的颜色。我们通过对呈现图层调用-hitTest:来判断是否被点击。</p>
<p>如果修改代码让-hitTest:直接作用于colorLayer而不是呈现图层，你会发现当图层移动的时候它并不能正确显示。这时候你就需要点击图层将要移动到的位置而不是图层本身来响应点击（这就是为什么用呈现图层来响应交互的原因）</p>
<p>#####清单7.7 使用presentationLayer图层来判断当前图层位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">  </div><div class="line">  @property (nonatomic, strong) CALayer *colorLayer;</div><div class="line">  </div><div class="line">  @end</div><div class="line">  </div><div class="line">  @implementation ViewController</div><div class="line">  </div><div class="line">  - (void)viewDidLoad</div><div class="line">  &#123;</div><div class="line">      [super viewDidLoad];</div><div class="line">      //create a red layer</div><div class="line">      self.colorLayer = [CALayer layer];</div><div class="line">      self.colorLayer.frame = CGRectMake(0, 0, 100, 100);</div><div class="line">      self.colorLayer.position = CGPointMake(self.view.bounds.size.width / 2, self.view.bounds.size.height / 2);</div><div class="line">      self.colorLayer.backgroundColor = [UIColor redColor].CGColor;</div><div class="line">      [self.view.layer addSublayer:self.colorLayer];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">  &#123;</div><div class="line">      //get the touch point</div><div class="line">      CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">      //check if we&apos;ve tapped the moving layer</div><div class="line">      if ([self.colorLayer.presentationLayer hitTest:point]) &#123;</div><div class="line">          //randomize the layer background color</div><div class="line">          CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">          CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">          CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">          self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">      &#125; else &#123;</div><div class="line">          //otherwise (slowly) move the layer to new position</div><div class="line">          [CATransaction begin];</div><div class="line">          [CATransaction setAnimationDuration:4.0];</div><div class="line">          self.colorLayer.position = point;</div><div class="line">          [CATransaction commit];</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  @end</div></pre></td></tr></table></figure></p>
<p>#####总结<br>这一章讨论了隐式动画，还有Core Animation对指定属性选择合适的动画行为的机制。同时你知道了UIKit是如何充分利用Core Animation的隐式动画机制来强化它的显式系统，以及动画是如何被默认禁用并且当需要的时候启用的。最后，你了解了呈现和模型图层，以及Core Animation是如何通过它们来判断出图层当前位置以及将要到达的位置。<br>在下一章中，我们将研究Core Animation提供的显式动画类型，既可以直接对图层属性做动画，也可以覆盖默认的图层行为。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation之CAReplicatorLayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation之CAReplicatorLayer/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CAReplicatorLayer 一般用来复制层或者反射。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-e6fd9c0497884002.gif?imageMogr2/auto-orient/strip" alt="3.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line">@property(nonatomic,strong)UIView *containView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // Do any additional setup after loading the view, typically from a nib.</div><div class="line">    </div><div class="line"></div><div class="line">    self.containView =[[UIView alloc]initWithFrame:CGRectMake(self.view.frame.size.width/2 -100, self.view.frame.size.height/2 - 100, 200, 200)];</div><div class="line">    self.containView.backgroundColor =[UIColor redColor];</div><div class="line">    [self.view addSubview:self.containView];</div><div class="line">    </div><div class="line"></div><div class="line">    CAReplicatorLayer *replayer =[CAReplicatorLayer layer];</div><div class="line">    replayer.frame = self.containView.bounds;</div><div class="line">    [self.containView.layer addSublayer:replayer];</div><div class="line">    CALayer *layer = [CALayer layer];</div><div class="line">    </div><div class="line"></div><div class="line">    layer.frame = CGRectMake(0, replayer.bounds.size.height -150, 10, 150);</div><div class="line"></div><div class="line">    layer.backgroundColor = [UIColor whiteColor].CGColor;</div><div class="line">    </div><div class="line"></div><div class="line">    </div><div class="line">    [replayer addSublayer:layer];</div><div class="line">    </div><div class="line">    CABasicAnimation *anim = [CABasicAnimation animation];</div><div class="line">    </div><div class="line">    anim.keyPath = @&quot;transform.scale.y&quot;;</div><div class="line">    </div><div class="line">    anim.toValue = @0.1;</div><div class="line">    </div><div class="line">    anim.duration = 0.5;</div><div class="line">    </div><div class="line">    anim.repeatCount = MAXFLOAT;</div><div class="line">    </div><div class="line">    // 设置动画反转</div><div class="line">    anim.autoreverses = YES;</div><div class="line">    </div><div class="line">    </div><div class="line">    [layer addAnimation:anim forKey:nil];</div><div class="line">    </div><div class="line">    </div><div class="line">//     复制层中子层总数</div><div class="line">//     instanceCount：表示复制层里面有多少个子层，包括原始层</div><div class="line">    replayer.instanceCount = 5;</div><div class="line">    </div><div class="line">    // 设置复制子层偏移量，不包括原始层,相对于原始层x偏移</div><div class="line">//    replayer.instanceTransform = CATransform3DIdentity;</div><div class="line"></div><div class="line">   </div><div class="line">    CATransform3D tranform = CATransform3DIdentity;</div><div class="line">    tranform = CATransform3DMakeTranslation(45, 0, 0);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    replayer.instanceTransform =tranform;</div><div class="line">    </div><div class="line">    // 设置复制层动画延迟时间</div><div class="line">    replayer.instanceDelay = 0.1;</div><div class="line">    </div><div class="line">    // 如果设置了原始层背景色，就不需要设置这个属性</div><div class="line">    replayer.instanceColor = [UIColor greenColor].CGColor;</div><div class="line">    </div><div class="line">    replayer.instanceGreenOffset = -0.3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2017/12/28/CoreAnimation图层几何学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/28/CoreAnimation图层几何学/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-28T20:43:14+08:00">
                2017-12-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<ul>
<li>####<strong>布局</strong></li>
</ul>
<p> UIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p>frame代表了图层的外部坐标（也就是在父图层上占据的空间），bounds是内部坐标（{0, 0}通常是图层的左上角），center和position都代表了相对于父图层anchorPoint所在的位置。anchorPoint的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-60c2a6313ce9cad9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.1.png"></p>
<p>视图的frame，bounds和center属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的frame<br>，不能够独立于图层之外改变视图的frame。</p>
<p>对于视图或者图层来说，frame并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据bounds，position和transform<br>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了（图3.2）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-962d369cf221fcfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2.png"></p>
<ul>
<li>####<strong>锚点</strong></li>
</ul>
<p>之前提到过，视图的center属性和图层的position属性都指定了anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame的位置，你可以认为anchorPoint是用来移动图层的把柄。</p>
<p>默认来说，anchorPoint位于图层的中点，所以图层的将会以这个点为中心放置。anchorPoint属性并没有被UIView接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的anchorPoint可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动（图3.3），而不是居中了。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-7827e0f4aceeba78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.3.png"></p>
<p>和第二章提到的contentsRect和contentsCenter属性类似，anchorPoint用单位坐标来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。anchorPoint可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了anchorPoint，position属性保持固定的值并没有发生改变，但是frame却移动了。</p>
<p>那在什么场合需要改变anchorPoint呢？既然我们可以随意改变图层位置，那改变anchorPoint不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个UIImageView<br>实例（当然你也可以用正常的视图，设置他们图层的contents<br>图片）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-2e8b159f0f65cc54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4.png"></p>
<p> 闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的frame，而根据图3.2的演示，当视图旋转的时候，frame是会发生改变的，这将会导致一些布局上的失灵。</p>
<p>我们用NSTimer来更新闹钟，使用视图的transform属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0a145b572f694e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.png"></p>
<p>#####清单3.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *hourHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *secondHand;</div><div class="line">@property (nonatomic, weak) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //start timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">    ￼</div><div class="line">    //set initial hand positions</div><div class="line">    [self tick];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tick</div><div class="line">&#123;</div><div class="line">    //convert time to hours, minutes and seconds</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">    //calculate hour hand angle //calculate minute hand angle</div><div class="line">    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">    //calculate second hand angle</div><div class="line">    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">    //rotate hands</div><div class="line">    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);</div><div class="line">    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);</div><div class="line">    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-63fdc55a5c4ba280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.png"><br> 你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>
<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>
<p>更好的方案是使用anchorPoint属性，我们来在-viewDidLoad方法中添加几行代码来给每个钟指针的anchorPoint做一些平移（清单3.2），图3.7显示了正确的结果。</p>
<p>#####清单3.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       // adjust anchor points</div><div class="line">       </div><div class="line">       self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       </div><div class="line">       </div><div class="line">       // start timer</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-73c01bb8b7088a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.7.png"></p>
<ul>
<li>####<strong>坐标系</strong><br>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds<br>，如果父图层发生了移动，它的所有子图层也会跟着移动。</li>
</ul>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的绝对位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。<br>CALayer给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; </div><div class="line">- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; </div><div class="line">- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;</div><div class="line">- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</div></pre></td></tr></table></figure>
<p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>
<ul>
<li>####<strong>翻转的几何结构</strong></li>
</ul>
<p>常规说来，在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES,意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们geometryFlipped<br>属性也设为YES）。</p>
<ul>
<li>####<strong>Z坐标轴</strong></li>
</ul>
<p>和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了我们已经讨论过的position和anchorPoint属性之外，CALayer还有另外两个属性，zPosition和anchorPointZ<br>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>注意这里并没有更深的属性来描述由宽和高做成的bounds<br>了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>
<p>zPosition属性在大多数情况下其实并不常用。在第五章，我们将会涉及CATransform3D，你会知道如何在三维空间移动和旋转图层，除了做变换之外，zPosition最实用的功能就是改变图层的显示顺序了。</p>
<p>通常，图层是根据它们子图层的sublayers<br>出现的顺序来类绘制的，这就是所谓的画家的<a href="http://lib.csdn.net/base/31" target="_blank" rel="noopener">算法</a>–就像一个画家在墙上作画–后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的zPosition，就可以把图层向相机方向前置，于是它就在所有其他图层的前面了（或者至少是小于它的zPosition值的图层的前面）。</p>
<p>这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。</p>
<p>图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-68e4281dd52477ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.8.png"><br>我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的zPosition（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给zPosition提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。</p>
<p>#####清单3.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *greenView;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *redView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       ￼</div><div class="line">       //move the green view zPosition nearer to the camera</div><div class="line">       self.greenView.layer.zPosition = 1.0f;</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-e7ea5f6f69f43a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.9绿色视图被绘制在红色视图的前面.png"></p>
<ul>
<li>####<strong>Hit Testing</strong></li>
</ul>
<p> 第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。</p>
<p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：-containsPoint:和-hitTest:。</p>
<p>-containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用-containsPoint:方法来判断到底是白色还是蓝色的图层被触摸了 （图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>
<p>#####清单3.4 使用containsPoint判断被点击的图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">   @property (nonatomic, weak) CALayer *blueLayer;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //create sublayer</div><div class="line">       self.blueLayer = [CALayer layer];</div><div class="line">       self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">       self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">       //add it to our view</div><div class="line">       [self.layerView.layer addSublayer:self.blueLayer];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">   &#123;</div><div class="line">       //get touch position relative to main view</div><div class="line">       CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">       //convert point to the white layer&apos;s coordinates</div><div class="line">       point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];</div><div class="line">       //get layer using containsPoint:</div><div class="line">       if ([self.layerView.layer containsPoint:point]) &#123;</div><div class="line">           //convert point to blueLayer’s coordinates</div><div class="line">           point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];</div><div class="line">           if ([self.blueLayer containsPoint:point]) &#123;</div><div class="line">               [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                           message:nil</div><div class="line">                                          delegate:nil</div><div class="line">                                 cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                                 otherButtonTitles:nil] show];</div><div class="line">           &#125; else &#123;</div><div class="line">               [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                           message:nil</div><div class="line">                                          delegate:nil</div><div class="line">                                 cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                                 otherButtonTitles:nil] show];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-71820c2c4fb8faac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.10点击图层被正确标识.png"></p>
<p>-hitTest:方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用-containsPoint:那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用-hitTest:方法被点击图层的代码如清单3.5所示。</p>
<p>#####使用hitTest判断被点击的图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //get touch position</div><div class="line">    CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">    //get touched layer</div><div class="line">    CALayer *layer = [self.layerView.layer hitTest:point];</div><div class="line">    //get layer using hitTest</div><div class="line">    if (layer == self.blueLayer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125; else if (layer == self.layerView.layer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 注意当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。</p>
<ul>
<li>####<strong>自动布局属性</strong></li>
</ul>
<p>你可能用过UIViewAutoresizingMask类型的一些常量，应用于当父视图改变尺寸的时候，相应UIView的frame也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了自动排版机制，它和自动调整不同，并且更加复杂。在Mac OS平台，CALayer有一个叫做layoutManager的属性可以通过CALayoutManager协议和CAConstraintLayoutManager类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraintAPI，但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数：<br><code>- (void)layoutSublayersOfLayer:(CALayer *)layer;</code></p>
<p>#####总结<br> 本章涉及了CALayer的集合结构，包括它的frame，position和bounds，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg"
              alt="雪晟" />
          
            <p class="site-author-name" itemprop="name">雪晟</p>
            <p class="site-description motion-element" itemprop="description">多去尝试你从未尝试的。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">98</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liuxinixn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/3d7c50f31b88" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-flag"></i>Jianshu</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雪晟</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
