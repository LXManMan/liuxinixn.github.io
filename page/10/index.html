<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="多去尝试你从未尝试的。">
<meta property="og:type" content="website">
<meta property="og:title" content="雪晟">
<meta property="og:url" content="liuxinixn.github.io/page/10/index.html">
<meta property="og:site_name" content="雪晟">
<meta property="og:description" content="多去尝试你从未尝试的。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雪晟">
<meta name="twitter:description" content="多去尝试你从未尝试的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxinixn.github.io/page/10/"/>





  <title>雪晟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雪晟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">十年饮冰，难凉热血。我是雪晟。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/07/CoreAnimation之变换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/07/CoreAnimation之变换/" itemprop="url">CoreAnimation之变化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-07T20:19:35+08:00">
                2016-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>很不幸，没人能告诉你母体是什么，你只能自己体会 – 骇客帝国</p>
</blockquote>
<p>在第四章“可视效果”中，我们研究了一些增强图层和它的内容显示效果的一些技术，在这一章中，我们将要研究可以用来对图层旋转，摆放或者扭曲的CGAffineTransform，以及可以将扁平物体转换成三维空间对象的CATransform3D（而不是仅仅对圆角矩形添加下沉阴影）。</p>
<ul>
<li>####<strong>仿射变换</strong></li>
</ul>
<p>在第三章“图层几何学”中，我们使用了UIView的transform属性旋转了钟的指针，但并没有解释背后运作的原理，实际上UIView的transform属性是一个CGAffineTransform类型，用于在二维空间做旋转，缩放和平移。CGAffineTransform是一个可以和二维空间向量（例如CGPoint）做乘法的3X2的矩阵（见图5.1）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-3045549ea178fed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.png"><br> 用CGPoint的每一列和CGAffineTransform矩阵的每一行对应元素相乘再求和，就形成了一个新的CGPoint类型的结果。要解释一下图中显示的灰色元素，为了能让矩阵做乘法，左边矩阵的列数一定要和右边矩阵的行数个数相同，所以要给矩阵填充一些标志值，使得既可以让矩阵做乘法，又不改变运算结果，并且没必要存储这些添加的值，因为它们的值不会发生变化，但是要用来做运算。</p>
<p>因此，通常会用3×3（而不是2×3）的矩阵来做二维变换，你可能会见到3行2列格式的矩阵，这是所谓的以列为主的格式，图5.1所示的是以行为主的格式，只要能保持一致，用哪种格式都无所谓。</p>
<p>当对图层应用变换矩阵，图层矩形内的每一个点都被相应地做变换，从而形成一个新的四边形的形状。CGAffineTransform中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行，CGAffineTransform可以做出任意符合上述标注的变换，图5.2显示了一些仿射的和非仿射的变换：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-942383d3231167ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.2.png"></p>
<pre><code>仿射和非仿射变换
</code></pre><p><strong>创建一个CGAffineTransform</strong></p>
<p>对矩阵数学做一个全面的阐述就超出本书的讨论范围了，不过如果你对矩阵完全不熟悉的话，矩阵变换可能会使你感到畏惧。幸运的是，Core Graphics提供了一系列函数，对完全没有数学基础的开发者也能够简单地做一些变换。如下几个函数都创建了一个CGAffineTransform实例：<br><code>CGAffineTransformMakeRotation(CGFloat angle) 
CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)</code><br>  旋转和缩放变换都可以很好解释–分别旋转或者缩放一个向量的值。平移变换是指每个点都移动了向量指定的x或者y值–所以如果向量代表了一个点，那它就平移了这个点的距离。</p>
<p>我们用一个很简单的项目来做个demo，把一个原始视图旋转45度角度（图5.3）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-378ef29aa545c385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.3.png"><br> UIView可以通过设置transform属性做变换，但实际上它只是封装了内部图层的变换。</p>
<p>CALayer同样也有一个transform属性，但它的类型是CATransform3D，而不是CGAffineTransform，本章后续将会详细解释。CALayer对应于UIView的transform属性叫做affineTransform，清单5.1的例子就是使用affineTransform对图层做了45度顺时针旋转。</p>
<p>#####清单5.1 使用affineTransform对图层旋转45度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //rotate the layer 45 degrees</div><div class="line">    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">    self.layerView.layer.affineTransform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>注意我们使用的旋转常量是M_PI_4，而不是你想象的45，因为<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>的变换函数使用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所以四分之一的pi就是45度。</p>
<p>C的数学函数库（iOS会自动引入）提供了pi的一些简便的换算，M_PI_4于是就是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) </div><div class="line">#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)</div></pre></td></tr></table></figure></p>
<p><strong>混合变换</strong><br>Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要缩放又要旋转的变换，这就会非常有用了。例如下面几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)     </div><div class="line">CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)      </div><div class="line">CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)</div></pre></td></tr></table></figure></p>
<p>当操纵一个变换的时候，初始生成一个什么都不做的变换很重要–也就是创建一个CGAffineTransform<br>类型的空值，矩阵论中称作单位矩阵，Core Graphics同样也提供了一个方便的常量：<br><code>CGAffineTransformIdentity</code><br>最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：<br><code>CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);</code></p>
<p>我们来用这些函数组合一个更加复杂的变换，先缩小50%，再旋转30度，最后向右移动200个像素（清单5.2）。图5.4显示了图层变换最后的结果。</p>
<p>#####清单5.2 使用若干方法创建一个复合变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad]; //create a new transform</div><div class="line">    CGAffineTransform transform = CGAffineTransformIdentity; //scale by 50%</div><div class="line">    transform = CGAffineTransformScale(transform, 0.5, 0.5); //rotate by 30 degrees</div><div class="line">    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //translate by 200 points</div><div class="line">    transform = CGAffineTransformTranslate(transform, 200, 0);</div><div class="line">    //apply transform to layer</div><div class="line">    self.layerView.layer.affineTransform = transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-336be9d648d56cd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.4.png"></p>
<p> 图5.4中有些需要注意的地方：图片向右边发生了平移，但并没有指定距离那么远（200像素），另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。</p>
<p>这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<p><strong>剪切变换</strong><br>Core Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置CGAffineTransform<br>的值。除非需要创建一个斜切的变换，Core Graphics并没有提供直接的函数。<br>斜切变换是放射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。我们用一张图片可以很直接的说明效果（图5.5）。也许用“倾斜”描述更加恰当，具体做变换的代码见清单5.3。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6817472cb15dc214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="斜切变换.png"></p>
<p>####清单5.3 实现一个斜切变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)</div><div class="line">&#123;</div><div class="line">    CGAffineTransform transform = CGAffineTransformIdentity;</div><div class="line">    transform.c = -x;</div><div class="line">    transform.b = y;</div><div class="line">    return transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //shear the layer at a 45-degree angle</div><div class="line">    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3D变换</strong><br> CG的前缀告诉我们，CGAffineTransform类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且CGAffineTransform仅仅对2D变换有效。</p>
<p>在第三章中，我们提到了zPosition属性，可以用来让图层靠近或者远离相机（用户视角），transform属性（CATransform3D类型）可以真正做到这点，即让图层在3D空间内移动或者旋转。</p>
<p>和CGAffineTransform类似，CATransform3D也是一个矩阵，但是和2x3的矩阵不同，CATransform3D是一个可以在3维空间内做变换的4x4的矩阵（图5.6）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-474ebda43a0f86d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.6.png"></p>
<pre><code>对一个3D像素点做CATransform3D矩阵变换
</code></pre><p>和CGAffineTransform矩阵类似，Core Animation提供了一系列的方法用来创建和组合CATransform3D类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个z参数，并且旋转函数除了angle之外多出了x,y,z三个参数，分别决定了每个坐标轴方向上的旋转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)</div><div class="line">CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) </div><div class="line">CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)</div></pre></td></tr></table></figure></p>
<p>你应该对X轴和Y轴比较熟悉了，分别以右和下为正方向（回忆第三章，这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向（图5.7)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0808e997f038e4a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.7.png"></p>
<p> 由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。</p>
<p>举个例子：清单5.4的代码使用了CATransform3DMakeRotation对视图内的图层绕Y轴做了45度角的旋转，我们可以把视图向右倾斜，这样会看得更清晰。</p>
<p>结果见图5.8，但并不像我们期待的那样。</p>
<p>#####清单5.4 绕Y轴旋转图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //rotate the layer 45 degrees along the Y axis</div><div class="line">        CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);</div><div class="line">        self.layerView.layer.transform = transform;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-740459ecf2961450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.8.png"></p>
<p>看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，是哪里出了问题呢？<br>其实完全没错，视图看起来更窄实际上是因为我们在用一个斜向的视角看它，而不是透视。</p>
<p><strong>透视投影</strong><br>在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边跟短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中任然保持平行，和之前提到的仿射变换类似。</p>
<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处（例如建筑绘图，颠倒，和伪3D视频），但当前我们并不需要。</p>
<p>为了做一些修正，我们需要引入投影变换（又称作z变换）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：</p>
<p>CATransform3D的透视效果通过一个矩阵中一个很简单的元素来控制：m34。m34（图5.9）用于按比例缩放X和Y的值来计算到底要离视角多远。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d9b4df52bdf13918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.9.png"><br> m34的默认值是0，我们可以通过设置m34为-1.0 / d来应用透视效果，d代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了。</p>
<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的防止的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果，对视图应用透视的代码见清单5.5，结果见图5.10。</p>
<p>#####清单5.5 对变换应用透视效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a new transform</div><div class="line">    CATransform3D transform = CATransform3DIdentity;</div><div class="line">    //apply perspective</div><div class="line">    transform.m34 = - 1.0 / 500.0;</div><div class="line">    //rotate by 45 degrees along the Y axis</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);</div><div class="line">    //apply to layer</div><div class="line">    self.layerView.layer.transform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-b2c36c95bd0d9de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.10.png"></p>
<p><strong>灭点</strong><br> 当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>在现实中，这个点通常是视图的中心（图5.11），于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0009ba0f03440c28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.11.png"><br> Core Animation定义了这个点位于变换图层的anchorPoint（通常位于图层中心，但也有例外，见第三章）。这就是说，当图层发生变换时，这个点永远位于图层变换之前anchorPoint的位置。</p>
<p>当改变一个图层的position，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整m34来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的position），这样所有的3D图层都共享一个灭点。</p>
<ul>
<li>####<strong>sublayerTransform属性</strong></li>
</ul>
<p>如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个position，如果用一个函数封装这些操作的确会更加方便，但仍然有限制（例如，你不能在Interface Builder中摆放视图），这里有一个更好的方法。</p>
<p>CALayer有一个属性叫做sublayerTransform。它也是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<p>相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在容器图层的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用position<br>和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
<p>我们来用一个demo举例说明。这里用Interface Builder并排放置两个视图（图5.12），然后通过设置它们容器视图的透视变换，我们可以保证它们有相同的透视和灭点，代码见清单5.6，结果见图5.13。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-99bde2090f46140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.12.png"></p>
<p>#####清单5.6 应用sublayerTransform<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //apply perspective transform to container</div><div class="line">    CATransform3D perspective = CATransform3DIdentity;</div><div class="line">    perspective.m34 = - 1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = perspective;</div><div class="line">    //rotate layerView1 by 45 degrees along the Y axis</div><div class="line">    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);</div><div class="line">    self.layerView1.layer.transform = transform1;</div><div class="line">    //rotate layerView2 by 45 degrees along the Y axis</div><div class="line">    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);</div><div class="line">    self.layerView2.layer.transform = transform2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-550f11f77952d490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.13通过相同的透视效果分别对视图做变换.png"><br><strong>背面</strong><br>我们既然可以在3D场景下旋转图层，那么也可以从背面去观察它。如果我们在清单5.4中把角度修改为M_PI（180度）而不是当前的M_PI_4（45度），那么将会把图层完全旋转一个半圈，于是完全背对了相机视角。<br>那么从背部看图层是什么样的呢，见图5.14</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d410b79466859b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.14.png"></p>
<p> 如你所见，图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p>CALayer有一个叫做doubleSided的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<p><strong>扁平化图层</strong><br>如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？见图5.15</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-8c0d287a3d5365db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.15.png"></p>
<p>意做了-45度旋转的内部图层是怎样抵消旋转45度的图层，从而恢复正常状态的。</p>
<p>如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。</p>
<p>验证一下，相应代码见清单5.7，结果见5.16</p>
<p>#####清单5.7 绕Z轴做相反的旋转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *outerView;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *innerView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //rotate the outer layer 45 degrees</div><div class="line">       CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);</div><div class="line">       self.outerView.layer.transform = outer;</div><div class="line">       //rotate the inner layer -45 degrees</div><div class="line">       CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);</div><div class="line">       self.innerView.layer.transform = inner;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c628c844d39fcbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.16.png"></p>
<p>运行结果和我们预期的一致。现在在3D情况下再试一次。修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用sublayerTransform属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换（清单5.8）。</p>
<p>#####清单5.8 绕Y轴相反的旋转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //rotate the outer layer 45 degrees</div><div class="line">    CATransform3D outer = CATransform3DIdentity;</div><div class="line">    outer.m34 = -1.0 / 500.0;</div><div class="line">    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);</div><div class="line">    self.outerView.layer.transform = outer;</div><div class="line">    //rotate the inner layer -45 degrees</div><div class="line">    CATransform3D inner = CATransform3DIdentity;</div><div class="line">    inner.m34 = -1.0 / 500.0;</div><div class="line">    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);</div><div class="line">    self.innerView.layer.transform = inner;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d0ede7526b6d95b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.17.png"></p>
<p>但其实这并不是我们所看到的，相反，我们看到的结果如图5.18所示。发什么了什么呢？内部的图层仍然向左侧旋转，并且发生了扭曲，但按道理说它应该保持正面朝上，并且显示正常的方块。</p>
<p>这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-77d09181063d3aa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="518.png"></p>
<p> 类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>
<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系–在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。</p>
<p>至少当你用正常的CALayer的时候是这样，CALayer有一个叫做CATransformLayer的子类来解决这个问题。具体在第六章“特殊的图层”中将会具体讨论。</p>
<p><strong>固体对象</strong><br>现在你懂得了在3D空间的一些图层布局的基础，我们来试着创建一个固态的3D对象（实际上是一个技术上所谓的空洞对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。<br>在这个例子中，我们用Interface Builder来构建立方体的面（图5.19），我们当然可以用代码来写，但是用Interface Builder的好处是可以方便的在每一个面上添加子视图。记住这些面仅仅是包含视图和控件的普通的用户界面元素，它们完全是我们界面交互的部分，并且当把它折成一个立方体之后也不会改变这个性质。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-9ac8ecb9aac49eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.19.png"><br> 这些面视图并没有放置在主视图当中，而是松散地排列在根nib文件里面。我们并不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的transform对它们进行重新布局，并且用Interface Builder在容器视图之外摆放他们可以让我们容易看清楚它们的内容，如果把它们一个叠着一个都塞进主视图，将会变得很难看。</p>
<p>我们把一个有颜色的UILabel放置在视图内部，是为了清楚的辨别它们之间的关系，并且UIButton被放置在第三个面视图里面，后面会做简单的解释。</p>
<p>具体把视图组织成立方体的代码见清单5.9，结果见图5.20</p>
<p>#####清单5.9 创建一个立方体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform</div><div class="line">&#123;</div><div class="line">    //get the face view and add it to the container</div><div class="line">    UIView *face = self.faces[index];</div><div class="line">    [self.containerView addSubview:face];</div><div class="line">    //center the face view within the container</div><div class="line">    CGSize containerSize = self.containerView.bounds.size;</div><div class="line">    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div><div class="line">    // apply the transform</div><div class="line">    face.layer.transform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //set up the container sublayer transform</div><div class="line">    CATransform3D perspective = CATransform3DIdentity;</div><div class="line">    perspective.m34 = -1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = perspective;</div><div class="line">    //add cube face 1</div><div class="line">    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);</div><div class="line">    [self addFace:0 withTransform:transform];</div><div class="line">    //add cube face 2</div><div class="line">    transform = CATransform3DMakeTranslation(100, 0, 0);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);</div><div class="line">    [self addFace:1 withTransform:transform];</div><div class="line">    //add cube face 3</div><div class="line">    transform = CATransform3DMakeTranslation(0, -100, 0);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);</div><div class="line">    [self addFace:2 withTransform:transform];</div><div class="line">    //add cube face 4</div><div class="line">    transform = CATransform3DMakeTranslation(0, 100, 0);</div><div class="line">    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);</div><div class="line">    [self addFace:3 withTransform:transform];</div><div class="line">    //add cube face 5</div><div class="line">    transform = CATransform3DMakeTranslation(-100, 0, 0);</div><div class="line">    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);</div><div class="line">    [self addFace:4 withTransform:transform];</div><div class="line">    //add cube face 6</div><div class="line">    transform = CATransform3DMakeTranslation(0, 0, -100);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);</div><div class="line">    [self addFace:5 withTransform:transform];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-27336b3a305d88a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="520.png"></p>
<p>从这个角度看立方体并不是很明显；看起来只是一个方块，为了更好地欣赏它，我们将更换一个不同的视角。</p>
<p>旋转这个立方体将会显得很笨重，因为我们要单独对每个面做旋转。另一个简单的方案是通过调整容器视图的sublayerTransform去旋转照相机。添加如下几行去旋转containerView图层的perspective变换矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0); </div><div class="line">perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);</div></pre></td></tr></table></figure></p>
<p>这就对相机（或者相对相机的整个场景，你也可以这么认为）绕Y轴旋转45度，并且绕X轴旋转45度。现在从另一个角度去观察立方体，就能看出它的真实面貌（图5.21）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-358730cc31f8063f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.21.png"><br><strong>光亮和阴影</strong></p>
<p>现在它看起来更像是一个立方体没错了，但是对每个面之间的连接还是很难分辨。Core Animation可以用3D显示图层，但是它对光线并没有概念。如果想让立方体看起来更加真实，需要自己做一个阴影效果。你可以通过改变每个面的背景颜色或者直接用带光亮效果的图片来调整。</p>
<p>如果需要动态地创建光线效果，你可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层，但为了计算阴影图层的不透明度，你需要得到每个面的正太向量（垂直于表面的向量），然后根据一个想象的光源计算出两个向量叉乘结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。</p>
<p>清单5.10实现了这样一个结果，我们用GLKit框架来做向量的计算（你需要引入GLKit库来运行代码），每个面的CATransform3D都被转换成GLKMatrix4，然后通过GLKMatrix4GetMatrix3函数得出一个3×3的旋转矩阵。这个旋转矩阵指定了图层的方向，然后可以用它来得到正太向量的值。结果如图5.22所示，试着调整LIGHT_DIRECTION和AMBIENT_LIGHT的值来切换光线效果</p>
<p>#####清单5.10 对立方体的表面应用动态的光线效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &lt;GLKit/GLKit.h&gt;</div><div class="line">    </div><div class="line">#define LIGHT_DIRECTION 0, 1, -0.5</div><div class="line">#define AMBIENT_LIGHT 0.5</div><div class="line">    </div><div class="line">    @interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)applyLightingToFace:(CALayer *)face</div><div class="line">    &#123;</div><div class="line">        //add lighting layer</div><div class="line">        CALayer *layer = [CALayer layer];</div><div class="line">        layer.frame = face.bounds;</div><div class="line">        [face addSublayer:layer];</div><div class="line">        //convert the face transform to matrix</div><div class="line">        //(GLKMatrix4 has the same structure as CATransform3D)</div><div class="line">        //译者注：GLKMatrix4和CATransform3D内存结构一致，但坐标类型有长度区别，所以理论上应该做一次float到CGFloat的转换，感谢[@zihuyishi](https://github.com/zihuyishi)同学~</div><div class="line">        CATransform3D transform = face.transform;</div><div class="line">        GLKMatrix4 matrix4 = *(GLKMatrix4 *)&amp;transform;</div><div class="line">        GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);</div><div class="line">        //get face normal</div><div class="line">        GLKVector3 normal = GLKVector3Make(0, 0, 1);</div><div class="line">        normal = GLKMatrix3MultiplyVector3(matrix3, normal);</div><div class="line">        normal = GLKVector3Normalize(normal);</div><div class="line">        //get dot product with light direction</div><div class="line">        GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));</div><div class="line">        float dotProduct = GLKVector3DotProduct(light, normal);</div><div class="line">        //set lighting layer opacity</div><div class="line">        CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;</div><div class="line">        UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];</div><div class="line">        layer.backgroundColor = color.CGColor;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform</div><div class="line">    &#123;</div><div class="line">        //get the face view and add it to the container</div><div class="line">        UIView *face = self.faces[index];</div><div class="line">        [self.containerView addSubview:face];</div><div class="line">        //center the face view within the container</div><div class="line">        CGSize containerSize = self.containerView.bounds.size;</div><div class="line">        face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div><div class="line">        // apply the transform</div><div class="line">        face.layer.transform = transform;</div><div class="line">        //apply lighting</div><div class="line">        [self applyLightingToFace:face.layer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //set up the container sublayer transform</div><div class="line">        CATransform3D perspective = CATransform3DIdentity;</div><div class="line">        perspective.m34 = -1.0 / 500.0;</div><div class="line">        perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);</div><div class="line">        perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);</div><div class="line">        self.containerView.layer.sublayerTransform = perspective;</div><div class="line">        //add cube face 1</div><div class="line">        CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);</div><div class="line">        [self addFace:0 withTransform:transform];</div><div class="line">        //add cube face 2</div><div class="line">        transform = CATransform3DMakeTranslation(100, 0, 0);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);</div><div class="line">        [self addFace:1 withTransform:transform];</div><div class="line">        //add cube face 3</div><div class="line">        transform = CATransform3DMakeTranslation(0, -100, 0);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);</div><div class="line">        [self addFace:2 withTransform:transform];</div><div class="line">        //add cube face 4</div><div class="line">        transform = CATransform3DMakeTranslation(0, 100, 0);</div><div class="line">        transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);</div><div class="line">        [self addFace:3 withTransform:transform];</div><div class="line">        //add cube face 5</div><div class="line">        transform = CATransform3DMakeTranslation(-100, 0, 0);</div><div class="line">        transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);</div><div class="line">        [self addFace:4 withTransform:transform];</div><div class="line">        //add cube face 6</div><div class="line">        transform = CATransform3DMakeTranslation(0, 0, -100);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);</div><div class="line">        [self addFace:5 withTransform:transform];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-5326f4bc4b613368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.22.png"></p>
<p><strong>点击事件</strong></p>
<p>你应该能注意到现在可以在第三个表面的顶部看见按钮了，点击它，什么都没发生，为什么呢？</p>
<p>这并不是因为iOS在3D场景下正确地处理响应事件，实际上是可以做到的。问题在于视图顺序。在第三章中我们简要提到过，点击事件的处理由视图在父视图中的顺序决定的，并不是3D空间中的Z轴顺序。当给立方体添加视图的时候，我们实际上是按照一个顺序添加，所以按照视图/图层顺序来说，4，5，6在3的前面。</p>
<p>即使我们看不见4，5，6的表面（因为被1，2，3遮了），iOS在事件响应上仍然保持之前的顺序。当试图点击表面3上的按钮，表面4，5，6截断了点击事件（取决于点击的位置），这就和普通的2D布局在按钮上覆盖物体一样。</p>
<p>你也许认为把doubleSided设置成NO可以解决这个问题，因为它不再渲染视图后面的内容，但实际上并不起作用。因为背对相机而隐藏的视图仍然会响应点击事件（这和通过设置hidden<br>属性或者设置alpha为0而隐藏的视图不同，那两种方式将不会响应事件）。所以即使禁止了双面渲染仍然不能解决这个问题（虽然由于性能问题，还是需要把它设置成NO）。</p>
<p>这里有几种正确的方案：把除了表面3的其他视图userInteractionEnabled属性都设置成NO来禁止事件传递。或者简单通过代码把视图3覆盖在视图6上。无论怎样都可以点击按钮了（图5.23）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-589bc9df2efcabfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.23.png"></p>
<p>#####总结<br> 这一章涉及了一些2D和3D的变换。你学习了一些矩阵计算的基础，以及如何用Core Animation创建3D场景。你看到了图层背后到底是如何呈现的，并且知道了不能把扁平的图片做成真实的立体效果，最后我们用demo说明了触摸事件的处理，视图中图层添加的层级顺序会比屏幕上显示的顺序更有意义。</p>
<p>第六章我们会研究一些Core Animation提供不同功能的具体的CALayer子类</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/06/-Swift之集合类型-(Collection-Types)（集合篇）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/06/-Swift之集合类型-(Collection-Types)（集合篇）/" itemprop="url">Swift之集合类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-06T20:19:36+08:00">
                2016-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>集合(Sets)</p>
</blockquote>
<p> 集合(Set)用来存储相同类型并且没有确定顺序的值。当 合元素顺序不重要时或者希望确保每个元素只出现一次 时可以使用 合而不是数组。<br><code>注意:Swift的 Set 类型被桥接到 Foundation 中的 NSSet 类。</code></p>
<p> 集合类型的哈希值<br>一个类型为了存储在 集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希 值。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如 <code>a==b</code>,因此必须 <code>a.hashValue == b.hashValu e</code>。</p>
<p><code>Swift</code>的所有基本类型(比如 <code>String</code>,<code>Int</code> , <code>Double</code> 和 <code>Bool</code>)默认都是可哈希化的，可以作为 合的值的类型或 者字典的键的类型。没有关联值的枚举成员值(在枚举有讲述)默认也是可哈希化的。</p>
<p><strong>合类型语法</strong></p>
<p><code>Swift</code> 中的 <code>Set</code> 类型被写为<code>Set&lt;Element&gt;</code> ，这里的 <code>Element</code> 表示 <code>Set</code>中允许存储的类型，和数组不同的是，  合没有等价的简化形式。</p>
<p><strong>创建和构造一个空的 集合</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var letters = Set&lt;Character&gt;()</div><div class="line">print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;) // 打印 &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot;</div></pre></td></tr></table></figure>
<p><code>注意:通过构造器，这里的 letters 变量的类型被推断为 Set&lt;Character&gt; 。</code></p>
<p>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数 组字面量创建一个空的 <code>Set</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">letters.insert(&quot;a&quot;)</div><div class="line">// letters 现在含有1个 Character 类型的值</div><div class="line">letters = []</div><div class="line">// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型</div></pre></td></tr></table></figure>
<p><strong>用数组字面量创建集合</strong></p>
<p>你可以使用数组字面量来构造 合，并且可以使用简化形式写一个或者多个值作为 合元素。<br>下面的例子创建一个称之为<code>favoriteGenres</code> 的 合来存储 <code>String</code>类型的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;] </div><div class="line">// favoriteGenres 被构造成含有三个初始值的 集合</div></pre></td></tr></table></figure></p>
<p>这个<code>favoriteGenres</code>变量被声明为“一个 <code>String</code>值的 合”，写为 <code>Set&lt;String&gt;</code>。由于这个特定的 合含有指 定 <code>String</code> 类型的值，所以它只允许存储 <code>String</code>类型值。这里的 <code>favoriteGenres</code>变量有三个 String 类型的初始 值(<code>&quot;Rock&quot;</code> ，<code>&quot;Classical&quot;</code> 和 <code>&quot;Hip hop&quot;</code> )，并以数组字面量的方式出现。</p>
<p><code>注意:
favoriteGenres 被声明为一个变量(拥有 var 标示符)而不是一个常量(拥有 let 标示符),因为它里面的元素将 会在下面的例子中被增加或者移除。</code></p>
<p>一个 <code>Set</code> 类型不能从数组字面量中被单独推断出来，因此<code>Set</code> 类型必须显式声明。然而，由于 <code>Swift</code> 的类型推 断功能，如果你想使用一个数组字面量构造一个<code>Set</code> 并且该数组字面量中的所有元素类型相同，那么你无须写出<br><code>Set</code> 的具体类型。 <code>favoriteGenres</code> 的构造形式可以采用简化的方式代替:</p>
<p><code>var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</code></p>
<p>由于数组字面量中的所有元素类型相同，<code>Swift</code>可以推断出 <code>Set&lt;String&gt;</code> 作为 <code>favoriteGenres</code>变量的正确类型。</p>
<p><strong>访问和修改一个集合</strong><br>你可以通过 <code>Set</code> 的属性和方法来访问和修改一个 <code>Set</code> 。</p>
<p>为了找出一个<code>Set</code> 中元素的数量，可以使用其只读属性<code>count</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(&quot;I have \(favoriteGenres.count) favorite music genres.&quot;) // 打印 &quot;I have 3 favorite music genres.</div></pre></td></tr></table></figure>
<p>使用布尔属性 <code>isEmpty</code>作为一个缩写形式去检查 <code>count</code>属性是否为 <code>0</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> if favoriteGenres.isEmpty &#123;</div><div class="line">     print(&quot;As far as music goes, I&apos;m not picky.&quot;)</div><div class="line"> &#125; else &#123;</div><div class="line">     print(&quot;I have particular music preferences.&quot;)</div><div class="line">&#125;</div><div class="line">// 打印 &quot;I have particular music preferences.&quot;</div></pre></td></tr></table></figure>
<p>你可以通过调用 <code>Set</code> 的 <code>insert(_:)</code>方法来添加一个新元素:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">favoriteGenres.insert(&quot;Jazz&quot;)</div><div class="line">// favoriteGenres 现在包含4个元素</div></pre></td></tr></table></figure></p>
<p>你可以通过调用 <code>Set</code> 的 <code>remove(_:)</code>方法去删除一个元素，如果该值是该 <code>Set</code>的一个元素则删除该元素并且返回 被删除的元素值，否则如果该<code>Set</code> 不包含该值，则返回 <code>nil</code> 。另外， <code>Set</code> 中的所有元素可以通过它的<code>removeAl l()</code>方法删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> if let removedGenre = favoriteGenres.remove(&quot;Rock&quot;) &#123;</div><div class="line">     print(&quot;\(removedGenre)? I&apos;m over it.&quot;)</div><div class="line"> &#125; else &#123;</div><div class="line">     print(&quot;I never much cared for that.&quot;)</div><div class="line">&#125;</div><div class="line">// 打印 &quot;Rock? I&apos;m over it.&quot;</div></pre></td></tr></table></figure>
<p>使用<code>contains(_:)</code> 方法去检查<code>Set</code> 中是否包含一个特定的值:</p>
<p><strong>遍历一个集合</strong></p>
<p>你可以在一个<code>for-in</code>循环中遍历一个 <code>Set</code>中的所有值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for genre in favoriteGenres &#123;</div><div class="line">    print(&quot;\(genre)&quot;)</div><div class="line">&#125;</div><div class="line">// Classical</div><div class="line">// Jazz</div><div class="line">// Hip hop</div></pre></td></tr></table></figure>
<p><code>Swift</code>的 <code>Set</code>类型没有确定的顺序，为了按照特定顺序来遍历一个 <code>Set</code> 中的值可以使用 <code>sorted()</code> 方法，它将返<br>回一个有序数组，这个数组的元素排列顺序由操作符<code>&#39;&lt;&#39;</code>对元素进行比较的结果来确定.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for genre in favoriteGenres.sorted() &#123;</div><div class="line">    print(&quot;(genre)&quot;)</div><div class="line">&#125;</div><div class="line">// prints &quot;Classical&quot;</div><div class="line">// prints &quot;Hip hop&quot;</div><div class="line">// prints &quot;Jazz</div></pre></td></tr></table></figure>
<blockquote>
<p>集合操作</p>
</blockquote>
<p>你可以高效地完成 Set 的一些基本操作，比如把两个 集合组合到一起，判断两个 合共有元素，或者判断两个  集合是否全包含，部分包含或者不相交。</p>
<p><strong>基本集合操作</strong><br>• 使用 intersection(<em>:) 方法根据两个 合中都包含的值创建的一个新的 集合。<br>• 使用 symmetricDifference(</em>:) 方法根据在一个 集合中但不在两个 合中的值创建一个新的 集合。 • 使用 union(<em>:) 方法根据两个集合的值创建一个新的集 合。<br>• 使用 subtracting(</em>:) 方法根据不在该 合中的值创建一个新的 集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let oddDigits: Set = [1, 3, 5, 7, 9]</div><div class="line">let evenDigits: Set = [0, 2, 4, 6, 8]</div><div class="line">let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]</div><div class="line">oddDigits.union(evenDigits).sort()</div><div class="line">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">oddDigits. intersection(evenDigits).sorted()</div><div class="line">// []</div><div class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()</div><div class="line">// [1, 9]  以 singleDigitPrimeNumbers集合为标准，取出oddDigits集合中不在singleDigitPrimeNumbers的值</div><div class="line">oddDigits. symmetricDifference(singleDigitPrimeNumbers).sorted()</div><div class="line">// [1, 2, 9] 取出两个集合的并集去掉交集的集合</div></pre></td></tr></table></figure>
<p><strong>集合成员关系和相等</strong></p>
<p>• 使用“是否相等”运算符( == )来判断两个 集合是否包含全部相同的值。<br>• 使用 isSubset(of:) 方法来判断一个集 合中的值是否也被包含在另外一个 合中。<br>• 使用 isSuperset(of:) 方法来判断一个 集合中包含另一个集合中所有的值。<br>• 使用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法来判断一个 合是否是另外一个集 合的子集 合或 者父集 合并且两个集 合并不相等。<br>• 使用 isDisjoint(with:) 方法来判断两个集 合是否不含有相同的值(是否没有交集)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let houseAnimals: Set = [&quot;?&quot;, &quot;?&quot;]</div><div class="line">let farmAnimals: Set = [&quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;]</div><div class="line">let cityAnimals: Set = [&quot;?&quot;, &quot;?&quot;]</div><div class="line">houseAnimals.isSubset(of: farmAnimals)</div><div class="line">// true</div><div class="line">farmAnimals.isSuperset(of: houseAnimals)</div><div class="line">// true</div><div class="line">farmAnimals.isDisjoint(with: cityAnimals)</div><div class="line">// true</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/06/CoreAnimation之贝塞尔曲线（加入购物车动画）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/06/CoreAnimation之贝塞尔曲线（加入购物车动画）/" itemprop="url">CoreAnimation之贝塞尔曲线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-06T20:19:35+08:00">
                2016-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1694376-c32df5200c40e600.gif?imageMogr2/auto-orient/strip" alt="12.gif"></p>
<blockquote>
<p><strong>加入购物车这个动画关键是贝塞尔曲线的绘制，然后给购物车加上一个关键帧动画即可。</strong></p>
</blockquote>
<p>贝塞尔曲线的起点从cell 中button开始，到购物车位置结束，控制点取 起点的纵坐标，终点的横坐标。<br>因为不在一个坐标系内，所以我们需要转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;</div><div class="line">- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;</div><div class="line">- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;</div><div class="line">- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;</div></pre></td></tr></table></figure></p>
<p><strong>在这里我们把购物车以及 cell 上的加入购物车按钮 全部转换到selv.view上（ps:本来想把购物车的中心点转化到tableview，上，把动画封装在cell的button 点击事件里，可是失败了， 代理方法会走，但是没有动画效果😢）</strong></p>
<blockquote>
<p>cell 中的回调处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[self layoutIfNeeded];//xib初始化，需要获得正确的frame</div><div class="line">   </div><div class="line">   CGPoint carButtonCenter = sender.center;</div><div class="line">   </div><div class="line">   //把button在cell坐标转化为在tableView上的坐标</div><div class="line">   CGPoint point = [self convertPoint:carButtonCenter toView:self.superview.superview];</div><div class="line">   </div><div class="line">   //回调</div><div class="line">   if (_shoppingButtonBlock)</div><div class="line">   &#123;</div><div class="line">       _shoppingButtonBlock(point);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>viewcontroller中的处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    MyCell *cell =[tableView dequeueReusableCellWithIdentifier:cellId];</div><div class="line">    if (!cell) &#123;</div><div class="line">        cell =[[MyCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    __weak ViewController *weakSelf = self;</div><div class="line">    [cell setShoppingButtonBlock:^(CGPoint centerPoint) &#123;</div><div class="line">        //关键帧动画处理</div><div class="line">        [weakSelf startAnimate:centerPoint];</div><div class="line">    &#125;];</div><div class="line">   </div><div class="line">    return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以把CAShapeLayer去掉，只是为了直观的看到动画效果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimate:(CGPoint)centerPoint</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    CGPoint startPoint = [self.tableview convertPoint:centerPoint toView:self.view];;</div><div class="line">    CGPoint endpoint = self.shopView.center;</div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(endpoint.x, startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:startPoint];</div><div class="line">    [path addQuadCurveToPoint:endpoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [self.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    </div><div class="line">    [self.shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>还是将动画抽取出来，只需要起点和终点以及动画宿主视图,实现解耦。</p>
</blockquote>
<p>定义一个NSObject类，接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@interface AddToShopAnimation : NSObject</div><div class="line">-(instancetype)initWithStartPoint:(CGPoint)startPoint entPoint:(CGPoint)endPoint ViewController:(UIViewController *)viewController HostView:(UIView *)shopView;</div><div class="line">-(void)startAnimation;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimation</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    </div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(_endPoint.x, _startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:_startPoint];</div><div class="line">    [path addQuadCurveToPoint:_endPoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [_viewController.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    [_shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>demo地址：<a href="https://github.com/liuxinixn/UIBezierPathAddtoShop" target="_blank" rel="noopener">贝塞尔曲线之加入购物车</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/06/ios-两种方式扩大button点击范围/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/06/ios-两种方式扩大button点击范围/" itemprop="url">iOS -两种方式扩大button的点击范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-06T20:19:35+08:00">
                2016-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UI给的图有时候很小，或者有个需求需要我们扩大button的点击区域， 我们一般的操作是在button 上添加一个view 增加点击事件，但是我们还有其他更方便的方法去扩大button 的点击区域。有需要可以了解下事件的分发机制。<br>有两种方式扩大button 的点击区域：</p>
<blockquote>
<p>第一种：重写方法     -(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event</p>
</blockquote>
<p>继承与UIButton，实现如下效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event</div><div class="line">&#123;</div><div class="line">    CGRect bounds = self.bounds;</div><div class="line">    //扩大原热区直径至26，可以暴露个接口，用来设置需要扩大的半径。</div><div class="line">    CGFloat widthDelta = MAX(26, 0);</div><div class="line">    CGFloat heightDelta = MAX(26, 0);</div><div class="line">    bounds = CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta);</div><div class="line">    return CGRectContainsPoint(bounds, point);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>第二种： 重写方法  - (UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    CGRect rectBig = CGRectInset(self.bounds, -(27.0/2), -(27.0/2));</div><div class="line">    </div><div class="line">    if (CGRectContainsPoint(rectBig, point)) &#123;</div><div class="line">        return self;</div><div class="line">    &#125;else&#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>######其实我们上面所做的变化其实如果仔细看点击区域还是个矩形，如果需要我们将点击区域规定在圆形范围 内，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</div><div class="line">    [super hitTest:point withEvent:event];</div><div class="line">    </div><div class="line">    CGPoint center = CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2);</div><div class="line">    </div><div class="line">    </div><div class="line">   //当然这个半径也可以扩大</div><div class="line">    CGFloat raidus = self.frame.size.height &gt;= self.frame.size.width ?self.frame.size.width/2 :self.frame.size.width/2;</div><div class="line">    </div><div class="line">   //传入中心点 实时点击点 与半径判断 点击点是否在半径区域内</div><div class="line">    BOOL pointInRound =[self touchPointInsideCircle:center radius:raidus targetPoint:point];</div><div class="line">    </div><div class="line">    if (pointInRound) &#123;</div><div class="line">        return self;</div><div class="line">    &#125;else</div><div class="line">    &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//用来判断 圆形点击区域</div><div class="line">- (BOOL)touchPointInsideCircle:(CGPoint)center radius:(CGFloat)radius targetPoint:(CGPoint)point</div><div class="line">&#123;</div><div class="line">    CGFloat dist = sqrtf((point.x - center.x) * (point.x - center.x) +</div><div class="line">                         (point.y - center.y) * (point.y - center.y));</div><div class="line">    return (dist &lt;= radius);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/05/CoreAnimation图层几何学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/05/CoreAnimation图层几何学/" itemprop="url">CoreAnimation图层几何学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-05T20:19:35+08:00">
                2016-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<ul>
<li>####<strong>布局</strong></li>
</ul>
<p> UIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p>frame代表了图层的外部坐标（也就是在父图层上占据的空间），bounds是内部坐标（{0, 0}通常是图层的左上角），center和position都代表了相对于父图层anchorPoint所在的位置。anchorPoint的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-60c2a6313ce9cad9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.1.png"></p>
<p>视图的frame，bounds和center属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的frame<br>，不能够独立于图层之外改变视图的frame。</p>
<p>对于视图或者图层来说，frame并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据bounds，position和transform<br>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了（图3.2）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-962d369cf221fcfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2.png"></p>
<ul>
<li>####<strong>锚点</strong></li>
</ul>
<p>之前提到过，视图的center属性和图层的position属性都指定了anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame的位置，你可以认为anchorPoint是用来移动图层的把柄。</p>
<p>默认来说，anchorPoint位于图层的中点，所以图层的将会以这个点为中心放置。anchorPoint属性并没有被UIView接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的anchorPoint可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动（图3.3），而不是居中了。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-7827e0f4aceeba78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.3.png"></p>
<p>和第二章提到的contentsRect和contentsCenter属性类似，anchorPoint用单位坐标来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。anchorPoint可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了anchorPoint，position属性保持固定的值并没有发生改变，但是frame却移动了。</p>
<p>那在什么场合需要改变anchorPoint呢？既然我们可以随意改变图层位置，那改变anchorPoint不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个UIImageView<br>实例（当然你也可以用正常的视图，设置他们图层的contents<br>图片）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-2e8b159f0f65cc54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4.png"></p>
<p> 闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的frame，而根据图3.2的演示，当视图旋转的时候，frame是会发生改变的，这将会导致一些布局上的失灵。</p>
<p>我们用NSTimer来更新闹钟，使用视图的transform属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0a145b572f694e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.png"></p>
<p>#####清单3.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *hourHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *secondHand;</div><div class="line">@property (nonatomic, weak) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //start timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">    ￼</div><div class="line">    //set initial hand positions</div><div class="line">    [self tick];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tick</div><div class="line">&#123;</div><div class="line">    //convert time to hours, minutes and seconds</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">    //calculate hour hand angle //calculate minute hand angle</div><div class="line">    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">    //calculate second hand angle</div><div class="line">    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">    //rotate hands</div><div class="line">    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);</div><div class="line">    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);</div><div class="line">    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-63fdc55a5c4ba280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.png"><br> 你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>
<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>
<p>更好的方案是使用anchorPoint属性，我们来在-viewDidLoad方法中添加几行代码来给每个钟指针的anchorPoint做一些平移（清单3.2），图3.7显示了正确的结果。</p>
<p>#####清单3.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       // adjust anchor points</div><div class="line">       </div><div class="line">       self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       </div><div class="line">       </div><div class="line">       // start timer</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-73c01bb8b7088a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.7.png"></p>
<ul>
<li>####<strong>坐标系</strong><br>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds<br>，如果父图层发生了移动，它的所有子图层也会跟着移动。</li>
</ul>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的绝对位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。<br>CALayer给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; </div><div class="line">- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; </div><div class="line">- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;</div><div class="line">- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</div></pre></td></tr></table></figure>
<p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>
<ul>
<li>####<strong>翻转的几何结构</strong></li>
</ul>
<p>常规说来，在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES,意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们geometryFlipped<br>属性也设为YES）。</p>
<ul>
<li>####<strong>Z坐标轴</strong></li>
</ul>
<p>和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了我们已经讨论过的position和anchorPoint属性之外，CALayer还有另外两个属性，zPosition和anchorPointZ<br>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>注意这里并没有更深的属性来描述由宽和高做成的bounds<br>了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>
<p>zPosition属性在大多数情况下其实并不常用。在第五章，我们将会涉及CATransform3D，你会知道如何在三维空间移动和旋转图层，除了做变换之外，zPosition最实用的功能就是改变图层的显示顺序了。</p>
<p>通常，图层是根据它们子图层的sublayers<br>出现的顺序来类绘制的，这就是所谓的画家的<a href="http://lib.csdn.net/base/31" target="_blank" rel="noopener">算法</a>–就像一个画家在墙上作画–后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的zPosition，就可以把图层向相机方向前置，于是它就在所有其他图层的前面了（或者至少是小于它的zPosition值的图层的前面）。</p>
<p>这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。</p>
<p>图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-68e4281dd52477ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.8.png"><br>我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的zPosition（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给zPosition提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。</p>
<p>#####清单3.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *greenView;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *redView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       ￼</div><div class="line">       //move the green view zPosition nearer to the camera</div><div class="line">       self.greenView.layer.zPosition = 1.0f;</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-e7ea5f6f69f43a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.9绿色视图被绘制在红色视图的前面.png"></p>
<ul>
<li>####<strong>Hit Testing</strong></li>
</ul>
<p> 第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。</p>
<p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：-containsPoint:和-hitTest:。</p>
<p>-containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用-containsPoint:方法来判断到底是白色还是蓝色的图层被触摸了 （图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>
<p>#####清单3.4 使用containsPoint判断被点击的图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">   @property (nonatomic, weak) CALayer *blueLayer;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //create sublayer</div><div class="line">       self.blueLayer = [CALayer layer];</div><div class="line">       self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">       self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">       //add it to our view</div><div class="line">       [self.layerView.layer addSublayer:self.blueLayer];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">   &#123;</div><div class="line">       //get touch position relative to main view</div><div class="line">       CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">       //convert point to the white layer&apos;s coordinates</div><div class="line">       point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];</div><div class="line">       //get layer using containsPoint:</div><div class="line">       if ([self.layerView.layer containsPoint:point]) &#123;</div><div class="line">           //convert point to blueLayer’s coordinates</div><div class="line">           point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];</div><div class="line">           if ([self.blueLayer containsPoint:point]) &#123;</div><div class="line">               [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                           message:nil</div><div class="line">                                          delegate:nil</div><div class="line">                                 cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                                 otherButtonTitles:nil] show];</div><div class="line">           &#125; else &#123;</div><div class="line">               [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                           message:nil</div><div class="line">                                          delegate:nil</div><div class="line">                                 cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                                 otherButtonTitles:nil] show];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-71820c2c4fb8faac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.10点击图层被正确标识.png"></p>
<p>-hitTest:方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用-containsPoint:那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用-hitTest:方法被点击图层的代码如清单3.5所示。</p>
<p>#####使用hitTest判断被点击的图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //get touch position</div><div class="line">    CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">    //get touched layer</div><div class="line">    CALayer *layer = [self.layerView.layer hitTest:point];</div><div class="line">    //get layer using hitTest</div><div class="line">    if (layer == self.blueLayer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125; else if (layer == self.layerView.layer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 注意当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。</p>
<ul>
<li>####<strong>自动布局属性</strong></li>
</ul>
<p>你可能用过UIViewAutoresizingMask类型的一些常量，应用于当父视图改变尺寸的时候，相应UIView的frame也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了自动排版机制，它和自动调整不同，并且更加复杂。在Mac OS平台，CALayer有一个叫做layoutManager的属性可以通过CALayoutManager协议和CAConstraintLayoutManager类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraintAPI，但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数：<br><code>- (void)layoutSublayersOfLayer:(CALayer *)layer;</code></p>
<p>#####总结<br> 本章涉及了CALayer的集合结构，包括它的frame，position和bounds，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/04/CoreAnimation视觉效果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/04/CoreAnimation视觉效果/" itemprop="url">CoreAnimation视觉效果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-04T20:19:35+08:00">
                2016-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>嗯，圆和椭圆还不错，但如果是带圆角的矩形呢<br>我们现在能做到那样了么？<br>史蒂芬·乔布斯</p>
</blockquote>
<p>我们在第三章『图层几何学』中讨论了图层的frame，第二章『寄宿图』则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。</p>
<ul>
<li>####<strong>圆角</strong></li>
</ul>
<p>圆角矩形是<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角举行的方法。恭喜你，猜对了。<br>CALayer有一个叫做conrnerRadius的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把masksToBounds设置成YES的话，图层里面的所有东西都会被截取。</p>
<p>我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-07f645d5d7004552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1.png"></p>
<p>然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果</p>
<p>#####清单4.1 设置cornerRadius和masksToBounds<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;￼￼￼</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //set the corner radius on our layers</div><div class="line">        self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">        self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">        </div><div class="line">        //enable clipping on the second layer</div><div class="line">        self.layerView2.layer.masksToBounds = YES;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-3a0579b2db95b743.png" alt="4.2.png"><br>如你所见，右边的子视图沿边界被裁剪了。<br>单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者CAShapeLayer（见第六章『专用图层』）。</p>
<ul>
<li>####<strong>图层边框</strong></li>
</ul>
<p> CALayer另外两个非常有用属性就是borderWidth和borderColor。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的bounds绘制，同时也包含图层的角。</p>
<p>borderWidth是以点为单位的定义边框粗细的浮点数，默认为0.borderColor定义了边框的颜色，默认为黑色。</p>
<p>borderColor是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了borderColor，虽然属性声明并不能证明这一点。CGColorRef在引用/释放时候的行为表现得与NSObject极其相似。但是Objective-C语法并不支持这一做法，所以CGColorRef属性即便是强引用也只能通过assign关键字来声明。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.</p>
<p>#####清单4.2 加上边框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       </div><div class="line">       //set the corner radius on our layers</div><div class="line">       self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">       self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">       </div><div class="line">       //add a border to our layers</div><div class="line">       self.layerView1.layer.borderWidth = 5.0f;</div><div class="line">       self.layerView2.layer.borderWidth = 5.0f;</div><div class="line">       </div><div class="line">       //enable clipping on the second layer</div><div class="line">       self.layerView2.layer.masksToBounds = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c76368bfcc883724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.3.png"><br>仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-767f323d4a8bcdb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.4.png"></p>
<ul>
<li>####<strong>contentsScale属性</strong></li>
</ul>
<p> iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。</p>
<p>给shadowOpacity属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：shadowColor，shadowOffset和shadowRadius。</p>
<p>显而易见，shadowColor属性控制着阴影的颜色，和borderColor和backgroundColor一样，它的类型也是CGColorRef。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。</p>
<p>shadowOffset属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。shadowOffset的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p>为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，shadowOffset的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-209274f1478b34a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.5.png"></p>
<p>苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。</p>
<p>shadowRadius属性控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。</p>
<p>通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给shadowRadius<br>设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-be8052dd45ee1287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.6.png"></p>
<ul>
<li>####<strong>阴影裁剪</strong></li>
</ul>
<p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-55db4a5ddd630e6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.7.png"></p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d6faa3736b29968d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.8.png"></p>
<p> 从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用masksToBounds裁剪内容的内图层。</p>
<p>如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-4c8e77c6cf05751f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.9.png"></p>
<p>我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。</p>
<p>#####清单4.3 用一个额外的视图来解决阴影裁切的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *shadowView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   ￼</div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       </div><div class="line">       //set the corner radius on our layers</div><div class="line">       self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">       self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">       </div><div class="line">       //add a border to our layers</div><div class="line">       self.layerView1.layer.borderWidth = 5.0f;</div><div class="line">       self.layerView2.layer.borderWidth = 5.0f;</div><div class="line">       </div><div class="line">       //add a shadow to layerView1</div><div class="line">       self.layerView1.layer.shadowOpacity = 0.5f;</div><div class="line">       self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);</div><div class="line">       self.layerView1.layer.shadowRadius = 5.0f;</div><div class="line">       </div><div class="line">       //add same shadow to shadowView (not layerView2)</div><div class="line">       self.shadowView.layer.shadowOpacity = 0.5f;</div><div class="line">       self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);</div><div class="line">       self.shadowView.layer.shadowRadius = 5.0f;</div><div class="line">       </div><div class="line">       //enable clipping on the second layer</div><div class="line">       self.layerView2.layer.masksToBounds = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-fd2670824eb2870b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.10.png"></p>
<ul>
<li><p>####<strong>shadowPath属性</strong></p>
<p>我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</p>
</li>
</ul>
<p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个shadowPath来提高性能。shadowPath是一个CGPathRef类型（一个指向CGPath的指针）。CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</p>
<p>图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。</p>
<p>#####清单4.4 创建简单的阴影形状<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //enable layer shadows</div><div class="line">    self.layerView1.layer.shadowOpacity = 0.5f;</div><div class="line">    self.layerView2.layer.shadowOpacity = 0.5f;</div><div class="line">    </div><div class="line">    //create a square shadow</div><div class="line">    CGMutablePathRef squarePath = CGPathCreateMutable();</div><div class="line">    CGPathAddRect(squarePath, NULL, self.layerView1.bounds);</div><div class="line">    self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);</div><div class="line">    </div><div class="line">    ￼//create a circular shadow</div><div class="line">    CGMutablePathRef circlePath = CGPathCreateMutable();</div><div class="line">    CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);</div><div class="line">    self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-eb06f611b0a94d9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.11.png"></p>
<p>如果是一个矩形或者是圆，用CGPath会相当简单明了。但是如果是更加复杂一点的图形，UIBezierPath类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<ul>
<li>####<strong>图层蒙板</strong></li>
</ul>
<p> 通过masksToBounds属性，我们可以沿边界裁剪图形；通过cornerRadius属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>
<p>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</p>
<p>CALayer有一个属性叫做mask可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，mask图层定义了父图层的部分可见区域。</p>
<p>mask图层的Color属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）</p>
<p>如果mask图层比父图层要小，只有在mask图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-15fab782b87c7c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.12.png"><br>我们将代码演示一下这个过程，创建一个简单的项目，通过图层的mask属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。</p>
<p>#####清单4.5 应用蒙板图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *imageView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //create mask layer</div><div class="line">    CALayer *maskLayer = [CALayer layer];</div><div class="line">    maskLayer.frame = self.layerView.bounds;</div><div class="line">    UIImage *maskImage = [UIImage imageNamed:@&quot;Cone.png&quot;];</div><div class="line">    maskLayer.contents = (__bridge id)maskImage.CGImage;</div><div class="line">    </div><div class="line">    //apply mask to image layer￼</div><div class="line">    self.imageView.layer.mask = maskLayer;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-260195fb443dc625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.13.png"><br>CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为mask属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。</p>
<ul>
<li>####<strong>拉伸过滤</strong></li>
</ul>
<p>最后我们再来谈谈minificationFilter和magnificationFilter<br>属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：</p>
<ul>
<li>能够显示最好的画质，像素既没有被压缩也没有被拉伸。</li>
<li>能更好的使用内存，因为这就是所有你要存储的东西。</li>
<li>最好的性能表现，CPU不需要为此额外的计算。</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。<br>当图片需要显示不同的大小的时候，有一种叫做拉伸过滤的<a href="http://lib.csdn.net/base/31" target="_blank" rel="noopener">算法</a>就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。<br>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。CALayer为此提供了三种拉伸过滤方法，他们是：</p>
<ul>
<li>kCAFilterLinear</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>
<p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。<br>kCAFilterTrilinear和kCAFilterLinear非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-627fcecfb98c98cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.14.png"></p>
<p>kCAFilterNearest是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重<br><img src="http://upload-images.jianshu.io/upload_images/1694376-14ccad89e4e169b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.15.png"></p>
<pre><code>图4.15 对于没有斜线的小图来说，最近过滤算法要好很多
</code></pre><p> 总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。</p>
<p>让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-abd590ea7cc36114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.16.png"></p>
<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个IBOutletCollection对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。</p>
<p>####清单4.6 显示一个LCD风格的时钟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;</div><div class="line">   @property (nonatomic, weak) NSTimer *timer;</div><div class="line">   ￼￼</div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad]; //get spritesheet image</div><div class="line">       UIImage *digits = [UIImage imageNamed:@&quot;Digits.png&quot;];</div><div class="line">       </div><div class="line">       //set up digit views</div><div class="line">       for (UIView *view in self.digitViews) &#123;</div><div class="line">           //set contents</div><div class="line">           view.layer.contents = (__bridge id)digits.CGImage;</div><div class="line">           view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);</div><div class="line">           view.layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       //start timer</div><div class="line">       self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">       </div><div class="line">       //set initial clock time</div><div class="line">       [self tick];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)setDigit:(NSInteger)digit forView:(UIView *)view</div><div class="line">   &#123;</div><div class="line">       //adjust contentsRect to select correct digit</div><div class="line">       view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)tick</div><div class="line">   &#123;</div><div class="line">       //convert time to hours, minutes and seconds</div><div class="line">       NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];</div><div class="line">       NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">       ￼</div><div class="line">       NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">       </div><div class="line">       //set hours</div><div class="line">       [self setDigit:components.hour / 10 forView:self.digitViews[0]];</div><div class="line">       [self setDigit:components.hour % 10 forView:self.digitViews[1]];</div><div class="line">       </div><div class="line">       //set minutes</div><div class="line">       [self setDigit:components.minute / 10 forView:self.digitViews[2]];</div><div class="line">       [self setDigit:components.minute % 10 forView:self.digitViews[3]];</div><div class="line">       </div><div class="line">       //set seconds</div><div class="line">       [self setDigit:components.second / 10 forView:self.digitViews[4]];</div><div class="line">       [self setDigit:components.second % 10 forView:self.digitViews[5]];</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-7dbef1a2760e625b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.18.png"></p>
<p>为了能像图4.19中那样，我们需要在for循环中加入如下代码：<br><code>view.layer.magnificationFilter = kCAFilterNearest;</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-43f21dbace80a1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.19.png"></p>
<ul>
<li>####<strong>组透明</strong></li>
</ul>
<p> UIView有一个叫做alpha的属性来确定视图的透明度。CALayer有一个等同的属性叫做opacity，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
<p>iOS常见的做法是把一个空间的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-8828828bb87444dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.20.png"></p>
<p> 这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>
<p>在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。</p>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的UIViewGroupOpacity为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果UIViewGroupOpacity并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。</p>
<p>另一个方法就是，你可以设置CALayer的一个叫做shouldRasterize属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。</p>
<p>为了启用shouldRasterize属性，我们设置了图层的rasterizationScale属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了shouldRasterize属性，你就要确保你设置了rasterizationScale属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>
<p>当shouldRasterize和UIViewGroupOpacity一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。</p>
<p>#####清单4.7 使用shouldRasterize属性解决组透明问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">    @interface ViewController ()</div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (UIButton *)customButton</div><div class="line">    &#123;</div><div class="line">        //create button</div><div class="line">        CGRect frame = CGRectMake(0, 0, 150, 50);</div><div class="line">        UIButton *button = [[UIButton alloc] initWithFrame:frame];</div><div class="line">        button.backgroundColor = [UIColor whiteColor];</div><div class="line">        button.layer.cornerRadius = 10;</div><div class="line">        </div><div class="line">        //add label</div><div class="line">        frame = CGRectMake(20, 10, 110, 30);</div><div class="line">        UILabel *label = [[UILabel alloc] initWithFrame:frame];</div><div class="line">        label.text = @&quot;Hello World&quot;;</div><div class="line">        label.textAlignment = NSTextAlignmentCenter;</div><div class="line">        [button addSubview:label];</div><div class="line">        return button;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //create opaque button</div><div class="line">        UIButton *button1 = [self customButton];</div><div class="line">        button1.center = CGPointMake(50, 150);</div><div class="line">        [self.containerView addSubview:button1];</div><div class="line">        </div><div class="line">        //create translucent button</div><div class="line">        UIButton *button2 = [self customButton];</div><div class="line">        ￼</div><div class="line">        button2.center = CGPointMake(250, 150);</div><div class="line">        button2.alpha = 0.5;</div><div class="line">        [self.containerView addSubview:button2];</div><div class="line">        </div><div class="line">        //enable rasterization for the translucent button</div><div class="line">        button2.layer.shouldRasterize = YES;</div><div class="line">        button2.layer.rasterizationScale = [UIScreen mainScreen].scale;</div><div class="line">    &#125;</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-006797526c30dcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.21.png"></p>
<p>#####总结<br> 这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。</p>
<p>在第五章，『变换』中，我们将会研究图层变化和3D转换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/03/CoreAnimation框架目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/03/CoreAnimation框架目录/" itemprop="url">CoreAnimation框架目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-03T20:19:35+08:00">
                2016-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目录纵览"><a href="#目录纵览" class="headerlink" title="目录纵览"></a>目录纵览</h1><h4 id="第一章：图层树"><a href="#第一章：图层树" class="headerlink" title="第一章：图层树"></a>第一章：图层树</h4><ul>
<li>图层与视图</li>
<li>图层的能力</li>
<li>使用图层<br>总结 链接：<a href="http://www.jianshu.com/p/8447e0c24df1" target="_blank" rel="noopener">图层树</a><h4 id="第二章：寄宿图"><a href="#第二章：寄宿图" class="headerlink" title="第二章：寄宿图"></a>第二章：寄宿图</h4></li>
<li>contents属性</li>
<li>Custom Drawing （自定义绘制）<br>总结 链接：<a href="http://www.jianshu.com/p/fea670e92e9e" target="_blank" rel="noopener">寄宿图</a><h4 id="第三章：图层几何学"><a href="#第三章：图层几何学" class="headerlink" title="第三章：图层几何学"></a>第三章：图层几何学</h4></li>
<li>布局</li>
<li><a href="http://www.jianshu.com/p/52dfc061ff7f" target="_blank" rel="noopener">锚点</a></li>
<li>坐标系</li>
<li>Hit Testing</li>
<li>自动布局<br>总结 链接：<a href="http://www.jianshu.com/p/ffee86d98d58" target="_blank" rel="noopener">图层几何学</a><h4 id="第五章：视觉效果"><a href="#第五章：视觉效果" class="headerlink" title="第五章：视觉效果"></a>第五章：视觉效果</h4></li>
<li>圆角</li>
<li>图层边框</li>
<li>阴影</li>
<li><a href="http://www.jianshu.com/p/26e7803f057b" target="_blank" rel="noopener">图层蒙版</a></li>
<li>拉伸过滤</li>
<li>组透明<br>总结 链接：<a href="http://www.jianshu.com/p/b556af4a3c7d" target="_blank" rel="noopener">视觉效果</a></li>
</ul>
<h4 id="第五章：变换"><a href="#第五章：变换" class="headerlink" title="第五章：变换"></a>第五章：变换</h4><ul>
<li>仿射变换</li>
<li>图层边框</li>
<li>3D对象</li>
<li>固体对象<br>总结 链接：<a href="http://www.jianshu.com/p/ff380a2658fa" target="_blank" rel="noopener">变换</a><h4 id="第六章：专用图层"><a href="#第六章：专用图层" class="headerlink" title="第六章：专用图层"></a>第六章：专用图层</h4></li>
<li><a href="http://www.jianshu.com/p/16fd028ee636" target="_blank" rel="noopener">CAShapeLayer</a></li>
<li>CATextLayer</li>
<li>CATransformLayer</li>
<li><a href="http://www.jianshu.com/p/0e0ff206f110" target="_blank" rel="noopener">CAReplicatorLayer</a></li>
<li>CAScrollLayer</li>
<li><a href="http://www.jianshu.com/p/03095391e301" target="_blank" rel="noopener">CAEmitterLayer</a></li>
<li>CAEAGLLayer</li>
<li>AVPlayerLayer<br>总结 链接：<a href="http://www.jianshu.com/p/826e593d82b6" target="_blank" rel="noopener">专用图层</a><h4 id="第七章：隐式动画"><a href="#第七章：隐式动画" class="headerlink" title="第七章：隐式动画"></a>第七章：隐式动画</h4></li>
<li>事务</li>
<li>完成块</li>
<li>图层行为</li>
<li>呈现与模型<br>总结 链接：<a href="http://www.jianshu.com/p/0e082382a612" target="_blank" rel="noopener">隐式动画</a><h4 id="第八章：显式动画"><a href="#第八章：显式动画" class="headerlink" title="第八章：显式动画"></a>第八章：显式动画</h4></li>
<li><a href="http://www.jianshu.com/p/73f87913c18d" target="_blank" rel="noopener">属性动画</a></li>
<li>动画组</li>
<li>过渡</li>
<li>在动画过程中取消动画<br>总结 链接：<a href="http://www.jianshu.com/p/1e1364839b20" target="_blank" rel="noopener">显式动画</a><h4 id="第九章：图层时间"><a href="#第九章：图层时间" class="headerlink" title="第九章：图层时间"></a>第九章：图层时间</h4></li>
<li>CAMediaTiming 协议</li>
<li>层级关系时间</li>
<li>手动动画<br>总结 链接：<a href="http://www.jianshu.com/p/7bfe1ef1fb5b" target="_blank" rel="noopener">图层时间</a><h4 id="第十章：缓冲"><a href="#第十章：缓冲" class="headerlink" title="第十章：缓冲"></a>第十章：缓冲</h4></li>
<li>动画速度</li>
<li>自定义缓冲函数<br>总结 链接：<a href="http://www.jianshu.com/p/39d1f739e2c9" target="_blank" rel="noopener">缓冲</a><h4 id="第十一章：基于定时器的动画"><a href="#第十一章：基于定时器的动画" class="headerlink" title="第十一章：基于定时器的动画"></a>第十一章：基于定时器的动画</h4></li>
<li>定时帧</li>
<li>物理模拟<br>总结 链接：<a href="http://www.jianshu.com/p/761bece1c5a6" target="_blank" rel="noopener">基于定时器的动画</a><h4 id="第十二章：性能调优"><a href="#第十二章：性能调优" class="headerlink" title="第十二章：性能调优"></a>第十二章：性能调优</h4></li>
<li>CPU VS GPU</li>
<li>测量，而不是猜测</li>
<li>Instruments<br>总结 链接：<a href="http://www.jianshu.com/p/8874ec25c302" target="_blank" rel="noopener">性能调优</a><h4 id="第十三章：高效绘图"><a href="#第十三章：高效绘图" class="headerlink" title="第十三章：高效绘图"></a>第十三章：高效绘图</h4></li>
<li>软件绘图</li>
<li>矢量图形</li>
<li>脏矩形</li>
<li>异步绘制<br>总结 链接：<a href="http://www.jianshu.com/p/974eb333020a" target="_blank" rel="noopener">高效绘图</a><h4 id="第十四章：图像IO"><a href="#第十四章：图像IO" class="headerlink" title="第十四章：图像IO"></a>第十四章：图像IO</h4></li>
<li>加载和潜伏</li>
<li>缓存</li>
<li>文件格式<br>总结 链接：<a href="http://www.jianshu.com/p/1cb402c1bbba" target="_blank" rel="noopener">图像IO</a><h4 id="第十五章：图层性能"><a href="#第十五章：图层性能" class="headerlink" title="第十五章：图层性能"></a>第十五章：图层性能</h4></li>
<li>隐式绘制</li>
<li>离屏渲染</li>
<li>混合和过渡绘制</li>
<li>减少和过渡绘制<br>总结</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/02/CoreAnimation寄宿图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/02/CoreAnimation寄宿图/" itemprop="url">CoreAnimation寄宿图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-02T20:19:35+08:00">
                2016-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>###寄宿图</p>
</blockquote>
<p>我们在第一章『图层树』中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。</p>
<ul>
<li>####<strong>contents属性</strong></li>
</ul>
<p>CALayer 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。<br>contents这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。<br>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的contents，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。<br>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：<br><code>layer.contents = (__bridge id)image.CGImage;</code><br> 如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！</p>
<p>让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的contents属性设置成图片。</p>
<p>#####清单2.1 更新后的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad]; //load an image</div><div class="line">        UIImage *image = [UIImage imageNamed:@&quot;Snowman&quot;];</div><div class="line">        //add it directly to our view&apos;s layer</div><div class="line">        self.layerView.layer.contents = (__bridge id)image.CGImage;</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-693d5c2da9328e26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图.png"></p>
<pre><code>在UIView的宿主图层中显示一张图片
</code></pre><p>我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。</p>
<ul>
<li>####<strong>contentGravity属性</strong></li>
</ul>
<p>你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把contentMode属性设置成更合适的值，像这样：<br><code>view.contentMode = UIViewContentModeScaleAspectFit;</code></p>
<p>这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。</p>
<p>CALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。contentsGravity可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<p>和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</p>
<p><code>self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6c0ffcad9d3f428c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<ul>
<li>####<strong>contentsScale属性</strong></li>
</ul>
<p>contentsScale属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p>contentsScale的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为contents由于设置了contentsGravity<br>属性，所以它已经被拉伸以适应图层的边界。</p>
<p>如果你只是单纯地想放大图层的contents图片，你可以通过使用图层的transform和affineTransform属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是contengsScale的目的所在.</p>
<p>contentsScale属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设contentsGravity<br>属性）。UIView有一个类似功能但是非常少用到contentScaleFactor<br>属性。</p>
<p>如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。</p>
<p>这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把contentsGravity设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化（如图2.3）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-e88c0aaf84f3b8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.3.png"></p>
<pre><code>用错误的contentsScale属性显示Retina图片
</code></pre><p>如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置contentsScale来修复这个问题（如2.2清单），图2.4是结果</p>
<p>#####清单2.4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad]; //load an image</div><div class="line">        UIImage *image = [UIImage imageNamed:@&quot;Snowman.png&quot;]; //add it directly to our view&apos;s layer</div><div class="line">        self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image</div><div class="line">        self.layerView.layer.contentsGravity = kCAGravityCenter;</div><div class="line">        </div><div class="line">        //set the contentsScale to match image</div><div class="line">        self.layerView.layer.contentsScale = image.scale;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d6cc02bde6e0ac3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.4.正确的contentsScale之后"><br>当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的contentsScale属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：<br><code>layer.contentsScale = [UIScreen mainScreen].scale;</code></p>
<ul>
<li>####<strong>maskToBounds属性</strong></li>
</ul>
<p>现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。</p>
<p>UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES，雪人就在边界里啦～（如图2.5）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-f3fe22588c2a354e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.5.png"></p>
<ul>
<li>####<strong>contentsRect属性</strong></li>
</ul>
<p>CALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要contentsGravity<br>灵活多了和bounds，frame不同，contentsRect不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<p>默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d1c60386893f5477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.6.png"></p>
<p>事实上给contentsRect设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p>contentsRect在app中最有趣的地方在于一个叫做image sprites（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。</p>
<p>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等</p>
<p>2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用contentsRect</p>
<p>首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-064197033685be51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.7.png"></p>
<p> 接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的contents，然后设置每个图层的contentsRect来去掉我们不想显示的部分。</p>
<p>我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果</p>
<p>#####清单2.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *coneView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *shipView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *iglooView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *anchorView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect ￼toLayer:(CALayer *)layer //set image</div><div class="line">&#123;</div><div class="line">    layer.contents = (__bridge id)image.CGImage;</div><div class="line">    </div><div class="line">    //scale contents to fit</div><div class="line">    layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">    </div><div class="line">    //set contentsRect</div><div class="line">    layer.contentsRect = rect;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad]; //load sprite sheet</div><div class="line">    UIImage *image = [UIImage imageNamed:@&quot;Sprites.png&quot;];</div><div class="line">    //set igloo sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];</div><div class="line">    //set cone sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];</div><div class="line">    //set anchor sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];</div><div class="line">    //set spaceship sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-df8cb36dcbaefaa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.8.png"></p>
<p>拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。<br>Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置contentsRect，这样开发者就不用手动写代码来摆放位置了。<br>这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（<a href="https://github.com/nicklockwood/LayerSprites" target="_blank" rel="noopener">https://github.com/nicklockwood/LayerSprites</a>)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。</p>
<ul>
<li>####<strong>contentsCenter属性</strong></li>
</ul>
<p> 本章我们介绍的最后一个和内容有关的属性是contentsCenter，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。contentsCenter其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<p>默认情况下，contentsCenter是{0, 0, 1, 1}，这意味着如果大小（由conttensGravity决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了contentsCenter设置为{0.25, 0.25, 0.5, 0.5}的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-ba74d68cdfe19927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.9.png"><br>这意味着我们可以随意重设尺寸，边框仍然会是连续的。他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d062cb97b49f705c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.10.png"></p>
<p> 清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11</p>
<p>####清单2.4</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-ba4b083cc0841e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.11.png"></p>
<ul>
<li>####<strong>Custome Drawing属性</strong></li>
</ul>
<p> 给contents赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现-drawRect:方法来自定义绘制。</p>
<p>-drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值。</p>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。</p>
<p>当视图在屏幕上出现的时候 -drawRect:方法就会被自动调用。-drawRect:方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了-setNeedsDisplay方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性）。虽然-drawRect:方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>CALayer有一个可选的delegate属性，实现了CALayerDelegate协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（delegate属性被声明为id类型，所有的代理方法都是可选的）。</p>
<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:<br><code>(void)displayLayer:(CALayerCALayer *)layer;</code></p>
<p>趁着这个机会，如果代理想直接设置contents属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现-displayLayer:方法，CALayer就会转而尝试调用下面这个方法：<br><code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</code></p>
<p> 在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>
<p>让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是他的结果</p>
<p>#####清单2.5实现CALayerDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        ￼</div><div class="line">        //create sublayer</div><div class="line">        CALayer *blueLayer = [CALayer layer];</div><div class="line">        blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">        blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">        </div><div class="line">        //set controller as layer delegate</div><div class="line">        blueLayer.delegate = self;</div><div class="line">        </div><div class="line">        //ensure that layer backing image uses correct scale</div><div class="line">        blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view</div><div class="line">        [self.layerView.layer addSublayer:blueLayer];</div><div class="line">        </div><div class="line">        //force layer to redraw</div><div class="line">        [blueLayer display];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</div><div class="line">    &#123;</div><div class="line">        //draw a thick red circle</div><div class="line">        CGContextSetLineWidth(ctx, 10.0f);</div><div class="line">        CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);</div><div class="line">        CGContextStrokeEllipseInRect(ctx, layer.bounds);</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0d39dd147e3b14af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.12.png"></p>
<p> 注意一下一些有趣的事情：</p>
<ul>
<li>我们在blueLayer上显式地调用了-display。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>尽管我们没有用masksToBounds属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<p>现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个-displayLayer:的实现，那所有的问题就都没了。</p>
<p>当使用寄宿了视图的图层的时候，你也不必实现-displayLayer:和-drawLayer:inContext:方法来绘制你的寄宿图。通常做法是实现UIView的-drawRect:方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用-display方法。</p>
<p>####总结<br> 本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。</p>
<p>在第三章，”图层几何学”中，我们将会探讨一下图层的几何，观察他们是如何放置和改变相互的尺寸的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/01/CAShapeLayer与UIBezierPath实现注水动画与正余弦水波纹动画,雷达扩散效果，添加购物车动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/01/CAShapeLayer与UIBezierPath实现注水动画与正余弦水波纹动画,雷达扩散效果，添加购物车动画/" itemprop="url">CAShapeLayer与UIBezierPath实现注水动画与正余弦水波纹动画，雷达扩散，添加购物车动画</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-01T20:19:35+08:00">
                2016-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>初步学习了CoreAnimation框架，总结了几个动画效果，主要是通过CAShapeLayer与贝塞尔曲线实现。<br>推荐一个大神的博客：<a href="http://kittenyang.com/" target="_blank" rel="noopener">Kitten 的时间胶囊</a>,爱好动画的可以看看。感觉数学好渣渣，是时候恶补一下了<br>先看下效果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-729daa88f1ae1a23.gif?imageMogr2/auto-orient/strip" alt="gif.gif"></p>
<blockquote>
<p>#####<strong>扇形下载进度</strong></p>
</blockquote>
<p>要实现扇形的下载进度，有两种方法， 这里先使用第一种：<br>1.使用设置UIBezierPath的角度<br>2.使用 CAShapeLayer的stokeEnd属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//设置中心点</div><div class="line">  CGPoint point = CGPointMake(self.frame.size.width/2, self.frame.size.height/2);</div><div class="line">  </div><div class="line">  //起点位置</div><div class="line">  CGFloat startAngle = - M_PI /2;</div><div class="line">  </div><div class="line">  //结束位置</div><div class="line">  CGFloat endAngle = self.progress *M_PI *2 + startAngle;</div><div class="line">  </div><div class="line">  </div><div class="line">  UIBezierPath *path =[UIBezierPath bezierPathWithArcCenter:point radius:self.bounds.size.width/2 startAngle:startAngle endAngle:endAngle clockwise:1];</div><div class="line">  </div><div class="line">   //画一根到 圆心的线</div><div class="line">  [path addLineToPoint:point];</div><div class="line">  </div><div class="line">  </div><div class="line">  //通过layer绘制</div><div class="line">  CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">  </div><div class="line">  </div><div class="line">  layer.path = path.CGPath;</div><div class="line">  </div><div class="line">  layer.fillColor =[UIColor colorWithRed:0.47 green:0.83 blue:0.98 alpha:1].CGColor;</div><div class="line">  </div><div class="line">  [self.layer addSublayer:layer];</div></pre></td></tr></table></figure></p>
<blockquote>
<h5 id="圆形进度"><a href="#圆形进度" class="headerlink" title="圆形进度"></a><strong>圆形进度</strong></h5></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">首先 我们需要一个背景层 一个前景层，一个路径供给两个layer使用。这里我们使用改变stokeEnd 来改变圆弧的进度，代码里增加了一点渐变</div><div class="line">   self.backLayer =[CAShapeLayer layer];</div><div class="line">    self.backLayer.fillColor  =[UIColor clearColor].CGColor;</div><div class="line">    self.backLayer.frame = self.bounds;</div><div class="line">    self.backLayer.lineWidth = 4;</div><div class="line">    self.backLayer.strokeColor =[UIColor lightGrayColor].CGColor;</div><div class="line">    [self.layer addSublayer:self.backLayer];</div><div class="line">    </div><div class="line">    self.foreLayer =[CAShapeLayer layer];</div><div class="line">    self.foreLayer.fillColor  =[UIColor clearColor].CGColor;</div><div class="line">    self.foreLayer.frame = self.bounds;</div><div class="line">    self.foreLayer.strokeColor =[UIColor redColor].CGColor;</div><div class="line">    self.foreLayer.lineWidth = 4;</div><div class="line">    [self.layer addSublayer:self.foreLayer];</div><div class="line">    </div><div class="line">    </div><div class="line">    UIBezierPath *path=  [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2) radius:self.bounds.size.width/2-2 startAngle:-M_PI_2 endAngle:M_PI *1.5 clockwise:YES];</div><div class="line">    self.backPath = path;</div><div class="line">    </div><div class="line">    self.backLayer.path = self.backPath.CGPath;</div><div class="line">    self.foreLayer.path = self.backPath.CGPath;</div><div class="line">    self.foreLayer.strokeEnd = 0;</div><div class="line">    </div><div class="line">    </div><div class="line">    self.gradientLayerLeft =[CAGradientLayer layer];</div><div class="line">    self.gradientLayerLeft.frame = self.bounds;</div><div class="line">    </div><div class="line">    self.gradientLayerLeft.colors =@[(__bridge id)[UIColor redColor].CGColor,(__bridge id)[UIColor yellowColor].CGColor,(__bridge id)[UIColor blueColor].CGColor];</div><div class="line">    self.gradientLayerLeft.locations = @[@0,@0.5,@1];</div><div class="line">    self.gradientLayerLeft.startPoint = CGPointMake(0, 0);</div><div class="line">    self.gradientLayerLeft.endPoint = CGPointMake(0, 1);</div><div class="line">    [self.layer addSublayer:self.gradientLayerLeft];</div><div class="line">  </div><div class="line">    </div><div class="line">    //设置mask</div><div class="line">    [self.gradientLayerLeft setMask:self.foreLayer];</div><div class="line">-(void)setProgressValue:(CGFloat)progressValue</div><div class="line">&#123;</div><div class="line">    _progressValue = progressValue;</div><div class="line">    self.foreLayer.strokeEnd = progressValue;</div><div class="line">    self.label.text = [NSString stringWithFormat:@&quot;%.f%%&quot;,progressValue *100];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> #####<strong>一个加载动画</strong></p>
</blockquote>
<p>引自：<a href="http://www.jianshu.com/p/447b0de110a7" target="_blank" rel="noopener">旋转加载动画</a><br>可以重点学习下做动画的思路，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//核心代码 在动画开始的时候做一些平移旋转</div><div class="line">- (void)animationDidStart:(CAAnimation *)anim&#123;</div><div class="line">    [UIView animateWithDuration:0.3 delay:0.1 options:UIViewAnimationOptionCurveEaseOut|UIViewAnimationOptionBeginFromCurrentState animations:^&#123;</div><div class="line">        </div><div class="line">        self.ball_1.transform = CGAffineTransformMakeTranslation(-BALL_RADIUS, 0);</div><div class="line">        self.ball_1.transform = CGAffineTransformScale(self.ball_1.transform, 0.7, 0.7);</div><div class="line">        </div><div class="line">        self.ball_3.transform = CGAffineTransformMakeTranslation(BALL_RADIUS, 0);</div><div class="line">        self.ball_3.transform = CGAffineTransformScale(self.ball_3.transform, 0.7, 0.7);</div><div class="line">        </div><div class="line">        </div><div class="line">        self.ball_2.transform = CGAffineTransformScale(self.ball_2.transform, 0.7, 0.7);</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [UIView animateWithDuration:0.3 delay:0.1 options:UIViewAnimationOptionCurveEaseIn  | UIViewAnimationOptionBeginFromCurrentState animations:^&#123;</div><div class="line">            self.ball_1.transform = CGAffineTransformIdentity;</div><div class="line">            self.ball_3.transform = CGAffineTransformIdentity;</div><div class="line">            self.ball_2.transform = CGAffineTransformIdentity;</div><div class="line">        &#125; completion:NULL];</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>#####<strong>使用正余弦做的注水动画</strong></p>
</blockquote>
<p>在使用正余弦做注水动画时，先了解下正余弦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 正弦曲线公式可表示为y=Asin(ωx+φ)+k：</div><div class="line"> A，振幅，最高和最低的距离</div><div class="line"> W，角速度，用于控制周期大小，单位x中的起伏个数</div><div class="line"> K，偏距，曲线整体上下偏移量</div><div class="line"> φ，初相，左右移动的值</div><div class="line"> </div><div class="line"> 这个效果主要的思路是添加两条曲线 一条正玄曲线、一条余弦曲线 然后在曲线下添加深浅不同的背景颜色，从而达到波浪显示的效果</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>我们要做的 就是使用两条正余弦，但是这两条正余弦， 波峰需要对应波谷，有两种方法：</p>
<ol>
<li>使用for循环分别拼接正余弦的路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">-(void)updateWave</div><div class="line">&#123;</div><div class="line">    //波浪宽度</div><div class="line">    CGFloat waterWaveWidth = self.bounds.size.width;</div><div class="line">    //初始化运动路径</div><div class="line">    CGMutablePathRef path = CGPathCreateMutable();</div><div class="line">    </div><div class="line">    CGMutablePathRef maskPath = CGPathCreateMutable();</div><div class="line">    //设置起始位置</div><div class="line">    CGPathMoveToPoint(path, nil, 0, _waveY);</div><div class="line">    </div><div class="line">    //设置起始位置</div><div class="line">    CGPathMoveToPoint(maskPath, nil, 0, _waveY);</div><div class="line">    //初始化波浪其实Y为偏距</div><div class="line">    CGFloat y = _waveY;</div><div class="line">  </div><div class="line">    //正弦曲线公式为： y=Asin(ωx+φ)+k;</div><div class="line">    for (float x = 0.0f; x &lt;= waterWaveWidth ; x++) &#123;</div><div class="line">        y = _waveAmplitude * sin(_wavePalstance * x + _waveX) + _waveY;</div><div class="line">       </div><div class="line">        CGPathAddLineToPoint(path, nil, x, y);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    for (float x = 0.0f; x &lt;= waterWaveWidth ; x++) &#123;</div><div class="line">        y = _waveAmplitude * cos(_wavePalstance * x + _waveX) + _waveY;</div><div class="line">       </div><div class="line">        CGPathAddLineToPoint(maskPath, nil, x, y);</div><div class="line">    &#125;</div><div class="line">    [self updateLayer:_waveLayer1 path:path];</div><div class="line">    [self updateLayer:_waveLayer2 path:maskPath];</div><div class="line"></div><div class="line">&#125;</div><div class="line">-(void)updateLayer:(CAShapeLayer *)layer path:(CGMutablePathRef )path</div><div class="line">&#123;</div><div class="line">    //填充底部颜色</div><div class="line">    CGFloat waterWaveWidth = self.bounds.size.width;</div><div class="line">    CGPathAddLineToPoint(path, nil, waterWaveWidth, self.bounds.size.height);</div><div class="line">    CGPathAddLineToPoint(path, nil, 0, self.bounds.size.height);</div><div class="line">    CGPathCloseSubpath(path);</div><div class="line">    layer.path = path;</div><div class="line">     CGPathRelease(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.使用单个for循环只是 设置 另一条曲线的y值相反即可实现两条正余弦的效果 ，最后一个动画中会有说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (int x = 0; x&lt;WIDTH; x++) &#123;</div><div class="line">       y = waveHeight*sinf(0.01*waveCurvature*x+offSetValue*0.045);</div><div class="line">       CGPathAddLineToPoint(path, nil, x, y);</div><div class="line">       //遮罩层的路径与之相反</div><div class="line">       masky = -y;</div><div class="line">       CGPathAddLineToPoint(maskPath, nil, x, masky);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><strong>但是</strong>我们有个需求就是改变 波浪的高度， 实现注水的百分比，就需要设置波浪的偏距<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(void)updateWaveY</div><div class="line">&#123;</div><div class="line">    CGFloat targetY = self.bounds.size.height - _progress * self.bounds.size.height;</div><div class="line">    if (_waveY &lt; targetY) &#123;</div><div class="line">        _waveY += 2;</div><div class="line">    &#125;</div><div class="line">    if (_waveY &gt; targetY ) &#123;</div><div class="line">        _waveY -= 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>#####<strong>正余弦动画2</strong> </p>
</blockquote>
<p>如果有个需求 ，比如一个小船 随着波浪的波动而起伏<br>那我们就需要计算 波浪的位置，然后设置小船的frame<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//这里使用创建正余弦的第二种方法</div><div class="line">    for (int x = 0; x&lt;WIDTH; x++) &#123;</div><div class="line">        y = waveHeight*sinf(0.01*waveCurvature*x+offSetValue*0.045);</div><div class="line">        CGPathAddLineToPoint(path, nil, x, y);</div><div class="line">        //遮罩层的路径与之相反</div><div class="line">        masky = -y;</div><div class="line">        CGPathAddLineToPoint(maskPath, nil, x, masky);</div><div class="line">    &#125;</div><div class="line">计算出实浪波动时，最中间的位置，设置小船的frame</div><div class="line">  CGFloat CentY = waveHeight*sinf(0.01*waveCurvature*WIDTH/2+offSetValue*0.045);</div><div class="line">    CGRect boardViewFrame = [boardView frame];</div><div class="line">    boardViewFrame.origin.y = 100-waveHeight+CentY;</div><div class="line">    boardView.frame = boardViewFrame;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>雷达动画</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-4dfc88e76fa8a370.gif?imageMogr2/auto-orient/strip" alt="gif.gif"></p>
<p>给UIView添加一个分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface UIView (RadarAnimation)</div><div class="line"></div><div class="line">@property(nonatomic,strong)UIColor *radarColor; //扩散颜色</div><div class="line">@property(nonatomic,assign)UIColor *radarBorderColor; //扩散边界颜色</div><div class="line">-(void)addRadarAnimation;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.radarColor = LBColor(237, 174, 130, 1);</div><div class="line">button.radarBorderColor = LBColor(237, 174, 130, 0.5);</div><div class="line"> [button addRadarAnimation];</div></pre></td></tr></table></figure></p>
<p>动画:添加动画的方法,创建三个layer，只不过，开始动画的时间要错开形成这个效果：：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">-(void)Animation&#123;</div><div class="line">    NSInteger pulsingCount = 3;</div><div class="line">    double animationDuration = 2;</div><div class="line"></div><div class="line">    CALayer * animationLayer = [[CALayer alloc]init];</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; pulsingCount; i++) &#123;</div><div class="line">        CALayer * pulsingLayer = [[CALayer alloc]init];</div><div class="line">        pulsingLayer.frame = CGRectMake(0, 0, self.frame.size.width, self.frame.size.height);</div><div class="line">        pulsingLayer.backgroundColor = self.radarColor.CGColor;</div><div class="line">        pulsingLayer.borderColor = self.radarBorderColor.CGColor;</div><div class="line"></div><div class="line"></div><div class="line">        pulsingLayer.borderWidth = 1.0;</div><div class="line">        pulsingLayer.cornerRadius = self.frame.size.height/2;</div><div class="line"></div><div class="line">        CAMediaTimingFunction * defaultCurve = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line"></div><div class="line">        CAAnimationGroup * animationGroup = [[CAAnimationGroup alloc]init];</div><div class="line">        animationGroup.fillMode = kCAFillModeBoth;</div><div class="line">        animationGroup.beginTime = CACurrentMediaTime() + (double)i * animationDuration/(double)pulsingCount;</div><div class="line">        animationGroup.duration = animationDuration;</div><div class="line">        animationGroup.repeatCount = HUGE_VAL;</div><div class="line">        animationGroup.timingFunction = defaultCurve;</div><div class="line"></div><div class="line">        CABasicAnimation * scaleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</div><div class="line">        scaleAnimation.autoreverses = NO;</div><div class="line">        scaleAnimation.fromValue = [NSNumber numberWithDouble:1];</div><div class="line">        scaleAnimation.toValue = [NSNumber numberWithDouble:1.5];</div><div class="line"></div><div class="line">        CAKeyframeAnimation * opacityAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];</div><div class="line">        opacityAnimation.values = @[[NSNumber numberWithDouble:1.0],[NSNumber numberWithDouble:0.5],[NSNumber numberWithDouble:0.3],[NSNumber numberWithDouble:0.0]];</div><div class="line">        opacityAnimation.keyTimes = @[[NSNumber numberWithDouble:0.0],[NSNumber numberWithDouble:0.25],[NSNumber numberWithDouble:0.5],[NSNumber numberWithDouble:1.0]];</div><div class="line">        animationGroup.animations = @[scaleAnimation,opacityAnimation];</div><div class="line"></div><div class="line">        [pulsingLayer addAnimation:animationGroup forKey:@&quot;pulsing&quot;];</div><div class="line">        [animationLayer addSublayer:pulsingLayer];</div><div class="line">    &#125;</div><div class="line">        animationLayer.zPosition = -1;//重新加载时，使动画至底层</div><div class="line">    [self.layer addSublayer:animationLayer];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>爱奇艺旋转动画，说白了还是监听stokeStart stokeEnd做动画效果。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-2394fa45a2af03ef.gif?imageMogr2/auto-orient/strip" alt="  爱奇艺动画.gif"></p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">-(void)setUp&#123;</div><div class="line">    </div><div class="line">    CGPoint point =  CGPointMake(self.width/2, self.height/2);</div><div class="line">    UIBezierPath *path =[UIBezierPath bezierPathWithArcCenter:point radius:(self.width - 1)/2 startAngle:-0.5 *M_PI endAngle:1.5 *M_PI clockwise:YES];</div><div class="line"></div><div class="line">    self.shapeLayer =[[CAShapeLayer alloc]init];</div><div class="line">    self.shapeLayer.frame = self. bounds;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeColor = [UIColor hexStringToColor:@&quot;#94BF3F&quot;].CGColor;</div><div class="line">    self.shapeLayer.fillColor =[UIColor clearColor].CGColor;</div><div class="line">    self.shapeLayer.lineWidth = 1;</div><div class="line">    self.shapeLayer.lineCap = kCALineCapRound;</div><div class="line">    </div><div class="line"> </div><div class="line">    self.shapeLayer.path = path.CGPath;</div><div class="line">    </div><div class="line">    [self.layer addSublayer:self.shapeLayer];</div><div class="line">    </div><div class="line">    </div><div class="line">  </div><div class="line">    self.imageView =[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 9, 9)];</div><div class="line">    self.imageView.center = point;</div><div class="line">    self.imageView.image =[UIImage imageNamed:@&quot;三角形&quot;];</div><div class="line">    </div><div class="line">    [self addSubview:self.imageView];</div><div class="line">    [self animationOne];</div><div class="line"></div><div class="line">&#125;</div><div class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</div><div class="line">    if ([[anim valueForKey:@&quot;animationName&quot;] isEqualToString:@&quot;AnimationEnd&quot;]) &#123;</div><div class="line">        </div><div class="line">        [self animationTwo];</div><div class="line">        [self rotationAnimation];</div><div class="line">    &#125;</div><div class="line">    if ([[anim valueForKey:@&quot;animationName&quot;] isEqualToString:@&quot;AnimationStart&quot;]) &#123;</div><div class="line">        </div><div class="line">   </div><div class="line">        [self.shapeLayer removeAllAnimations];</div><div class="line">        [self animationOne];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)animationOne&#123;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeStart=0;</div><div class="line">    //设置strokeEnd的最终值，动画的fromValue为0，strokeEnd的最终值为0.98</div><div class="line">    self.shapeLayer.strokeEnd=0.98;</div><div class="line">    CABasicAnimation *basicAnimationOne=[CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</div><div class="line">    basicAnimationOne.fromValue=@(0);</div><div class="line">    </div><div class="line">    basicAnimationOne.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    basicAnimationOne.delegate=self;</div><div class="line">    [basicAnimationOne setValue:@&quot;AnimationEnd&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line">    [self.shapeLayer addAnimation:basicAnimationOne forKey:@&quot;animationName&quot;];</div><div class="line">&#125;</div><div class="line">-(void)animationTwo&#123;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeStart = 0.98;</div><div class="line">    CABasicAnimation *basicAnimationTwo=[CABasicAnimation animationWithKeyPath:@&quot;strokeStart&quot;];</div><div class="line">    basicAnimationTwo.fromValue=@(0);</div><div class="line">    </div><div class="line">    basicAnimationTwo.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    basicAnimationTwo.delegate=self;</div><div class="line">    [basicAnimationTwo setValue:@&quot;AnimationStart&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line"></div><div class="line">    [self.shapeLayer addAnimation:basicAnimationTwo forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)rotationAnimation&#123;</div><div class="line">    CABasicAnimation *rotationAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">    </div><div class="line">    rotationAnimation.toValue=@(M_PI*2);</div><div class="line">    rotationAnimation.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    rotationAnimation.delegate=self;</div><div class="line">    [rotationAnimation setValue:@&quot;AnimationRotation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    [self.imageView.layer addAnimation:rotationAnimation forKey:@&quot;AnimationRotation&quot;];</div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初学动画，参考很多文章，做个小小总结。<br>demo地址 <a href="https://github.com/liuxinixn/ProgressViewDemo" target="_blank" rel="noopener">demo集合</a></p>
<p>另外一个加入购物车的小动画：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-37a8d72c7ff0562c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimation</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    </div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(_endPoint.x, _startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:_startPoint];</div><div class="line">    [path addQuadCurveToPoint:_endPoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [_viewController.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    [_shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/a9a4c51aef13" target="_blank" rel="noopener">贝塞尔曲线（加入购物车动画）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg"
              alt="雪晟" />
          
            <p class="site-author-name" itemprop="name">雪晟</p>
            <p class="site-description motion-element" itemprop="description">多去尝试你从未尝试的。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">99</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liuxinixn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/3d7c50f31b88" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-flag"></i>Jianshu</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雪晟</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
