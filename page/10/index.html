<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="多去尝试你从未尝试的。">
<meta property="og:type" content="website">
<meta property="og:title" content="雪晟">
<meta property="og:url" content="liuxinixn.github.io/page/10/index.html">
<meta property="og:site_name" content="雪晟">
<meta property="og:description" content="多去尝试你从未尝试的。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雪晟">
<meta name="twitter:description" content="多去尝试你从未尝试的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxinixn.github.io/page/10/"/>





  <title>雪晟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雪晟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">十年饮冰，难凉热血。我是雪晟。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/09/CoreAnimation之缓冲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/09/CoreAnimation之缓冲/" itemprop="url">CoreAnimation缓冲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-09T20:19:35+08:00">
                2016-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>生活和艺术一样，最美的永远是曲线。 – 爱德华布尔沃 - 利顿</p>
</blockquote>
<p>在第九章“图层时间”中，我们讨论了动画时间和CAMediaTiming<br>协议。现在我们来看一下另一个和时间相关的机制–所谓的缓冲。Core Animation使用缓冲来使动画移动更平滑更自然，而不是看起来的那种机械和人工，在这一章我们将要研究如何对你的动画控制和自定义缓冲曲线。</p>
<p>#####动画速度<br>动画实际上就是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。速率由以下公式计算而来：</p>
<p><code>velocity = change / time</code></p>
<p>这里的变化可以指的是一个物体移动的距离，时间指动画持续的时长，用这样的一个移动可以更加形象的描述（比如position<br>和bounds属性的动画），但实际上它应用于任意可以做动画的属性（比如color和opacity）。</p>
<p>上面的等式假设了速度在整个动画过程中都是恒定不变的（就如同第八章“显式动画”的情况），对于这种恒定速度的动画我们称之为“线性步调”，而且从技术的角度而言这也是实现动画最简单的方式，但也是完全不真实的一种效果。</p>
<p>考虑一个场景，一辆车行驶在一定距离内，它并不会一开始就以60mph的速度行驶，然后到达终点后突然变成0mph。一是因为需要无限大的加速度（即使是最好的车也不会在0秒内从0跑到60），另外不然的话会干死所有乘客。在现实中，它会慢慢地加速到全速，然后当它接近终点的时候，它会慢慢地减速，直到最后停下来。</p>
<p>那么对于一个掉落到地上的物体又会怎样呢？它会首先停在空中，然后一直加速到落到地面，然后突然停止（然后由于积累的动能转换伴随着一声巨响，砰！）。</p>
<p>现实生活中的任何一个物体都会在运动中加速或者减速。那么我们如何在动画中实现这种加速度呢？一种方法是使用物理引擎来对运动物体的摩擦和动量来建模，然而这会使得计算过于复杂。我们称这种类型的方程为缓冲函数，幸运的是，Core Animation内嵌了一系列标准函数提供给我们使用。</p>
<p>#####CAMediaTimingFunction<br> 那么该如何使用缓冲方程式呢？首先需要设置CAAnimation的timingFunction属性，是CAMediaTimingFunction类的一个对象。如果想改变隐式动画的计时函数，同样也可以使用CATransaction的+setAnimationTimingFunction:方法。</p>
<p>这里有一些方式来创建CAMediaTimingFunction，最简单的方式是调用+timingFunctionWithName:的构造方法。这里传入如下几个常量之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kCAMediaTimingFunctionLinear </div><div class="line">kCAMediaTimingFunctionEaseIn </div><div class="line">kCAMediaTimingFunctionEaseOut </div><div class="line">kCAMediaTimingFunctionEaseInEaseOut</div><div class="line">kCAMediaTimingFunctionDefault</div></pre></td></tr></table></figure></p>
<p>kCAMediaTimingFunctionLinear选项创建了一个线性的计时函数，同样也是CAAnimation的timingFunction属性为空时候的默认函数。线性步调对于那些立即加速并且保持匀速到达终点的场景会有意义（例如射出枪膛的子弹），但是默认来说它看起来很奇怪，因为对大多数的动画来说确实很少用到。</p>
<p>kCAMediaTimingFunctionEaseIn常量创建了一个慢慢加速然后突然停止的方法。对于之前提到的自由落体的例子来说很适合，或者比如对准一个目标的导弹的发射。</p>
<p>kCAMediaTimingFunctionEaseOut则恰恰相反，它以一个全速开始，然后慢慢减速停止。它有一个削弱的效果，应用的场景比如一扇门慢慢地关上，而不是砰地一声。</p>
<p>kCAMediaTimingFunctionEaseInEaseOut创建了一个慢慢加速然后再慢慢减速的过程。这是现实世界大多数物体移动的方式，也是大多数动画来说最好的选择。如果只可以用一种缓冲函数的话，那就必须是它了。那么你会疑惑为什么这不是默认的选择，实际上当使用UIView的动画方法时，他的确是默认的，但当创建CAAnimation<br>的时候，就需要手动设置它了。</p>
<p>最后还有一个kCAMediaTimingFunctionDefault，它和kCAMediaTimingFunctionEaseInEaseOut很类似，但是加速和减速的过程都稍微有些慢。它kCAMediaTimingFunctionEaseInEaseOut<br>的区别很难察觉，可能是苹果觉得它对于隐式动画来说更适合（然后对UIKit就改变了想法，而是使用kCAMediaTimingFunctionEaseInEaseOut作为默认效果），虽然它的名字说是默认的，但还是要记住当创建显式的CAAnimation<br>它并不是默认选项（换句话说，默认的图层行为动画用kCAMediaTimingFunctionDefault作为它们的计时方法）。</p>
<p>你可以使用一个简单的测试工程来实验一下（清单10.1），在运行之前改变缓冲函数的代码，然后点击任何地方来观察图层是如何通过指定的缓冲移动的。</p>
<p>#####清单10.1 缓冲函数的简单测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) CALayer *colorLayer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a red layer</div><div class="line">    self.colorLayer = [CALayer layer];</div><div class="line">    self.colorLayer.frame = CGRectMake(0, 0, 100, 100);</div><div class="line">    self.colorLayer.position = CGPointMake(self.view.bounds.size.width/2.0, self.view.bounds.size.height/2.0);</div><div class="line">    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;</div><div class="line">    [self.view.layer addSublayer:self.colorLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //configure the transaction</div><div class="line">    [CATransaction begin];</div><div class="line">    [CATransaction setAnimationDuration:1.0];</div><div class="line">    [CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];</div><div class="line">    //set the position</div><div class="line">    self.colorLayer.position = [[touches anyObject] locationInView:self.view];</div><div class="line">    //commit transaction</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>#####UIView的动画缓冲<br>UIKit的动画也同样支持这些缓冲方法的使用，尽管语法和常量有些不同，为了改变UIView动画的缓冲选项，给options参数添加如下常量之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIViewAnimationOptionCurveEaseInOut </div><div class="line">UIViewAnimationOptionCurveEaseIn </div><div class="line">UIViewAnimationOptionCurveEaseOut </div><div class="line">UIViewAnimationOptionCurveLinear</div></pre></td></tr></table></figure></p>
<p> 它们和CAMediaTimingFunction紧密关联，UIViewAnimationOptionCurveEaseInOut是默认值（这里没有kCAMediaTimingFunctionDefault相对应的值了）。</p>
<p>具体使用方法见清单10.2（注意到这里不再使用UIView额外添加的图层，因为UIKit的动画并不支持这类图层）。</p>
<p>#####清单10.2 使用UIKit动画的缓冲测试工程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) UIView *colorView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a red layer</div><div class="line">    self.colorView = [[UIView alloc] init];</div><div class="line">    self.colorView.bounds = CGRectMake(0, 0, 100, 100);</div><div class="line">    self.colorView.center = CGPointMake(self.view.bounds.size.width / 2, self.view.bounds.size.height / 2);</div><div class="line">    self.colorView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:self.colorView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //perform the animation</div><div class="line">    [UIView animateWithDuration:1.0 delay:0.0</div><div class="line">                        options:UIViewAnimationOptionCurveEaseOut</div><div class="line">                     animations:^&#123;</div><div class="line">                         //set the position</div><div class="line">                         self.colorView.center = [[touches anyObject] locationInView:self.view];</div><div class="line">                     &#125;</div><div class="line">                     completion:NULL];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>#####缓冲和关键帧动画<br>或许你会回想起第八章里面颜色切换的关键帧动画由于线性变换的原因（见清单8.5）看起来有些奇怪，使得颜色变换非常不自然。为了纠正这点，我们来用更加合适的缓冲方法，例如kCAMediaTimingFunctionEaseIn，给图层的颜色变化添加一点脉冲效果，让它更像现实中的一个彩色灯泡。</p>
<p>我们不想给整个动画过程应用这个效果，我们希望对每个动画的过程重复这样的缓冲，于是每次颜色的变换都会有脉冲效果。</p>
<p>CAKeyframeAnimation有一个NSArray类型的timingFunctions<br>属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于keyframes数组的元素个数减一，因为它是描述每一帧之间动画速度的函数。</p>
<p>在这个例子中，我们自始至终想使用同一个缓冲函数，但我们同样需要一个函数的数组来告诉动画不停地重复每个步骤，而不是在整个动画序列只做一次缓冲，我们简单地使用包含多个相同函数拷贝的数组就可以了（见清单10.3）。</p>
<p>运行更新后的代码，你会发现动画看起来更加自然了。</p>
<p>#####清单10.3 对CAKeyframeAnimation使用CAMediaTimingFunction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    @property (nonatomic, weak) IBOutlet CALayer *colorLayer;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create sublayer</div><div class="line">        self.colorLayer = [CALayer layer];</div><div class="line">        self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">        self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">        //add it to our view</div><div class="line">        [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (IBAction)changeColor</div><div class="line">    &#123;</div><div class="line">        //create a keyframe animation</div><div class="line">        CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">        animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">        animation.duration = 2.0;</div><div class="line">        animation.values = @[</div><div class="line">                             (__bridge id)[UIColor blueColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor redColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor greenColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor blueColor].CGColor ];</div><div class="line">        //add timing function</div><div class="line">        CAMediaTimingFunction *fn = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn];</div><div class="line">        animation.timingFunctions = @[fn, fn, fn];</div><div class="line">        //apply animation to layer</div><div class="line">        [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>#####自定义缓冲函数<br> 在第八章中，我们给时钟项目添加了动画。看起来很赞，但是如果有合适的缓冲函数就更好了。在显示世界中，钟表指针转动的时候，通常起步很慢，然后迅速啪地一声，最后缓冲到终点。但是标准的缓冲函数在这里每一个适合它，那该如何创建一个新的呢？</p>
<p>除了+functionWithName:之外，CAMediaTimingFunction同样有另一个构造函数，一个有四个浮点参数的+functionWithControlPoints::::（注意这里奇怪的语法，并没有包含具体每个参数的名称，这在objective-C中是合法的，但是却违反了苹果对方法命名的指导方针，而且看起来是一个奇怪的设计）。</p>
<p>使用这个方法，我们可以创建一个自定义的缓冲函数，来匹配我们的时钟动画，为了理解如何使用这个方法，我们要了解一些CAMediaTimingFunction是如何工作的。</p>
<p>#####三次贝塞尔曲线<br>CAMediaTimingFunction函数的主要原则在于它把输入的时间转换成起点和终点之间成比例的改变。我们可以用一个简单的图标来解释，横轴代表时间，纵轴代表改变的量，于是线性的缓冲就是一条从起点开始的简单的斜线（图10.1）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-dcd616ebc1d7d817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.1.png"></p>
<p>这条曲线的斜率代表了速度，斜率的改变代表了加速度，原则上来说，任何加速的曲线都可以用这种图像来表示，但是CAMediaTimingFunction使用了一个叫做三次贝塞尔曲线的函数，它只可以产出指定缓冲函数的子集（我们之前在第八章中创建CAKeyframeAnimation路径的时候提到过三次贝塞尔曲线）。</p>
<p>你或许会回想起，一个三次贝塞尔曲线通过四个点来定义，第一个和最后一个点代表了曲线的起点和终点，剩下中间两个点叫做控制点，因为它们控制了曲线的形状，贝塞尔曲线的控制点其实是位于曲线之外的点，也就是说曲线并不一定要穿过它们。你可以把它们想象成吸引经过它们曲线的磁铁。</p>
<p>图10.2展示了一个三次贝塞尔缓冲函数的例子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-b85f8cfe5566baaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.2.png"></p>
<p> 实际上它是一个很奇怪的函数，先加速，然后减速，最后快到达终点的时候又加速，那么标准的缓冲函数又该如何用图像来表示呢？</p>
<p>CAMediaTimingFunction有一个叫做-getControlPointAtIndex:values:的方法，可以用来检索曲线的点，这个方法的设计的确有点奇怪（或许也就只有苹果能回答为什么不简单返回一个CGPoint），但是使用它我们可以找到标准缓冲函数的点，然后用UIBezierPath和CAShapeLayer来把它画出来。</p>
<p>曲线的起始和终点始终是{0, 0}和{1, 1}，于是我们只需要检索曲线的第二个和第三个点（控制点）。具体代码见清单10.4。所有的标准缓冲函数的图像见图10.3。</p>
<p>#####清单10.4 使用UIBezierPath绘制CAMediaTimingFunction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create timing function</div><div class="line">        CAMediaTimingFunction *function = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut];</div><div class="line">        //get control points</div><div class="line">        CGPoint controlPoint1, controlPoint2;</div><div class="line">        [function getControlPointAtIndex:1 values:(float *)&amp;controlPoint1];</div><div class="line">        [function getControlPointAtIndex:2 values:(float *)&amp;controlPoint2];</div><div class="line">        //create curve</div><div class="line">        UIBezierPath *path = [[UIBezierPath alloc] init];</div><div class="line">        [path moveToPoint:CGPointZero];</div><div class="line">        [path addCurveToPoint:CGPointMake(1, 1)</div><div class="line">                controlPoint1:controlPoint1 controlPoint2:controlPoint2];</div><div class="line">        //scale the path up to a reasonable size for display</div><div class="line">        [path applyTransform:CGAffineTransformMakeScale(200, 200)];</div><div class="line">        //create shape layer</div><div class="line">        CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">        shapeLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">        shapeLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">        shapeLayer.lineWidth = 4.0f;</div><div class="line">        shapeLayer.path = path.CGPath;</div><div class="line">        [self.layerView.layer addSublayer:shapeLayer];</div><div class="line">        //flip geometry so that 0,0 is in the bottom-left</div><div class="line">        self.layerView.layer.geometryFlipped = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-54afa74cbf2aa63d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.3.png"></p>
<p>那么对于我们自定义时钟指针的缓冲函数来说，我们需要初始微弱，然后迅速上升，最后缓冲到终点的曲线，通过一些实验之后，最终结果如下：<br><code>[CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];</code></p>
<p>如果把它转换成缓冲函数的图像，最后如图10.4所示，如果把它添加到时钟的程序，就形成了之前一直期待的非常赞的效果（见代清单10.5）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c0827049652cabd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.4.png"></p>
<p>###清单10.5 添加了自定义缓冲函数的时钟程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)setAngle:(CGFloat)angle forHand:(UIView *)handView ￼animated:(BOOL)animated</div><div class="line">  &#123;</div><div class="line">      //generate transform</div><div class="line">      CATransform3D transform = CATransform3DMakeRotation(angle, 0, 0, 1);</div><div class="line">      if (animated) &#123;</div><div class="line">          //create transform animation</div><div class="line">          CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">          animation.keyPath = @&quot;transform&quot;;</div><div class="line">          animation.fromValue = [handView.layer.presentationLayer valueForKey:@&quot;transform&quot;];</div><div class="line">          animation.toValue = [NSValue valueWithCATransform3D:transform];</div><div class="line">          animation.duration = 0.5;</div><div class="line">          animation.delegate = self;</div><div class="line">          animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];</div><div class="line">          //apply animation</div><div class="line">          handView.layer.transform = transform;</div><div class="line">          [handView.layer addAnimation:animation forKey:nil];</div><div class="line">      &#125; else &#123;</div><div class="line">          //set transform directly</div><div class="line">          handView.layer.transform = transform;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>#####更加复杂的动画曲线<br>考虑一个橡胶球掉落到坚硬的地面的场景，当开始下落的时候，它会持续加速知道落到地面，然后经过几次反弹，最后停下来。如果用一张图来说明，它会如图10.5所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-272872ff5eb96c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.5.png"></p>
<p>这种效果没法用一个简单的三次贝塞尔曲线表示，于是不能用CAMediaTimingFunction来完成。但如果想要实现这样的效果，可以用如下几种方法：</p>
<ul>
<li>用CAKeyframeAnimation创建一个动画，然后分割成几个步骤，每个小步骤使用自己的计时函数（具体下节介绍）。</li>
<li>使用定时器逐帧更新实现动画（见第11章，“基于定时器的动画”）。<br>#####基于关键帧的缓冲<br>为了使用关键帧实现反弹动画，我们需要在缓冲曲线中对每一个显著的点创建一个关键帧（在这个情况下，关键点也就是每次反弹的峰值），然后应用缓冲函数把每段曲线连接起来。同时，我们也需要通过keyTimes<br>来指定每个关键帧的时间偏移，由于每次反弹的时间都会减少，于是关键帧并不会均匀分布。<br>清单10.6展示了实现反弹球动画的代码（见图10.6）<br>#####清单10.6 使用关键帧实现反弹球的动画<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add ball image view</div><div class="line">    UIImage *ballImage = [UIImage imageNamed:@&quot;Ball.png&quot;];</div><div class="line">    self.ballView = [[UIImageView alloc] initWithImage:ballImage];</div><div class="line">    [self.containerView addSubview:self.ballView];</div><div class="line">    //animate</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //replay animation on tap</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = @[</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 32)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 140)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 220)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 250)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)]</div><div class="line">                         ];</div><div class="line">    </div><div class="line">    animation.timingFunctions = @[</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn]</div><div class="line">                                  ];</div><div class="line">    </div><div class="line">    animation.keyTimes = @[@0.0, @0.3, @0.5, @0.7, @0.8, @0.9, @0.95, @1.0];</div><div class="line">    //apply animation</div><div class="line">    self.ballView.layer.position = CGPointMake(150, 268);</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-256c3ef34723c976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.6.png"><br>这种方式还算不错，但是实现起来略显笨重（因为要不停地尝试计算各种关键帧和时间偏移）并且和动画强绑定了（因为如果要改变动画的一个属性，那就意味着要重新计算所有的关键帧）。那该如何写一个方法，用缓冲函数来把任何简单的属性动画转换成关键帧动画呢，下面我们来实现它</p>
<p>#####流程自动化<br>在清单10.6中，我们把动画分割成相当大的几块，然后用Core Animation的缓冲进入和缓冲退出函数来大约形成我们想要的曲线。但如果我们把动画分割成更小的几部分，那么我们就可以用直线来拼接这些曲线（也就是线性缓冲）。为了实现自动化，我们需要知道如何做如下两件事情：</p>
<ul>
<li>自动把任意属性动画分割成多个关键帧</li>
<li>用一个数学函数表示弹性动画，使得可以对帧做便宜</li>
</ul>
<p>为了解决第一个问题，我们需要复制Core Animation的插值机制。这是一个传入起点和终点，然后在这两个点之间指定时间点产出一个新点的机制。对于简单的浮点起始值，公式如下（假设时间从0到1）：<br><code>value = (endValue – startValue) × time + startValue;</code></p>
<p> 那么如果要插入一个类似于CGPoint，CGColorRef或者CATransform3D这种更加复杂类型的值，我们可以简单地对每个独立的元素应用这个方法（也就CGPoint中的x和y值，CGColorRef中的红，蓝，绿，透明值，或者是CATransform3D中独立矩阵的坐标）。我们同样需要一些逻辑在插值之前对对象拆解值，然后在插值之后在重新封装成对象，也就是说需要实时地检查类型。</p>
<p>一旦我们可以用代码获取属性动画的起始值之间的任意插值，我们就可以把动画分割成许多独立的关键帧，然后产出一个线性的关键帧动画。清单10.7展示了相关代码。</p>
<p>注意到我们用了60 x 动画时间（秒做单位）作为关键帧的个数，这时因为Core Animation按照每秒60帧去渲染屏幕更新，所以如果我们每秒生成60个关键帧，就可以保证动画足够的平滑（尽管实际上很可能用更少的帧率就可以达到很好的效果）。</p>
<p>我们在示例中仅仅引入了对CGPoint类型的插值代码。但是，从代码中很清楚能看出如何扩展成支持别的类型。作为不能识别类型的备选方案，我们仅仅在前一半返回了fromValue，在后一半返回了toValue。</p>
<p>清单10.7 使用插入的值创建一个关键帧动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">float interpolate(float from, float to, float time)</div><div class="line">&#123;</div><div class="line">    return (to - from) * time + from;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)interpolateFromValue:(id)fromValue toValue:(id)toValue time:(float)time</div><div class="line">&#123;</div><div class="line">    if ([fromValue isKindOfClass:[NSValue class]]) &#123;</div><div class="line">        //get type</div><div class="line">        const char *type = [fromValue objCType];</div><div class="line">        if (strcmp(type, @encode(CGPoint)) == 0) &#123;</div><div class="line">            CGPoint from = [fromValue CGPointValue];</div><div class="line">            CGPoint to = [toValue CGPointValue];</div><div class="line">            CGPoint result = CGPointMake(interpolate(from.x, to.x, time), interpolate(from.y, to.y, time));</div><div class="line">            return [NSValue valueWithCGPoint:result];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //provide safe default implementation</div><div class="line">    return (time &lt; 0.5)? fromValue: toValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //set up animation parameters</div><div class="line">    NSValue *fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    NSValue *toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    CFTimeInterval duration = 1.0;</div><div class="line">    //generate keyframes</div><div class="line">    NSInteger numFrames = duration * 60;</div><div class="line">    NSMutableArray *frames = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; numFrames; i++) &#123;</div><div class="line">        float time = 1 / (float)numFrames * i;</div><div class="line">        [frames addObject:[self interpolateFromValue:fromValue toValue:toValue time:time]];</div><div class="line">    &#125;</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = frames;</div><div class="line">    //apply animation</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这可以起到作用，但效果并不是很好，到目前为止我们所完成的只是一个非常复杂的方式来使用线性缓冲复制CABasicAnimation的行为。这种方式的好处在于我们可以更加精确地控制缓冲，这也意味着我们可以应用一个完全定制的缓冲函数。那么该如何做呢？</p>
<p>缓冲背后的数学并不很简单，但是幸运的是我们不需要一一实现它。罗伯特·彭纳有一个网页关于缓冲函数（<a href="http://www.robertpenner.com/easing" target="_blank" rel="noopener">http://www.robertpenner.com/easing</a>），包含了大多数普遍的缓冲函数的多种编程语言的实现的链接，包括C。这里是一个缓冲进入缓冲退出函数的示例（实际上有很多不同的方式去实现它）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">float quadraticEaseInOut(float t)</div><div class="line">&#123;</div><div class="line">    return (t &lt; 0.5)? (2 * t * t): (-2 * t * t) + (4 * t) - 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">对我们的弹性球来说，我们可以使用bounceEaseOut函数：</div><div class="line"></div><div class="line">float bounceEaseOut(float t)</div><div class="line">&#123;</div><div class="line">    if (t &lt; 4/11.0) &#123;</div><div class="line">        return (121 * t * t)/16.0;</div><div class="line">    &#125; else if (t &lt; 8/11.0) &#123;</div><div class="line">        return (363/40.0 * t * t) - (99/10.0 * t) + 17/5.0;</div><div class="line">    &#125; else if (t &lt; 9/10.0) &#123;</div><div class="line">        return (4356/361.0 * t * t) - (35442/1805.0 * t) + 16061/1805.0;</div><div class="line">    &#125;</div><div class="line">    return (54/5.0 * t * t) - (513/25.0 * t) + 268/25.0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果修改清单10.7的代码来引入bounceEaseOut方法，我们的任务就是仅仅交换缓冲函数，现在就可以选择任意的缓冲类型创建动画了（见清单10.8）。</div><div class="line"></div><div class="line">清单10.8 用关键帧实现自定义的缓冲函数</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //set up animation parameters</div><div class="line">    NSValue *fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    NSValue *toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    CFTimeInterval duration = 1.0;</div><div class="line">    //generate keyframes</div><div class="line">    NSInteger numFrames = duration * 60;</div><div class="line">    NSMutableArray *frames = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; numFrames; i++) &#123;</div><div class="line">        float time = 1/(float)numFrames * i;</div><div class="line">        //apply easing</div><div class="line">        time = bounceEaseOut(time);</div><div class="line">        //add keyframe</div><div class="line">        [frames addObject:[self interpolateFromValue:fromValue toValue:toValue time:time]];</div><div class="line">    &#125;</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = frames;</div><div class="line">    //apply animation</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#####总结<br> 在这一章中，我们了解了有关缓冲和CAMediaTimingFunction类，它可以允许我们创建自定义的缓冲函数来完善我们的动画，同样了解了如何用CAKeyframeAnimation来避开CAMediaTimingFunction的限制，创建完全自定义的缓冲函数。</p>
<p>在下一章中，我们将要研究基于定时器的动画–另一个给我们对动画更多控制的选择，并且实现对动画的实时操纵。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/05/CoreAnimation图层几何学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/05/CoreAnimation图层几何学/" itemprop="url">CoreAnimation图层几何学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-05T20:19:35+08:00">
                2016-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<ul>
<li>####<strong>布局</strong></li>
</ul>
<p> UIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p>frame代表了图层的外部坐标（也就是在父图层上占据的空间），bounds是内部坐标（{0, 0}通常是图层的左上角），center和position都代表了相对于父图层anchorPoint所在的位置。anchorPoint的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-60c2a6313ce9cad9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.1.png"></p>
<p>视图的frame，bounds和center属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的frame<br>，不能够独立于图层之外改变视图的frame。</p>
<p>对于视图或者图层来说，frame并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据bounds，position和transform<br>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了（图3.2）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-962d369cf221fcfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2.png"></p>
<ul>
<li>####<strong>锚点</strong></li>
</ul>
<p>之前提到过，视图的center属性和图层的position属性都指定了anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame的位置，你可以认为anchorPoint是用来移动图层的把柄。</p>
<p>默认来说，anchorPoint位于图层的中点，所以图层的将会以这个点为中心放置。anchorPoint属性并没有被UIView接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的anchorPoint可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动（图3.3），而不是居中了。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-7827e0f4aceeba78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.3.png"></p>
<p>和第二章提到的contentsRect和contentsCenter属性类似，anchorPoint用单位坐标来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。anchorPoint可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了anchorPoint，position属性保持固定的值并没有发生改变，但是frame却移动了。</p>
<p>那在什么场合需要改变anchorPoint呢？既然我们可以随意改变图层位置，那改变anchorPoint不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个UIImageView<br>实例（当然你也可以用正常的视图，设置他们图层的contents<br>图片）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-2e8b159f0f65cc54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4.png"></p>
<p> 闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的frame，而根据图3.2的演示，当视图旋转的时候，frame是会发生改变的，这将会导致一些布局上的失灵。</p>
<p>我们用NSTimer来更新闹钟，使用视图的transform属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0a145b572f694e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.png"></p>
<p>#####清单3.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *hourHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *secondHand;</div><div class="line">@property (nonatomic, weak) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //start timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">    ￼</div><div class="line">    //set initial hand positions</div><div class="line">    [self tick];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tick</div><div class="line">&#123;</div><div class="line">    //convert time to hours, minutes and seconds</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">    //calculate hour hand angle //calculate minute hand angle</div><div class="line">    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">    //calculate second hand angle</div><div class="line">    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">    //rotate hands</div><div class="line">    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);</div><div class="line">    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);</div><div class="line">    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-63fdc55a5c4ba280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.png"><br> 你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>
<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>
<p>更好的方案是使用anchorPoint属性，我们来在-viewDidLoad方法中添加几行代码来给每个钟指针的anchorPoint做一些平移（清单3.2），图3.7显示了正确的结果。</p>
<p>#####清单3.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       // adjust anchor points</div><div class="line">       </div><div class="line">       self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       </div><div class="line">       </div><div class="line">       // start timer</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-73c01bb8b7088a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.7.png"></p>
<ul>
<li>####<strong>坐标系</strong><br>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds<br>，如果父图层发生了移动，它的所有子图层也会跟着移动。</li>
</ul>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的绝对位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。<br>CALayer给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; </div><div class="line">- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; </div><div class="line">- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;</div><div class="line">- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</div></pre></td></tr></table></figure>
<p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>
<ul>
<li>####<strong>翻转的几何结构</strong></li>
</ul>
<p>常规说来，在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES,意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们geometryFlipped<br>属性也设为YES）。</p>
<ul>
<li>####<strong>Z坐标轴</strong></li>
</ul>
<p>和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了我们已经讨论过的position和anchorPoint属性之外，CALayer还有另外两个属性，zPosition和anchorPointZ<br>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>注意这里并没有更深的属性来描述由宽和高做成的bounds<br>了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>
<p>zPosition属性在大多数情况下其实并不常用。在第五章，我们将会涉及CATransform3D，你会知道如何在三维空间移动和旋转图层，除了做变换之外，zPosition最实用的功能就是改变图层的显示顺序了。</p>
<p>通常，图层是根据它们子图层的sublayers<br>出现的顺序来类绘制的，这就是所谓的画家的<a href="http://lib.csdn.net/base/31" target="_blank" rel="noopener">算法</a>–就像一个画家在墙上作画–后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的zPosition，就可以把图层向相机方向前置，于是它就在所有其他图层的前面了（或者至少是小于它的zPosition值的图层的前面）。</p>
<p>这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。</p>
<p>图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-68e4281dd52477ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.8.png"><br>我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的zPosition（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给zPosition提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。</p>
<p>#####清单3.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *greenView;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *redView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       ￼</div><div class="line">       //move the green view zPosition nearer to the camera</div><div class="line">       self.greenView.layer.zPosition = 1.0f;</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-e7ea5f6f69f43a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.9绿色视图被绘制在红色视图的前面.png"></p>
<ul>
<li>####<strong>Hit Testing</strong></li>
</ul>
<p> 第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。</p>
<p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：-containsPoint:和-hitTest:。</p>
<p>-containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用-containsPoint:方法来判断到底是白色还是蓝色的图层被触摸了 （图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>
<p>#####清单3.4 使用containsPoint判断被点击的图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">   @property (nonatomic, weak) CALayer *blueLayer;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //create sublayer</div><div class="line">       self.blueLayer = [CALayer layer];</div><div class="line">       self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">       self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">       //add it to our view</div><div class="line">       [self.layerView.layer addSublayer:self.blueLayer];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">   &#123;</div><div class="line">       //get touch position relative to main view</div><div class="line">       CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">       //convert point to the white layer&apos;s coordinates</div><div class="line">       point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];</div><div class="line">       //get layer using containsPoint:</div><div class="line">       if ([self.layerView.layer containsPoint:point]) &#123;</div><div class="line">           //convert point to blueLayer’s coordinates</div><div class="line">           point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];</div><div class="line">           if ([self.blueLayer containsPoint:point]) &#123;</div><div class="line">               [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                           message:nil</div><div class="line">                                          delegate:nil</div><div class="line">                                 cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                                 otherButtonTitles:nil] show];</div><div class="line">           &#125; else &#123;</div><div class="line">               [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                           message:nil</div><div class="line">                                          delegate:nil</div><div class="line">                                 cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                                 otherButtonTitles:nil] show];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-71820c2c4fb8faac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.10点击图层被正确标识.png"></p>
<p>-hitTest:方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用-containsPoint:那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用-hitTest:方法被点击图层的代码如清单3.5所示。</p>
<p>#####使用hitTest判断被点击的图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //get touch position</div><div class="line">    CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">    //get touched layer</div><div class="line">    CALayer *layer = [self.layerView.layer hitTest:point];</div><div class="line">    //get layer using hitTest</div><div class="line">    if (layer == self.blueLayer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125; else if (layer == self.layerView.layer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 注意当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。</p>
<ul>
<li>####<strong>自动布局属性</strong></li>
</ul>
<p>你可能用过UIViewAutoresizingMask类型的一些常量，应用于当父视图改变尺寸的时候，相应UIView的frame也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了自动排版机制，它和自动调整不同，并且更加复杂。在Mac OS平台，CALayer有一个叫做layoutManager的属性可以通过CALayoutManager协议和CAConstraintLayoutManager类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraintAPI，但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数：<br><code>- (void)layoutSublayersOfLayer:(CALayer *)layer;</code></p>
<p>#####总结<br> 本章涉及了CALayer的集合结构，包括它的frame，position和bounds，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/04/CoreAnimation视觉效果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/04/CoreAnimation视觉效果/" itemprop="url">CoreAnimation视觉效果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-04T20:19:35+08:00">
                2016-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>嗯，圆和椭圆还不错，但如果是带圆角的矩形呢<br>我们现在能做到那样了么？<br>史蒂芬·乔布斯</p>
</blockquote>
<p>我们在第三章『图层几何学』中讨论了图层的frame，第二章『寄宿图』则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。</p>
<ul>
<li>####<strong>圆角</strong></li>
</ul>
<p>圆角矩形是<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角举行的方法。恭喜你，猜对了。<br>CALayer有一个叫做conrnerRadius的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把masksToBounds设置成YES的话，图层里面的所有东西都会被截取。</p>
<p>我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-07f645d5d7004552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1.png"></p>
<p>然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果</p>
<p>#####清单4.1 设置cornerRadius和masksToBounds<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;￼￼￼</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //set the corner radius on our layers</div><div class="line">        self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">        self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">        </div><div class="line">        //enable clipping on the second layer</div><div class="line">        self.layerView2.layer.masksToBounds = YES;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-3a0579b2db95b743.png" alt="4.2.png"><br>如你所见，右边的子视图沿边界被裁剪了。<br>单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者CAShapeLayer（见第六章『专用图层』）。</p>
<ul>
<li>####<strong>图层边框</strong></li>
</ul>
<p> CALayer另外两个非常有用属性就是borderWidth和borderColor。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的bounds绘制，同时也包含图层的角。</p>
<p>borderWidth是以点为单位的定义边框粗细的浮点数，默认为0.borderColor定义了边框的颜色，默认为黑色。</p>
<p>borderColor是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了borderColor，虽然属性声明并不能证明这一点。CGColorRef在引用/释放时候的行为表现得与NSObject极其相似。但是Objective-C语法并不支持这一做法，所以CGColorRef属性即便是强引用也只能通过assign关键字来声明。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.</p>
<p>#####清单4.2 加上边框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       </div><div class="line">       //set the corner radius on our layers</div><div class="line">       self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">       self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">       </div><div class="line">       //add a border to our layers</div><div class="line">       self.layerView1.layer.borderWidth = 5.0f;</div><div class="line">       self.layerView2.layer.borderWidth = 5.0f;</div><div class="line">       </div><div class="line">       //enable clipping on the second layer</div><div class="line">       self.layerView2.layer.masksToBounds = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c76368bfcc883724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.3.png"><br>仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-767f323d4a8bcdb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.4.png"></p>
<ul>
<li>####<strong>contentsScale属性</strong></li>
</ul>
<p> iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。</p>
<p>给shadowOpacity属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：shadowColor，shadowOffset和shadowRadius。</p>
<p>显而易见，shadowColor属性控制着阴影的颜色，和borderColor和backgroundColor一样，它的类型也是CGColorRef。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。</p>
<p>shadowOffset属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。shadowOffset的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p>为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，shadowOffset的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-209274f1478b34a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.5.png"></p>
<p>苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。</p>
<p>shadowRadius属性控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。</p>
<p>通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给shadowRadius<br>设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-be8052dd45ee1287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.6.png"></p>
<ul>
<li>####<strong>阴影裁剪</strong></li>
</ul>
<p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-55db4a5ddd630e6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.7.png"></p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d6faa3736b29968d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.8.png"></p>
<p> 从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用masksToBounds裁剪内容的内图层。</p>
<p>如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-4c8e77c6cf05751f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.9.png"></p>
<p>我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。</p>
<p>#####清单4.3 用一个额外的视图来解决阴影裁切的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *shadowView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   ￼</div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       </div><div class="line">       //set the corner radius on our layers</div><div class="line">       self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">       self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">       </div><div class="line">       //add a border to our layers</div><div class="line">       self.layerView1.layer.borderWidth = 5.0f;</div><div class="line">       self.layerView2.layer.borderWidth = 5.0f;</div><div class="line">       </div><div class="line">       //add a shadow to layerView1</div><div class="line">       self.layerView1.layer.shadowOpacity = 0.5f;</div><div class="line">       self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);</div><div class="line">       self.layerView1.layer.shadowRadius = 5.0f;</div><div class="line">       </div><div class="line">       //add same shadow to shadowView (not layerView2)</div><div class="line">       self.shadowView.layer.shadowOpacity = 0.5f;</div><div class="line">       self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);</div><div class="line">       self.shadowView.layer.shadowRadius = 5.0f;</div><div class="line">       </div><div class="line">       //enable clipping on the second layer</div><div class="line">       self.layerView2.layer.masksToBounds = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-fd2670824eb2870b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.10.png"></p>
<ul>
<li><p>####<strong>shadowPath属性</strong></p>
<p>我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</p>
</li>
</ul>
<p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个shadowPath来提高性能。shadowPath是一个CGPathRef类型（一个指向CGPath的指针）。CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</p>
<p>图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。</p>
<p>#####清单4.4 创建简单的阴影形状<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //enable layer shadows</div><div class="line">    self.layerView1.layer.shadowOpacity = 0.5f;</div><div class="line">    self.layerView2.layer.shadowOpacity = 0.5f;</div><div class="line">    </div><div class="line">    //create a square shadow</div><div class="line">    CGMutablePathRef squarePath = CGPathCreateMutable();</div><div class="line">    CGPathAddRect(squarePath, NULL, self.layerView1.bounds);</div><div class="line">    self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);</div><div class="line">    </div><div class="line">    ￼//create a circular shadow</div><div class="line">    CGMutablePathRef circlePath = CGPathCreateMutable();</div><div class="line">    CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);</div><div class="line">    self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-eb06f611b0a94d9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.11.png"></p>
<p>如果是一个矩形或者是圆，用CGPath会相当简单明了。但是如果是更加复杂一点的图形，UIBezierPath类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<ul>
<li>####<strong>图层蒙板</strong></li>
</ul>
<p> 通过masksToBounds属性，我们可以沿边界裁剪图形；通过cornerRadius属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>
<p>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</p>
<p>CALayer有一个属性叫做mask可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，mask图层定义了父图层的部分可见区域。</p>
<p>mask图层的Color属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）</p>
<p>如果mask图层比父图层要小，只有在mask图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-15fab782b87c7c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.12.png"><br>我们将代码演示一下这个过程，创建一个简单的项目，通过图层的mask属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。</p>
<p>#####清单4.5 应用蒙板图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *imageView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //create mask layer</div><div class="line">    CALayer *maskLayer = [CALayer layer];</div><div class="line">    maskLayer.frame = self.layerView.bounds;</div><div class="line">    UIImage *maskImage = [UIImage imageNamed:@&quot;Cone.png&quot;];</div><div class="line">    maskLayer.contents = (__bridge id)maskImage.CGImage;</div><div class="line">    </div><div class="line">    //apply mask to image layer￼</div><div class="line">    self.imageView.layer.mask = maskLayer;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-260195fb443dc625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.13.png"><br>CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为mask属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。</p>
<ul>
<li>####<strong>拉伸过滤</strong></li>
</ul>
<p>最后我们再来谈谈minificationFilter和magnificationFilter<br>属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：</p>
<ul>
<li>能够显示最好的画质，像素既没有被压缩也没有被拉伸。</li>
<li>能更好的使用内存，因为这就是所有你要存储的东西。</li>
<li>最好的性能表现，CPU不需要为此额外的计算。</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。<br>当图片需要显示不同的大小的时候，有一种叫做拉伸过滤的<a href="http://lib.csdn.net/base/31" target="_blank" rel="noopener">算法</a>就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。<br>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。CALayer为此提供了三种拉伸过滤方法，他们是：</p>
<ul>
<li>kCAFilterLinear</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>
<p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。<br>kCAFilterTrilinear和kCAFilterLinear非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-627fcecfb98c98cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.14.png"></p>
<p>kCAFilterNearest是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重<br><img src="http://upload-images.jianshu.io/upload_images/1694376-14ccad89e4e169b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.15.png"></p>
<pre><code>图4.15 对于没有斜线的小图来说，最近过滤算法要好很多
</code></pre><p> 总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。</p>
<p>让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-abd590ea7cc36114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.16.png"></p>
<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个IBOutletCollection对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。</p>
<p>####清单4.6 显示一个LCD风格的时钟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;</div><div class="line">   @property (nonatomic, weak) NSTimer *timer;</div><div class="line">   ￼￼</div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad]; //get spritesheet image</div><div class="line">       UIImage *digits = [UIImage imageNamed:@&quot;Digits.png&quot;];</div><div class="line">       </div><div class="line">       //set up digit views</div><div class="line">       for (UIView *view in self.digitViews) &#123;</div><div class="line">           //set contents</div><div class="line">           view.layer.contents = (__bridge id)digits.CGImage;</div><div class="line">           view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);</div><div class="line">           view.layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       //start timer</div><div class="line">       self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">       </div><div class="line">       //set initial clock time</div><div class="line">       [self tick];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)setDigit:(NSInteger)digit forView:(UIView *)view</div><div class="line">   &#123;</div><div class="line">       //adjust contentsRect to select correct digit</div><div class="line">       view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)tick</div><div class="line">   &#123;</div><div class="line">       //convert time to hours, minutes and seconds</div><div class="line">       NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];</div><div class="line">       NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">       ￼</div><div class="line">       NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">       </div><div class="line">       //set hours</div><div class="line">       [self setDigit:components.hour / 10 forView:self.digitViews[0]];</div><div class="line">       [self setDigit:components.hour % 10 forView:self.digitViews[1]];</div><div class="line">       </div><div class="line">       //set minutes</div><div class="line">       [self setDigit:components.minute / 10 forView:self.digitViews[2]];</div><div class="line">       [self setDigit:components.minute % 10 forView:self.digitViews[3]];</div><div class="line">       </div><div class="line">       //set seconds</div><div class="line">       [self setDigit:components.second / 10 forView:self.digitViews[4]];</div><div class="line">       [self setDigit:components.second % 10 forView:self.digitViews[5]];</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-7dbef1a2760e625b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.18.png"></p>
<p>为了能像图4.19中那样，我们需要在for循环中加入如下代码：<br><code>view.layer.magnificationFilter = kCAFilterNearest;</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-43f21dbace80a1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.19.png"></p>
<ul>
<li>####<strong>组透明</strong></li>
</ul>
<p> UIView有一个叫做alpha的属性来确定视图的透明度。CALayer有一个等同的属性叫做opacity，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
<p>iOS常见的做法是把一个空间的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-8828828bb87444dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.20.png"></p>
<p> 这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>
<p>在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。</p>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的UIViewGroupOpacity为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果UIViewGroupOpacity并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。</p>
<p>另一个方法就是，你可以设置CALayer的一个叫做shouldRasterize属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。</p>
<p>为了启用shouldRasterize属性，我们设置了图层的rasterizationScale属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了shouldRasterize属性，你就要确保你设置了rasterizationScale属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>
<p>当shouldRasterize和UIViewGroupOpacity一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。</p>
<p>#####清单4.7 使用shouldRasterize属性解决组透明问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">    @interface ViewController ()</div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (UIButton *)customButton</div><div class="line">    &#123;</div><div class="line">        //create button</div><div class="line">        CGRect frame = CGRectMake(0, 0, 150, 50);</div><div class="line">        UIButton *button = [[UIButton alloc] initWithFrame:frame];</div><div class="line">        button.backgroundColor = [UIColor whiteColor];</div><div class="line">        button.layer.cornerRadius = 10;</div><div class="line">        </div><div class="line">        //add label</div><div class="line">        frame = CGRectMake(20, 10, 110, 30);</div><div class="line">        UILabel *label = [[UILabel alloc] initWithFrame:frame];</div><div class="line">        label.text = @&quot;Hello World&quot;;</div><div class="line">        label.textAlignment = NSTextAlignmentCenter;</div><div class="line">        [button addSubview:label];</div><div class="line">        return button;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //create opaque button</div><div class="line">        UIButton *button1 = [self customButton];</div><div class="line">        button1.center = CGPointMake(50, 150);</div><div class="line">        [self.containerView addSubview:button1];</div><div class="line">        </div><div class="line">        //create translucent button</div><div class="line">        UIButton *button2 = [self customButton];</div><div class="line">        ￼</div><div class="line">        button2.center = CGPointMake(250, 150);</div><div class="line">        button2.alpha = 0.5;</div><div class="line">        [self.containerView addSubview:button2];</div><div class="line">        </div><div class="line">        //enable rasterization for the translucent button</div><div class="line">        button2.layer.shouldRasterize = YES;</div><div class="line">        button2.layer.rasterizationScale = [UIScreen mainScreen].scale;</div><div class="line">    &#125;</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-006797526c30dcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.21.png"></p>
<p>#####总结<br> 这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。</p>
<p>在第五章，『变换』中，我们将会研究图层变化和3D转换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/03/CoreAnimation框架目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/03/CoreAnimation框架目录/" itemprop="url">CoreAnimation框架目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-03T20:19:35+08:00">
                2016-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目录纵览"><a href="#目录纵览" class="headerlink" title="目录纵览"></a>目录纵览</h1><h4 id="第一章：图层树"><a href="#第一章：图层树" class="headerlink" title="第一章：图层树"></a>第一章：图层树</h4><ul>
<li>图层与视图</li>
<li>图层的能力</li>
<li>使用图层<br>总结 链接：<a href="http://www.jianshu.com/p/8447e0c24df1" target="_blank" rel="noopener">图层树</a><h4 id="第二章：寄宿图"><a href="#第二章：寄宿图" class="headerlink" title="第二章：寄宿图"></a>第二章：寄宿图</h4></li>
<li>contents属性</li>
<li>Custom Drawing （自定义绘制）<br>总结 链接：<a href="http://www.jianshu.com/p/fea670e92e9e" target="_blank" rel="noopener">寄宿图</a><h4 id="第三章：图层几何学"><a href="#第三章：图层几何学" class="headerlink" title="第三章：图层几何学"></a>第三章：图层几何学</h4></li>
<li>布局</li>
<li><a href="http://www.jianshu.com/p/52dfc061ff7f" target="_blank" rel="noopener">锚点</a></li>
<li>坐标系</li>
<li>Hit Testing</li>
<li>自动布局<br>总结 链接：<a href="http://www.jianshu.com/p/ffee86d98d58" target="_blank" rel="noopener">图层几何学</a><h4 id="第五章：视觉效果"><a href="#第五章：视觉效果" class="headerlink" title="第五章：视觉效果"></a>第五章：视觉效果</h4></li>
<li>圆角</li>
<li>图层边框</li>
<li>阴影</li>
<li><a href="http://www.jianshu.com/p/26e7803f057b" target="_blank" rel="noopener">图层蒙版</a></li>
<li>拉伸过滤</li>
<li>组透明<br>总结 链接：<a href="http://www.jianshu.com/p/b556af4a3c7d" target="_blank" rel="noopener">视觉效果</a></li>
</ul>
<h4 id="第五章：变换"><a href="#第五章：变换" class="headerlink" title="第五章：变换"></a>第五章：变换</h4><ul>
<li>仿射变换</li>
<li>图层边框</li>
<li>3D对象</li>
<li>固体对象<br>总结 链接：<a href="http://www.jianshu.com/p/ff380a2658fa" target="_blank" rel="noopener">变换</a><h4 id="第六章：专用图层"><a href="#第六章：专用图层" class="headerlink" title="第六章：专用图层"></a>第六章：专用图层</h4></li>
<li><a href="http://www.jianshu.com/p/16fd028ee636" target="_blank" rel="noopener">CAShapeLayer</a></li>
<li>CATextLayer</li>
<li>CATransformLayer</li>
<li><a href="http://www.jianshu.com/p/0e0ff206f110" target="_blank" rel="noopener">CAReplicatorLayer</a></li>
<li>CAScrollLayer</li>
<li><a href="http://www.jianshu.com/p/03095391e301" target="_blank" rel="noopener">CAEmitterLayer</a></li>
<li>CAEAGLLayer</li>
<li>AVPlayerLayer<br>总结 链接：<a href="http://www.jianshu.com/p/826e593d82b6" target="_blank" rel="noopener">专用图层</a><h4 id="第七章：隐式动画"><a href="#第七章：隐式动画" class="headerlink" title="第七章：隐式动画"></a>第七章：隐式动画</h4></li>
<li>事务</li>
<li>完成块</li>
<li>图层行为</li>
<li>呈现与模型<br>总结 链接：<a href="http://www.jianshu.com/p/0e082382a612" target="_blank" rel="noopener">隐式动画</a><h4 id="第八章：显式动画"><a href="#第八章：显式动画" class="headerlink" title="第八章：显式动画"></a>第八章：显式动画</h4></li>
<li><a href="http://www.jianshu.com/p/73f87913c18d" target="_blank" rel="noopener">属性动画</a></li>
<li>动画组</li>
<li>过渡</li>
<li>在动画过程中取消动画<br>总结 链接：<a href="http://www.jianshu.com/p/1e1364839b20" target="_blank" rel="noopener">显式动画</a><h4 id="第九章：图层时间"><a href="#第九章：图层时间" class="headerlink" title="第九章：图层时间"></a>第九章：图层时间</h4></li>
<li>CAMediaTiming 协议</li>
<li>层级关系时间</li>
<li>手动动画<br>总结 链接：<a href="http://www.jianshu.com/p/7bfe1ef1fb5b" target="_blank" rel="noopener">图层时间</a><h4 id="第十章：缓冲"><a href="#第十章：缓冲" class="headerlink" title="第十章：缓冲"></a>第十章：缓冲</h4></li>
<li>动画速度</li>
<li>自定义缓冲函数<br>总结 链接：<a href="http://www.jianshu.com/p/39d1f739e2c9" target="_blank" rel="noopener">缓冲</a><h4 id="第十一章：基于定时器的动画"><a href="#第十一章：基于定时器的动画" class="headerlink" title="第十一章：基于定时器的动画"></a>第十一章：基于定时器的动画</h4></li>
<li>定时帧</li>
<li>物理模拟<br>总结 链接：<a href="http://www.jianshu.com/p/761bece1c5a6" target="_blank" rel="noopener">基于定时器的动画</a><h4 id="第十二章：性能调优"><a href="#第十二章：性能调优" class="headerlink" title="第十二章：性能调优"></a>第十二章：性能调优</h4></li>
<li>CPU VS GPU</li>
<li>测量，而不是猜测</li>
<li>Instruments<br>总结 链接：<a href="http://www.jianshu.com/p/8874ec25c302" target="_blank" rel="noopener">性能调优</a><h4 id="第十三章：高效绘图"><a href="#第十三章：高效绘图" class="headerlink" title="第十三章：高效绘图"></a>第十三章：高效绘图</h4></li>
<li>软件绘图</li>
<li>矢量图形</li>
<li>脏矩形</li>
<li>异步绘制<br>总结 链接：<a href="http://www.jianshu.com/p/974eb333020a" target="_blank" rel="noopener">高效绘图</a><h4 id="第十四章：图像IO"><a href="#第十四章：图像IO" class="headerlink" title="第十四章：图像IO"></a>第十四章：图像IO</h4></li>
<li>加载和潜伏</li>
<li>缓存</li>
<li>文件格式<br>总结 链接：<a href="http://www.jianshu.com/p/1cb402c1bbba" target="_blank" rel="noopener">图像IO</a><h4 id="第十五章：图层性能"><a href="#第十五章：图层性能" class="headerlink" title="第十五章：图层性能"></a>第十五章：图层性能</h4></li>
<li>隐式绘制</li>
<li>离屏渲染</li>
<li>混合和过渡绘制</li>
<li>减少和过渡绘制<br>总结</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/02/CoreAnimation寄宿图/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/02/CoreAnimation寄宿图/" itemprop="url">CoreAnimation寄宿图</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-02T20:19:35+08:00">
                2016-05-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>###寄宿图</p>
</blockquote>
<p>我们在第一章『图层树』中介绍了CALayer类并创建了一个简单的有蓝色背景的图层。背景颜色还好啦，但是如果它仅仅是展现了一个单调的颜色未免也太无聊了。事实上CALayer类能够包含一张你喜欢的图片，这一章节我们将来探索CALayer的寄宿图（即图层中包含的图）。</p>
<ul>
<li>####<strong>contents属性</strong></li>
</ul>
<p>CALayer 有一个属性叫做contents，这个属性的类型被定义为id，意味着它可以是任何类型的对象。在这种情况下，你可以给contents属性赋任何值，你的app仍然能够编译通过。但是，在实践中，如果你给contents赋的不是CGImage，那么你得到的图层将是空白的。<br>contents这个奇怪的表现是由Mac OS的历史原因造成的。它之所以被定义为id类型，是因为在Mac OS系统上，这个属性对CGImage和NSImage类型的值都起作用。如果你试图在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>平台上将UIImage的值赋给它，只能得到一个空白的图层。一些初识Core Animation的iOS开发者可能会对这个感到困惑。<br>头疼的不仅仅是我们刚才提到的这个问题。事实上，你真正要赋值的类型应该是CGImageRef，它是一个指向CGImage结构的指针。UIImage有一个CGImage属性，它返回一个”CGImageRef”,如果你想把这个值直接赋值给CALayer的contents，那你将会得到一个编译错误。因为CGImageRef并不是一个真正的Cocoa对象，而是一个Core Foundation类型。<br>尽管Core Foundation类型跟Cocoa对象在运行时貌似很像（被称作toll-free bridging），他们并不是类型兼容的，不过你可以通过bridged关键字转换。如果要给图层的寄宿图赋值，你可以按照以下这个方法：<br><code>layer.contents = (__bridge id)image.CGImage;</code><br> 如果你没有使用ARC（自动引用计数），你就不需要__bridge这部分。但是，你干嘛不用ARC？！</p>
<p>让我们来继续修改我们在第一章新建的工程，以便能够展示一张图片而不仅仅是一个背景色。我们已经用代码的方式建立一个图层，那我们就不需要额外的图层了。那么我们就直接把layerView的宿主图层的contents属性设置成图片。</p>
<p>#####清单2.1 更新后的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad]; //load an image</div><div class="line">        UIImage *image = [UIImage imageNamed:@&quot;Snowman&quot;];</div><div class="line">        //add it directly to our view&apos;s layer</div><div class="line">        self.layerView.layer.contents = (__bridge id)image.CGImage;</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-693d5c2da9328e26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图.png"></p>
<pre><code>在UIView的宿主图层中显示一张图片
</code></pre><p>我们用这些简单的代码做了一件很有趣的事情：我们利用CALayer在一个普通的UIView中显示了一张图片。这不是一个UIImageView，它不是我们通常用来展示图片的方法。通过直接操作图层，我们使用了一些新的函数，使得UIView更加有趣了。</p>
<ul>
<li>####<strong>contentGravity属性</strong></li>
</ul>
<p>你可能已经注意到了我们的雪人看起来有点。。。胖 ＝＝！ 我们加载的图片并不刚好是一个方的，为了适应这个视图，它有一点点被拉伸了。在使用UIImageView的时候遇到过同样的问题，解决方法就是把contentMode属性设置成更合适的值，像这样：<br><code>view.contentMode = UIViewContentModeScaleAspectFit;</code></p>
<p>这个方法基本和我们遇到的情况的解决方法已经接近了（你可以试一下 :) ），不过UIView大多数视觉相关的属性比如contentMode，对这些属性的操作其实是对对应图层的操作。</p>
<p>CALayer与contentMode对应的属性叫做contentsGravity，但是它是一个NSString类型，而不是像对应的UIKit部分，那里面的值是枚举。contentsGravity可选的常量值有以下一些：</p>
<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>
<p>和cotentMode一样，contentsGravity的目的是为了决定内容在图层的边界中怎么对齐，我们将使用kCAGravityResizeAspect，它的效果等同于UIViewContentModeScaleAspectFit， 同时它还能在图层中等比例拉伸以适应图层的边界。</p>
<p><code>self.layerView.layer.contentsGravity = kCAGravityResizeAspect;</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6c0ffcad9d3f428c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.png"></p>
<ul>
<li>####<strong>contentsScale属性</strong></li>
</ul>
<p>contentsScale属性定义了寄宿图的像素尺寸和视图大小的比例，默认情况下它是一个值为1.0的浮点数。</p>
<p>contentsScale的目的并不是那么明显。它并不是总会对屏幕上的寄宿图有影响。如果你尝试对我们的例子设置不同的值，你就会发现根本没任何影响。因为contents由于设置了contentsGravity<br>属性，所以它已经被拉伸以适应图层的边界。</p>
<p>如果你只是单纯地想放大图层的contents图片，你可以通过使用图层的transform和affineTransform属性来达到这个目的（见第五章『Transforms』，里面对此有解释），这(指放大)也不是contengsScale的目的所在.</p>
<p>contentsScale属性其实属于支持高分辨率（又称Hi-DPI或Retina）屏幕机制的一部分。它用来判断在绘制图层的时候应该为寄宿图创建的空间大小，和需要显示的图片的拉伸度（假设并没有设contentsGravity<br>属性）。UIView有一个类似功能但是非常少用到contentScaleFactor<br>属性。</p>
<p>如果contentsScale设置为1.0，将会以每个点1个像素绘制图片，如果设置为2.0，则会以每个点2个像素绘制图片，这就是我们熟知的Retina屏幕。（如果你对像素和点的概念不是很清楚的话，这个章节的后面部分将会对此做出解释）。</p>
<p>这并不会对我们在使用kCAGravityResizeAspect时产生任何影响，因为它就是拉伸图片以适应图层而已，根本不会考虑到分辨率问题。但是如果我们把contentsGravity设置为kCAGravityCenter（这个值并不会拉伸图片），那将会有很明显的变化（如图2.3）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-e88c0aaf84f3b8e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.3.png"></p>
<pre><code>用错误的contentsScale属性显示Retina图片
</code></pre><p>如你所见，我们的雪人不仅有点大还有点像素的颗粒感。那是因为和UIImage不同，CGImage没有拉伸的概念。当我们使用UIImage类去读取我们的雪人图片的时候，他读取了高质量的Retina版本的图片。但是当我们用CGImage来设置我们的图层的内容时，拉伸这个因素在转换的时候就丢失了。不过我们可以通过手动设置contentsScale来修复这个问题（如2.2清单），图2.4是结果</p>
<p>#####清单2.4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad]; //load an image</div><div class="line">        UIImage *image = [UIImage imageNamed:@&quot;Snowman.png&quot;]; //add it directly to our view&apos;s layer</div><div class="line">        self.layerView.layer.contents = (__bridge id)image.CGImage; //center the image</div><div class="line">        self.layerView.layer.contentsGravity = kCAGravityCenter;</div><div class="line">        </div><div class="line">        //set the contentsScale to match image</div><div class="line">        self.layerView.layer.contentsScale = image.scale;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d6cc02bde6e0ac3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.4.正确的contentsScale之后"><br>当用代码的方式来处理寄宿图的时候，一定要记住要手动的设置图层的contentsScale属性，否则，你的图片在Retina设备上就显示得不正确啦。代码如下：<br><code>layer.contentsScale = [UIScreen mainScreen].scale;</code></p>
<ul>
<li>####<strong>maskToBounds属性</strong></li>
</ul>
<p>现在我们的雪人总算是显示了正确的大小，不过你也许已经发现了另外一些事情：他超出了视图的边界。默认情况下，UIView仍然会绘制超过边界的内容或是子视图，在CALayer下也是这样的。</p>
<p>UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做masksToBounds，把它设置为YES，雪人就在边界里啦～（如图2.5）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-f3fe22588c2a354e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.5.png"></p>
<ul>
<li>####<strong>contentsRect属性</strong></li>
</ul>
<p>CALayer的contentsRect属性允许我们在图层边框里显示寄宿图的一个子域。这涉及到图片是如何显示和拉伸的，所以要contentsGravity<br>灵活多了和bounds，frame不同，contentsRect不是按点来计算的，它使用了单位坐标，单位坐标指定在0到1之间，是一个相对值（像素和点就是绝对值）。所以他们是相对与寄宿图的尺寸的。iOS使用了以下的坐标系统：</p>
<ul>
<li>点 —— 在iOS和Mac OS中最常见的坐标体系。点就像是虚拟的像素，也被称作逻辑像素。在标准设备上，一个点就是一个像素，但是在Retina设备上，一个点等于2*2个像素。iOS用点作为屏幕的坐标测算体系就是为了在Retina设备和普通设备上能有一致的视觉效果。</li>
<li>像素 —— 物理像素坐标并不会用来屏幕布局，但是仍然与图片有相对关系。UIImage是一个屏幕分辨率解决方案，所以指定点来度量大小。但是一些底层的图片表示如CGImage就会使用像素，所以你要清楚在Retina设备和普通设备上，他们表现出来了不同的大小。</li>
<li>单位 —— 对于与图片大小或是图层边界相关的显示，单位坐标是一个方便的度量方式， 当大小改变的时候，也不需要再次调整。单位坐标在OpenGL这种纹理坐标系统中用得很多，Core Animation中也用到了单位坐标。</li>
</ul>
<p>默认的contentsRect是{0, 0, 1, 1}，这意味着整个寄宿图默认都是可见的，如果我们指定一个小一点的矩形，图片就会被裁剪（如图2.6）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d1c60386893f5477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.6.png"></p>
<p>事实上给contentsRect设置一个负数的原点或是大于{1, 1}的尺寸也是可以的。这种情况下，最外面的像素会被拉伸以填充剩下的区域。</p>
<p>contentsRect在app中最有趣的地方在于一个叫做image sprites（图片拼合）的用法。如果你有游戏编程的经验，那么你一定对图片拼合的概念很熟悉，图片能够在屏幕上独立地变更位置。抛开游戏编程不谈，这个技术常用来指代载入拼合的图片，跟移动图片一点关系也没有。</p>
<p>典型地，图片拼合后可以打包整合到一张大图上一次性载入。相比多次载入不同的图片，这样做能够带来很多方面的好处：内存使用，载入时间，渲染性能等等</p>
<p>2D游戏引擎入Cocos2D使用了拼合技术，它使用OpenGL来显示图片。不过我们可以使用拼合在一个普通的UIKit应用中，对！就是使用contentsRect</p>
<p>首先，我们需要一个拼合后的图表 —— 一个包含小一些的拼合图的大图片。如图2.7所示：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-064197033685be51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.7.png"></p>
<p> 接下来，我们要在app中载入并显示这些拼合图。规则很简单：像平常一样载入我们的大图，然后把它赋值给四个独立的图层的contents，然后设置每个图层的contentsRect来去掉我们不想显示的部分。</p>
<p>我们的工程中需要一些额外的视图。（为了避免太多代码。我们将使用Interface Builder来拜访他们的位置，如果你愿意还是可以用代码的方式来实现的）。清单2.3有需要的代码，图2.8展示了结果</p>
<p>#####清单2.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *coneView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *shipView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *iglooView;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *anchorView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)addSpriteImage:(UIImage *)image withContentRect:(CGRect)rect ￼toLayer:(CALayer *)layer //set image</div><div class="line">&#123;</div><div class="line">    layer.contents = (__bridge id)image.CGImage;</div><div class="line">    </div><div class="line">    //scale contents to fit</div><div class="line">    layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">    </div><div class="line">    //set contentsRect</div><div class="line">    layer.contentsRect = rect;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad]; //load sprite sheet</div><div class="line">    UIImage *image = [UIImage imageNamed:@&quot;Sprites.png&quot;];</div><div class="line">    //set igloo sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0, 0, 0.5, 0.5) toLayer:self.iglooView.layer];</div><div class="line">    //set cone sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0, 0.5, 0.5) toLayer:self.coneView.layer];</div><div class="line">    //set anchor sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0, 0.5, 0.5, 0.5) toLayer:self.anchorView.layer];</div><div class="line">    //set spaceship sprite</div><div class="line">    [self addSpriteImage:image withContentRect:CGRectMake(0.5, 0.5, 0.5, 0.5) toLayer:self.shipView.layer];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-df8cb36dcbaefaa1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图2.8.png"></p>
<p>拼合不仅给app提供了一个整洁的载入方式，还有效地提高了载入性能（单张大图比多张小图载入地更快），但是如果有手动安排的话，他们还是有一些不方便的，如果你需要在一个已经创建好的品和图上做一些尺寸上的修改或者其他变动，无疑是比较麻烦的。<br>Mac上有一些商业软件可以为你自动拼合图片，这些工具自动生成一个包含拼合后的坐标的XML或者plist文件，拼合图片的使用大大简化。这个文件可以和图片一同载入，并给每个拼合的图层设置contentsRect，这样开发者就不用手动写代码来摆放位置了。<br>这些文件通常在OpenGL游戏中使用，不过呢，你要是有兴趣在一些常见的app中使用拼合技术，那么一个叫做LayerSprites的开源库（<a href="https://github.com/nicklockwood/LayerSprites" target="_blank" rel="noopener">https://github.com/nicklockwood/LayerSprites</a>)，它能够读取Cocos2D格式中的拼合图并在普通的Core Animation层中显示出来。</p>
<ul>
<li>####<strong>contentsCenter属性</strong></li>
</ul>
<p> 本章我们介绍的最后一个和内容有关的属性是contentsCenter，看名字你可能会以为它可能跟图片的位置有关，不过这名字着实误导了你。contentsCenter其实是一个CGRect，它定义了一个固定的边框和一个在图层上可拉伸的区域。 改变contentsCenter的值并不会影响到寄宿图的显示，除非这个图层的大小改变了，你才看得到效果。</p>
<p>默认情况下，contentsCenter是{0, 0, 1, 1}，这意味着如果大小（由conttensGravity决定）改变了,那么寄宿图将会均匀地拉伸开。但是如果我们增加原点的值并减小尺寸。我们会在图片的周围创造一个边框。图2.9展示了contentsCenter设置为{0.25, 0.25, 0.5, 0.5}的效果。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-ba74d68cdfe19927.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.9.png"><br>这意味着我们可以随意重设尺寸，边框仍然会是连续的。他工作起来的效果和UIImage里的-resizableImageWithCapInsets: 方法效果非常类似，只是它可以运用到任何寄宿图，甚至包括在Core Graphics运行时绘制的图形（本章稍后会讲到）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d062cb97b49f705c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.10.png"></p>
<p> 清单2.4 演示了如何编写这些可拉伸视图。不过，contentsCenter的另一个很酷的特性就是，它可以在Interface Builder里面配置，根本不用写代码。如图2.11</p>
<p>####清单2.4</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-ba4b083cc0841e22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.11.png"></p>
<ul>
<li>####<strong>Custome Drawing属性</strong></li>
</ul>
<p> 给contents赋CGImage的值不是唯一的设置寄宿图的方法。我们也可以直接用Core Graphics直接绘制寄宿图。能够通过继承UIView并实现-drawRect:方法来自定义绘制。</p>
<p>-drawRect: 方法没有默认的实现，因为对UIView来说，寄宿图并不是必须的，它不在意那到底是单调的颜色还是有一个图片的实例。如果UIView检测到-drawRect: 方法被调用了，它就会为视图分配一个寄宿图，这个寄宿图的像素尺寸等于视图大小乘以 contentsScale的值。</p>
<p>如果你不需要寄宿图，那就不要创建这个方法了，这会造成CPU资源和内存的浪费，这也是为什么苹果建议：如果没有自定义绘制的任务就不要在子类中写一个空的-drawRect:方法。</p>
<p>当视图在屏幕上出现的时候 -drawRect:方法就会被自动调用。-drawRect:方法里面的代码利用Core Graphics去绘制一个寄宿图，然后内容就会被缓存起来直到它需要被更新（通常是因为开发者调用了-setNeedsDisplay方法，尽管影响到表现效果的属性值被更改时，一些视图类型会被自动重绘，如bounds属性）。虽然-drawRect:方法是一个UIView方法，事实上都是底层的CALayer安排了重绘工作和保存了因此产生的图片。</p>
<p>CALayer有一个可选的delegate属性，实现了CALayerDelegate协议，当CALayer需要一个内容特定的信息时，就会从协议中请求。CALayerDelegate是一个非正式协议，其实就是说没有CALayerDelegate @protocol可以让你在类里面引用啦。你只需要调用你想调用的方法，CALayer会帮你做剩下的。（delegate属性被声明为id类型，所有的代理方法都是可选的）。</p>
<p>当需要被重绘时，CALayer会请求它的代理给他一个寄宿图来显示。它通过调用下面这个方法做到的:<br><code>(void)displayLayer:(CALayerCALayer *)layer;</code></p>
<p>趁着这个机会，如果代理想直接设置contents属性的话，它就可以这么做，不然没有别的方法可以调用了。如果代理不实现-displayLayer:方法，CALayer就会转而尝试调用下面这个方法：<br><code>- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;</code></p>
<p> 在调用这个方法之前，CALayer创建了一个合适尺寸的空寄宿图（尺寸由bounds和contentsScale决定）和一个Core Graphics的绘制上下文环境，为绘制寄宿图做准备，他作为ctx参数传入。</p>
<p>让我们来继续第一章的项目让它实现CALayerDelegate并做一些绘图工作吧（见清单2.5）.图2.12是他的结果</p>
<p>#####清单2.5实现CALayerDelegate<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        ￼</div><div class="line">        //create sublayer</div><div class="line">        CALayer *blueLayer = [CALayer layer];</div><div class="line">        blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">        blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">        </div><div class="line">        //set controller as layer delegate</div><div class="line">        blueLayer.delegate = self;</div><div class="line">        </div><div class="line">        //ensure that layer backing image uses correct scale</div><div class="line">        blueLayer.contentsScale = [UIScreen mainScreen].scale; //add layer to our view</div><div class="line">        [self.layerView.layer addSublayer:blueLayer];</div><div class="line">        </div><div class="line">        //force layer to redraw</div><div class="line">        [blueLayer display];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</div><div class="line">    &#123;</div><div class="line">        //draw a thick red circle</div><div class="line">        CGContextSetLineWidth(ctx, 10.0f);</div><div class="line">        CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);</div><div class="line">        CGContextStrokeEllipseInRect(ctx, layer.bounds);</div><div class="line">    &#125;</div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0d39dd147e3b14af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="2.12.png"></p>
<p> 注意一下一些有趣的事情：</p>
<ul>
<li>我们在blueLayer上显式地调用了-display。不同于UIView，当图层显示在屏幕上时，CALayer不会自动重绘它的内容。它把重绘的决定权交给了开发者。</li>
<li>尽管我们没有用masksToBounds属性，绘制的那个圆仍然沿边界被裁剪了。这是因为当你使用CALayerDelegate绘制寄宿图的时候，并没有对超出边界外的内容提供绘制支持。</li>
</ul>
<p>现在你理解了CALayerDelegate，并知道怎么使用它。但是除非你创建了一个单独的图层，你几乎没有机会用到CALayerDelegate协议。因为当UIView创建了它的宿主图层时，它就会自动地把图层的delegate设置为它自己，并提供了一个-displayLayer:的实现，那所有的问题就都没了。</p>
<p>当使用寄宿了视图的图层的时候，你也不必实现-displayLayer:和-drawLayer:inContext:方法来绘制你的寄宿图。通常做法是实现UIView的-drawRect:方法，UIView就会帮你做完剩下的工作，包括在需要重绘的时候调用-display方法。</p>
<p>####总结<br> 本章介绍了寄宿图和一些相关的属性。你学到了如何显示和放置图片， 使用拼合技术来显示， 以及用CALayerDelegate和Core Graphics来绘制图层内容。</p>
<p>在第三章，”图层几何学”中，我们将会探讨一下图层的几何，观察他们是如何放置和改变相互的尺寸的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/01/CAShapeLayer与UIBezierPath实现注水动画与正余弦水波纹动画,雷达扩散效果，添加购物车动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/01/CAShapeLayer与UIBezierPath实现注水动画与正余弦水波纹动画,雷达扩散效果，添加购物车动画/" itemprop="url">CAShapeLayer与UIBezierPath实现注水动画与正余弦水波纹动画，雷达扩散，添加购物车动画</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-01T20:19:35+08:00">
                2016-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>初步学习了CoreAnimation框架，总结了几个动画效果，主要是通过CAShapeLayer与贝塞尔曲线实现。<br>推荐一个大神的博客：<a href="http://kittenyang.com/" target="_blank" rel="noopener">Kitten 的时间胶囊</a>,爱好动画的可以看看。感觉数学好渣渣，是时候恶补一下了<br>先看下效果</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-729daa88f1ae1a23.gif?imageMogr2/auto-orient/strip" alt="gif.gif"></p>
<blockquote>
<p>#####<strong>扇形下载进度</strong></p>
</blockquote>
<p>要实现扇形的下载进度，有两种方法， 这里先使用第一种：<br>1.使用设置UIBezierPath的角度<br>2.使用 CAShapeLayer的stokeEnd属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//设置中心点</div><div class="line">  CGPoint point = CGPointMake(self.frame.size.width/2, self.frame.size.height/2);</div><div class="line">  </div><div class="line">  //起点位置</div><div class="line">  CGFloat startAngle = - M_PI /2;</div><div class="line">  </div><div class="line">  //结束位置</div><div class="line">  CGFloat endAngle = self.progress *M_PI *2 + startAngle;</div><div class="line">  </div><div class="line">  </div><div class="line">  UIBezierPath *path =[UIBezierPath bezierPathWithArcCenter:point radius:self.bounds.size.width/2 startAngle:startAngle endAngle:endAngle clockwise:1];</div><div class="line">  </div><div class="line">   //画一根到 圆心的线</div><div class="line">  [path addLineToPoint:point];</div><div class="line">  </div><div class="line">  </div><div class="line">  //通过layer绘制</div><div class="line">  CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">  </div><div class="line">  </div><div class="line">  layer.path = path.CGPath;</div><div class="line">  </div><div class="line">  layer.fillColor =[UIColor colorWithRed:0.47 green:0.83 blue:0.98 alpha:1].CGColor;</div><div class="line">  </div><div class="line">  [self.layer addSublayer:layer];</div></pre></td></tr></table></figure></p>
<blockquote>
<h5 id="圆形进度"><a href="#圆形进度" class="headerlink" title="圆形进度"></a><strong>圆形进度</strong></h5></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">首先 我们需要一个背景层 一个前景层，一个路径供给两个layer使用。这里我们使用改变stokeEnd 来改变圆弧的进度，代码里增加了一点渐变</div><div class="line">   self.backLayer =[CAShapeLayer layer];</div><div class="line">    self.backLayer.fillColor  =[UIColor clearColor].CGColor;</div><div class="line">    self.backLayer.frame = self.bounds;</div><div class="line">    self.backLayer.lineWidth = 4;</div><div class="line">    self.backLayer.strokeColor =[UIColor lightGrayColor].CGColor;</div><div class="line">    [self.layer addSublayer:self.backLayer];</div><div class="line">    </div><div class="line">    self.foreLayer =[CAShapeLayer layer];</div><div class="line">    self.foreLayer.fillColor  =[UIColor clearColor].CGColor;</div><div class="line">    self.foreLayer.frame = self.bounds;</div><div class="line">    self.foreLayer.strokeColor =[UIColor redColor].CGColor;</div><div class="line">    self.foreLayer.lineWidth = 4;</div><div class="line">    [self.layer addSublayer:self.foreLayer];</div><div class="line">    </div><div class="line">    </div><div class="line">    UIBezierPath *path=  [UIBezierPath bezierPathWithArcCenter:CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2) radius:self.bounds.size.width/2-2 startAngle:-M_PI_2 endAngle:M_PI *1.5 clockwise:YES];</div><div class="line">    self.backPath = path;</div><div class="line">    </div><div class="line">    self.backLayer.path = self.backPath.CGPath;</div><div class="line">    self.foreLayer.path = self.backPath.CGPath;</div><div class="line">    self.foreLayer.strokeEnd = 0;</div><div class="line">    </div><div class="line">    </div><div class="line">    self.gradientLayerLeft =[CAGradientLayer layer];</div><div class="line">    self.gradientLayerLeft.frame = self.bounds;</div><div class="line">    </div><div class="line">    self.gradientLayerLeft.colors =@[(__bridge id)[UIColor redColor].CGColor,(__bridge id)[UIColor yellowColor].CGColor,(__bridge id)[UIColor blueColor].CGColor];</div><div class="line">    self.gradientLayerLeft.locations = @[@0,@0.5,@1];</div><div class="line">    self.gradientLayerLeft.startPoint = CGPointMake(0, 0);</div><div class="line">    self.gradientLayerLeft.endPoint = CGPointMake(0, 1);</div><div class="line">    [self.layer addSublayer:self.gradientLayerLeft];</div><div class="line">  </div><div class="line">    </div><div class="line">    //设置mask</div><div class="line">    [self.gradientLayerLeft setMask:self.foreLayer];</div><div class="line">-(void)setProgressValue:(CGFloat)progressValue</div><div class="line">&#123;</div><div class="line">    _progressValue = progressValue;</div><div class="line">    self.foreLayer.strokeEnd = progressValue;</div><div class="line">    self.label.text = [NSString stringWithFormat:@&quot;%.f%%&quot;,progressValue *100];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p> #####<strong>一个加载动画</strong></p>
</blockquote>
<p>引自：<a href="http://www.jianshu.com/p/447b0de110a7" target="_blank" rel="noopener">旋转加载动画</a><br>可以重点学习下做动画的思路，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//核心代码 在动画开始的时候做一些平移旋转</div><div class="line">- (void)animationDidStart:(CAAnimation *)anim&#123;</div><div class="line">    [UIView animateWithDuration:0.3 delay:0.1 options:UIViewAnimationOptionCurveEaseOut|UIViewAnimationOptionBeginFromCurrentState animations:^&#123;</div><div class="line">        </div><div class="line">        self.ball_1.transform = CGAffineTransformMakeTranslation(-BALL_RADIUS, 0);</div><div class="line">        self.ball_1.transform = CGAffineTransformScale(self.ball_1.transform, 0.7, 0.7);</div><div class="line">        </div><div class="line">        self.ball_3.transform = CGAffineTransformMakeTranslation(BALL_RADIUS, 0);</div><div class="line">        self.ball_3.transform = CGAffineTransformScale(self.ball_3.transform, 0.7, 0.7);</div><div class="line">        </div><div class="line">        </div><div class="line">        self.ball_2.transform = CGAffineTransformScale(self.ball_2.transform, 0.7, 0.7);</div><div class="line">    &#125; completion:^(BOOL finished) &#123;</div><div class="line">        [UIView animateWithDuration:0.3 delay:0.1 options:UIViewAnimationOptionCurveEaseIn  | UIViewAnimationOptionBeginFromCurrentState animations:^&#123;</div><div class="line">            self.ball_1.transform = CGAffineTransformIdentity;</div><div class="line">            self.ball_3.transform = CGAffineTransformIdentity;</div><div class="line">            self.ball_2.transform = CGAffineTransformIdentity;</div><div class="line">        &#125; completion:NULL];</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>#####<strong>使用正余弦做的注水动画</strong></p>
</blockquote>
<p>在使用正余弦做注水动画时，先了解下正余弦<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> 正弦曲线公式可表示为y=Asin(ωx+φ)+k：</div><div class="line"> A，振幅，最高和最低的距离</div><div class="line"> W，角速度，用于控制周期大小，单位x中的起伏个数</div><div class="line"> K，偏距，曲线整体上下偏移量</div><div class="line"> φ，初相，左右移动的值</div><div class="line"> </div><div class="line"> 这个效果主要的思路是添加两条曲线 一条正玄曲线、一条余弦曲线 然后在曲线下添加深浅不同的背景颜色，从而达到波浪显示的效果</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>我们要做的 就是使用两条正余弦，但是这两条正余弦， 波峰需要对应波谷，有两种方法：</p>
<ol>
<li>使用for循环分别拼接正余弦的路径</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">-(void)updateWave</div><div class="line">&#123;</div><div class="line">    //波浪宽度</div><div class="line">    CGFloat waterWaveWidth = self.bounds.size.width;</div><div class="line">    //初始化运动路径</div><div class="line">    CGMutablePathRef path = CGPathCreateMutable();</div><div class="line">    </div><div class="line">    CGMutablePathRef maskPath = CGPathCreateMutable();</div><div class="line">    //设置起始位置</div><div class="line">    CGPathMoveToPoint(path, nil, 0, _waveY);</div><div class="line">    </div><div class="line">    //设置起始位置</div><div class="line">    CGPathMoveToPoint(maskPath, nil, 0, _waveY);</div><div class="line">    //初始化波浪其实Y为偏距</div><div class="line">    CGFloat y = _waveY;</div><div class="line">  </div><div class="line">    //正弦曲线公式为： y=Asin(ωx+φ)+k;</div><div class="line">    for (float x = 0.0f; x &lt;= waterWaveWidth ; x++) &#123;</div><div class="line">        y = _waveAmplitude * sin(_wavePalstance * x + _waveX) + _waveY;</div><div class="line">       </div><div class="line">        CGPathAddLineToPoint(path, nil, x, y);</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    for (float x = 0.0f; x &lt;= waterWaveWidth ; x++) &#123;</div><div class="line">        y = _waveAmplitude * cos(_wavePalstance * x + _waveX) + _waveY;</div><div class="line">       </div><div class="line">        CGPathAddLineToPoint(maskPath, nil, x, y);</div><div class="line">    &#125;</div><div class="line">    [self updateLayer:_waveLayer1 path:path];</div><div class="line">    [self updateLayer:_waveLayer2 path:maskPath];</div><div class="line"></div><div class="line">&#125;</div><div class="line">-(void)updateLayer:(CAShapeLayer *)layer path:(CGMutablePathRef )path</div><div class="line">&#123;</div><div class="line">    //填充底部颜色</div><div class="line">    CGFloat waterWaveWidth = self.bounds.size.width;</div><div class="line">    CGPathAddLineToPoint(path, nil, waterWaveWidth, self.bounds.size.height);</div><div class="line">    CGPathAddLineToPoint(path, nil, 0, self.bounds.size.height);</div><div class="line">    CGPathCloseSubpath(path);</div><div class="line">    layer.path = path;</div><div class="line">     CGPathRelease(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.使用单个for循环只是 设置 另一条曲线的y值相反即可实现两条正余弦的效果 ，最后一个动画中会有说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for (int x = 0; x&lt;WIDTH; x++) &#123;</div><div class="line">       y = waveHeight*sinf(0.01*waveCurvature*x+offSetValue*0.045);</div><div class="line">       CGPathAddLineToPoint(path, nil, x, y);</div><div class="line">       //遮罩层的路径与之相反</div><div class="line">       masky = -y;</div><div class="line">       CGPathAddLineToPoint(maskPath, nil, x, masky);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><strong>但是</strong>我们有个需求就是改变 波浪的高度， 实现注水的百分比，就需要设置波浪的偏距<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(void)updateWaveY</div><div class="line">&#123;</div><div class="line">    CGFloat targetY = self.bounds.size.height - _progress * self.bounds.size.height;</div><div class="line">    if (_waveY &lt; targetY) &#123;</div><div class="line">        _waveY += 2;</div><div class="line">    &#125;</div><div class="line">    if (_waveY &gt; targetY ) &#123;</div><div class="line">        _waveY -= 2;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>#####<strong>正余弦动画2</strong> </p>
</blockquote>
<p>如果有个需求 ，比如一个小船 随着波浪的波动而起伏<br>那我们就需要计算 波浪的位置，然后设置小船的frame<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//这里使用创建正余弦的第二种方法</div><div class="line">    for (int x = 0; x&lt;WIDTH; x++) &#123;</div><div class="line">        y = waveHeight*sinf(0.01*waveCurvature*x+offSetValue*0.045);</div><div class="line">        CGPathAddLineToPoint(path, nil, x, y);</div><div class="line">        //遮罩层的路径与之相反</div><div class="line">        masky = -y;</div><div class="line">        CGPathAddLineToPoint(maskPath, nil, x, masky);</div><div class="line">    &#125;</div><div class="line">计算出实浪波动时，最中间的位置，设置小船的frame</div><div class="line">  CGFloat CentY = waveHeight*sinf(0.01*waveCurvature*WIDTH/2+offSetValue*0.045);</div><div class="line">    CGRect boardViewFrame = [boardView frame];</div><div class="line">    boardViewFrame.origin.y = 100-waveHeight+CentY;</div><div class="line">    boardView.frame = boardViewFrame;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>雷达动画</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-4dfc88e76fa8a370.gif?imageMogr2/auto-orient/strip" alt="gif.gif"></p>
<p>给UIView添加一个分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line"></div><div class="line">@interface UIView (RadarAnimation)</div><div class="line"></div><div class="line">@property(nonatomic,strong)UIColor *radarColor; //扩散颜色</div><div class="line">@property(nonatomic,assign)UIColor *radarBorderColor; //扩散边界颜色</div><div class="line">-(void)addRadarAnimation;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>调用方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.radarColor = LBColor(237, 174, 130, 1);</div><div class="line">button.radarBorderColor = LBColor(237, 174, 130, 0.5);</div><div class="line"> [button addRadarAnimation];</div></pre></td></tr></table></figure></p>
<p>动画:添加动画的方法,创建三个layer，只不过，开始动画的时间要错开形成这个效果：：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">-(void)Animation&#123;</div><div class="line">    NSInteger pulsingCount = 3;</div><div class="line">    double animationDuration = 2;</div><div class="line"></div><div class="line">    CALayer * animationLayer = [[CALayer alloc]init];</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; pulsingCount; i++) &#123;</div><div class="line">        CALayer * pulsingLayer = [[CALayer alloc]init];</div><div class="line">        pulsingLayer.frame = CGRectMake(0, 0, self.frame.size.width, self.frame.size.height);</div><div class="line">        pulsingLayer.backgroundColor = self.radarColor.CGColor;</div><div class="line">        pulsingLayer.borderColor = self.radarBorderColor.CGColor;</div><div class="line"></div><div class="line"></div><div class="line">        pulsingLayer.borderWidth = 1.0;</div><div class="line">        pulsingLayer.cornerRadius = self.frame.size.height/2;</div><div class="line"></div><div class="line">        CAMediaTimingFunction * defaultCurve = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];</div><div class="line"></div><div class="line">        CAAnimationGroup * animationGroup = [[CAAnimationGroup alloc]init];</div><div class="line">        animationGroup.fillMode = kCAFillModeBoth;</div><div class="line">        animationGroup.beginTime = CACurrentMediaTime() + (double)i * animationDuration/(double)pulsingCount;</div><div class="line">        animationGroup.duration = animationDuration;</div><div class="line">        animationGroup.repeatCount = HUGE_VAL;</div><div class="line">        animationGroup.timingFunction = defaultCurve;</div><div class="line"></div><div class="line">        CABasicAnimation * scaleAnimation = [CABasicAnimation animationWithKeyPath:@&quot;transform.scale&quot;];</div><div class="line">        scaleAnimation.autoreverses = NO;</div><div class="line">        scaleAnimation.fromValue = [NSNumber numberWithDouble:1];</div><div class="line">        scaleAnimation.toValue = [NSNumber numberWithDouble:1.5];</div><div class="line"></div><div class="line">        CAKeyframeAnimation * opacityAnimation = [CAKeyframeAnimation animationWithKeyPath:@&quot;opacity&quot;];</div><div class="line">        opacityAnimation.values = @[[NSNumber numberWithDouble:1.0],[NSNumber numberWithDouble:0.5],[NSNumber numberWithDouble:0.3],[NSNumber numberWithDouble:0.0]];</div><div class="line">        opacityAnimation.keyTimes = @[[NSNumber numberWithDouble:0.0],[NSNumber numberWithDouble:0.25],[NSNumber numberWithDouble:0.5],[NSNumber numberWithDouble:1.0]];</div><div class="line">        animationGroup.animations = @[scaleAnimation,opacityAnimation];</div><div class="line"></div><div class="line">        [pulsingLayer addAnimation:animationGroup forKey:@&quot;pulsing&quot;];</div><div class="line">        [animationLayer addSublayer:pulsingLayer];</div><div class="line">    &#125;</div><div class="line">        animationLayer.zPosition = -1;//重新加载时，使动画至底层</div><div class="line">    [self.layer addSublayer:animationLayer];</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>爱奇艺旋转动画，说白了还是监听stokeStart stokeEnd做动画效果。</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-2394fa45a2af03ef.gif?imageMogr2/auto-orient/strip" alt="  爱奇艺动画.gif"></p>
<p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line">-(void)setUp&#123;</div><div class="line">    </div><div class="line">    CGPoint point =  CGPointMake(self.width/2, self.height/2);</div><div class="line">    UIBezierPath *path =[UIBezierPath bezierPathWithArcCenter:point radius:(self.width - 1)/2 startAngle:-0.5 *M_PI endAngle:1.5 *M_PI clockwise:YES];</div><div class="line"></div><div class="line">    self.shapeLayer =[[CAShapeLayer alloc]init];</div><div class="line">    self.shapeLayer.frame = self. bounds;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeColor = [UIColor hexStringToColor:@&quot;#94BF3F&quot;].CGColor;</div><div class="line">    self.shapeLayer.fillColor =[UIColor clearColor].CGColor;</div><div class="line">    self.shapeLayer.lineWidth = 1;</div><div class="line">    self.shapeLayer.lineCap = kCALineCapRound;</div><div class="line">    </div><div class="line"> </div><div class="line">    self.shapeLayer.path = path.CGPath;</div><div class="line">    </div><div class="line">    [self.layer addSublayer:self.shapeLayer];</div><div class="line">    </div><div class="line">    </div><div class="line">  </div><div class="line">    self.imageView =[[UIImageView alloc]initWithFrame:CGRectMake(0, 0, 9, 9)];</div><div class="line">    self.imageView.center = point;</div><div class="line">    self.imageView.image =[UIImage imageNamed:@&quot;三角形&quot;];</div><div class="line">    </div><div class="line">    [self addSubview:self.imageView];</div><div class="line">    [self animationOne];</div><div class="line"></div><div class="line">&#125;</div><div class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</div><div class="line">    if ([[anim valueForKey:@&quot;animationName&quot;] isEqualToString:@&quot;AnimationEnd&quot;]) &#123;</div><div class="line">        </div><div class="line">        [self animationTwo];</div><div class="line">        [self rotationAnimation];</div><div class="line">    &#125;</div><div class="line">    if ([[anim valueForKey:@&quot;animationName&quot;] isEqualToString:@&quot;AnimationStart&quot;]) &#123;</div><div class="line">        </div><div class="line">   </div><div class="line">        [self.shapeLayer removeAllAnimations];</div><div class="line">        [self animationOne];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)animationOne&#123;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeStart=0;</div><div class="line">    //设置strokeEnd的最终值，动画的fromValue为0，strokeEnd的最终值为0.98</div><div class="line">    self.shapeLayer.strokeEnd=0.98;</div><div class="line">    CABasicAnimation *basicAnimationOne=[CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</div><div class="line">    basicAnimationOne.fromValue=@(0);</div><div class="line">    </div><div class="line">    basicAnimationOne.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    basicAnimationOne.delegate=self;</div><div class="line">    [basicAnimationOne setValue:@&quot;AnimationEnd&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line">    [self.shapeLayer addAnimation:basicAnimationOne forKey:@&quot;animationName&quot;];</div><div class="line">&#125;</div><div class="line">-(void)animationTwo&#123;</div><div class="line">    </div><div class="line">    self.shapeLayer.strokeStart = 0.98;</div><div class="line">    CABasicAnimation *basicAnimationTwo=[CABasicAnimation animationWithKeyPath:@&quot;strokeStart&quot;];</div><div class="line">    basicAnimationTwo.fromValue=@(0);</div><div class="line">    </div><div class="line">    basicAnimationTwo.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    basicAnimationTwo.delegate=self;</div><div class="line">    [basicAnimationTwo setValue:@&quot;AnimationStart&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line"></div><div class="line">    [self.shapeLayer addAnimation:basicAnimationTwo forKey:@&quot;animationName&quot;];</div><div class="line">    </div><div class="line">&#125;</div><div class="line">-(void)rotationAnimation&#123;</div><div class="line">    CABasicAnimation *rotationAnimation=[CABasicAnimation animationWithKeyPath:@&quot;transform.rotation.z&quot;];</div><div class="line">    </div><div class="line">    rotationAnimation.toValue=@(M_PI*2);</div><div class="line">    rotationAnimation.duration= KAnimationDuration;</div><div class="line">    </div><div class="line">    rotationAnimation.delegate=self;</div><div class="line">    [rotationAnimation setValue:@&quot;AnimationRotation&quot; forKey:@&quot;animationName&quot;];</div><div class="line">    [self.imageView.layer addAnimation:rotationAnimation forKey:@&quot;AnimationRotation&quot;];</div><div class="line">    </div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>初学动画，参考很多文章，做个小小总结。<br>demo地址 <a href="https://github.com/liuxinixn/ProgressViewDemo" target="_blank" rel="noopener">demo集合</a></p>
<p>另外一个加入购物车的小动画：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-37a8d72c7ff0562c.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="12.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimation</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    </div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(_endPoint.x, _startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:_startPoint];</div><div class="line">    [path addQuadCurveToPoint:_endPoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [_viewController.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    [_shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://www.jianshu.com/p/a9a4c51aef13" target="_blank" rel="noopener">贝塞尔曲线（加入购物车动画）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg"
              alt="雪晟" />
          
            <p class="site-author-name" itemprop="name">雪晟</p>
            <p class="site-description motion-element" itemprop="description">多去尝试你从未尝试的。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">96</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liuxinixn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/3d7c50f31b88" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-flag"></i>Jianshu</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雪晟</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
