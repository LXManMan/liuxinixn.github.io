<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="多去尝试你从未尝试的。">
<meta property="og:type" content="website">
<meta property="og:title" content="雪晟">
<meta property="og:url" content="liuxinixn.github.io/page/8/index.html">
<meta property="og:site_name" content="雪晟">
<meta property="og:description" content="多去尝试你从未尝试的。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雪晟">
<meta name="twitter:description" content="多去尝试你从未尝试的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxinixn.github.io/page/8/"/>





  <title>雪晟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雪晟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">十年饮冰，难凉热血。我是雪晟。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/06/03/ios--二维码生成（带图标）以及相册识别二维码跳转/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/03/ios--二维码生成（带图标）以及相册识别二维码跳转/" itemprop="url">iOS--二维码生成（带图标）以及相册识别二维码跳转</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-03T20:19:35+08:00">
                2016-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>关于二维码的生成，系统提供了API。</p>
</blockquote>
<p>######第一步根据内容生成CIImage<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">//根据url 创建CIImage</div><div class="line">+(CIImage *)QRFromUrl:(NSString *)urlStr&#123;</div><div class="line">    // 1、创建滤镜对象</div><div class="line">    CIFilter *filter = [CIFilter filterWithName:@&quot;CIQRCodeGenerator&quot;];</div><div class="line">    </div><div class="line">    // 恢复滤镜的默认属性</div><div class="line">    [filter setDefaults];</div><div class="line">    </div><div class="line">    // 2、设置数据</div><div class="line">    NSString *info = urlStr;</div><div class="line">    // 将字符串转换成</div><div class="line">    NSData *infoData = [info dataUsingEncoding:NSUTF8StringEncoding];</div><div class="line">    </div><div class="line">    // 通过KVC设置滤镜inputMessage数据</div><div class="line">    [filter setValue:infoData forKeyPath:@&quot;inputMessage&quot;];</div><div class="line">    </div><div class="line">    // 3、获得滤镜输出的图像</div><div class="line">    CIImage *outputImage = [filter outputImage];</div><div class="line">    </div><div class="line">    return outputImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#####第二步根据CIImage生成UIImage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/** 根据CIImage生成指定大小的UIImage */</div><div class="line">+ (UIImage *)createUIImageFormCIImage:(CIImage *)image withSize:(CGFloat)size &#123;</div><div class="line">    CGRect extent = CGRectIntegral(image.extent);</div><div class="line">    CGFloat scale = MIN(size/CGRectGetWidth(extent), size/CGRectGetHeight(extent));</div><div class="line">    </div><div class="line">    // 1.创建bitmap;</div><div class="line">    size_t width = CGRectGetWidth(extent) * scale;</div><div class="line">    size_t height = CGRectGetHeight(extent) * scale;</div><div class="line">    CGColorSpaceRef cs = CGColorSpaceCreateDeviceGray();</div><div class="line">    CGContextRef bitmapRef = CGBitmapContextCreate(nil, width, height, 8, 0, cs, (CGBitmapInfo)kCGImageAlphaNone);</div><div class="line">    CIContext *context = [CIContext contextWithOptions:nil];</div><div class="line">    CGImageRef bitmapImage = [context createCGImage:image fromRect:extent];</div><div class="line">    CGContextSetInterpolationQuality(bitmapRef, kCGInterpolationNone);</div><div class="line">    CGContextScaleCTM(bitmapRef, scale, scale);</div><div class="line">    CGContextDrawImage(bitmapRef, extent, bitmapImage);</div><div class="line">    </div><div class="line">    // 2.保存bitmap到图片</div><div class="line">    CGImageRef scaledImage = CGBitmapContextCreateImage(bitmapRef);</div><div class="line">    CGContextRelease(bitmapRef);</div><div class="line">    CGImageRelease(bitmapImage);</div><div class="line">    return [UIImage imageWithCGImage:scaledImage];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样就可以生成简单的二维码。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-7b431ed9bb0ee43f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="普通的二维码.png"></p>
<blockquote>
<p>如果要在二维码中间加一个logo头像，我们需要给生成的二维码添加水印。</p>
<p>######假定已经生成了普通的二维码</p>
<p>######第一步:需要根据二维码图片设置生成水印图片<code>rect</code>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//根据二维码图片设置生成水印图片rect 这里限制水印的图片为二维码的1/4</div><div class="line">    CGRect waterImageRect = [self getWaterImageRectFromOutputQRImage:orginQRImage];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">+(CGRect)getWaterImageRectFromOutputQRImage:(UIImage *)orginQRImage&#123;</div><div class="line">    </div><div class="line">     CGSize linkSize = CGSizeMake(orginQRImage.size.width / 4, orginQRImage.size.height / 4); </div><div class="line">    </div><div class="line">    CGFloat linkX = (orginQRImage.size.width -linkSize.width)/2;</div><div class="line">    CGFloat linkY = (orginQRImage.size.height -linkSize.height)/2;</div><div class="line"></div><div class="line">    </div><div class="line">    return CGRectMake(linkX, linkY, linkSize.width, linkSize.height);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>######第二步：根据限制的rect重新生成logo图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">UIImage *logoImage =[[UIImage imageNamed:logoName]scaleToSize:waterImageRect.size];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-(UIImage*)scaleToSize:(CGSize)size</div><div class="line">&#123;</div><div class="line">    size = CGSizeMake(size.width  , size.height );</div><div class="line">    // 创建一个bitmap的context</div><div class="line">    // 并把它设置成为当前正在使用的context</div><div class="line">    UIGraphicsBeginImageContext(size);</div><div class="line">    // 绘制改变大小的图片</div><div class="line">    [self drawInRect:CGRectMake(0, 0, size.width , size.height )];</div><div class="line">    // 从当前context中创建一个改变大小后的图片</div><div class="line">    UIImage* scaledImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    // 使当前的context出堆栈</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    // 返回新的改变大小后的图片</div><div class="line">    return scaledImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####第三步：为生成的二维码添加水印图片</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//添加水印图片</div><div class="line">   finalImage =[UIImage LX_WaterImageWithImage:orginQRImage waterImage:waterImage waterImageRect:waterImageRect];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//添加水印图片</div><div class="line">+ (UIImage *)LX_WaterImageWithImage:(UIImage *)image waterImage:(UIImage *)waterImage waterImageRect:(CGRect)rect&#123;</div><div class="line">    </div><div class="line">    //1.获取图片</div><div class="line">    </div><div class="line">    //2.开启上下文</div><div class="line">    UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);</div><div class="line">    //3.绘制背景图片</div><div class="line">    [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)];</div><div class="line">    //绘制水印图片到当前上下文</div><div class="line">    [waterImage drawInRect:rect];</div><div class="line">    </div><div class="line">    //4.从上下文中获取新图片</div><div class="line">    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    //5.关闭图形上下文</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    //返回图片</div><div class="line">    return newImage;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后会生成如下的二维码<br><img src="http://upload-images.jianshu.io/upload_images/1694376-0d14832e33c8f20a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="logo二维码.png"></p>
<p>把方法封装在 分类里面,直接调用即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//普通的二维码</div><div class="line">+(UIImage *)LX_ImageOfQRFromURL:(NSString *)urlStr codeSize:(CGFloat)codeSize;</div><div class="line"></div><div class="line">//带logo 的二维码</div><div class="line">+(UIImage *)LX_ImageOfQRFromURL:(NSString *)urlStr codeSize:(CGFloat)codeSize logoName:(NSString *)logoName  radius: (CGFloat)radius borderWidth:(CGFloat)borderWidth borderColor:(UIColor *)borderColor;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>简单介绍一些图片裁剪处理的分类。</p>
</blockquote>
<p>1、裁剪图片自定义圆角<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)LX_ClipImageWithImage:(UIImage *)image circleRect:(CGRect)rect radious:(CGFloat) radious;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)LX_ClipImageWithImage:(UIImage *)image circleRect:(CGRect)rect radious:(CGFloat) radious&#123;</div><div class="line">    //1、开启上下文</div><div class="line">    UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);</div><div class="line">    //2、设置裁剪区域</div><div class="line">//    UIBezierPath * path = [UIBezierPath bezierPathWithOvalInRect:rect];</div><div class="line">    UIBezierPath * path = [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radious];</div><div class="line">    [path addClip];</div><div class="line">    //3、绘制图片</div><div class="line">    [image drawAtPoint:CGPointZero];</div><div class="line">    //4、获取新图片</div><div class="line">    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    //5、关闭上下文</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    //6、返回新图片</div><div class="line">    return newImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-56387fab3d8917dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆形裁剪.png"></p>
<p>2、圆形裁剪带边框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//裁剪带边框的圆形图片</div><div class="line">+ ( UIImage *)LX_ClipCircleImageWithImage:(UIImage *)image circleRect:(CGRect)rect borderWidth:(CGFloat)borderW borderColor:( UIColor *)borderColor;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//裁剪带边框的圆形图片</div><div class="line">+ (UIImage *)LX_ClipCircleImageWithImage:(UIImage *)image circleRect:(CGRect)rect borderWidth:(CGFloat)borderW borderColor:( UIColor *)borderColor&#123;</div><div class="line">    //1、开启上下文</div><div class="line">    UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);</div><div class="line">    </div><div class="line">    //2、设置边框</div><div class="line">    UIBezierPath * path = [UIBezierPath bezierPathWithOvalInRect:rect];</div><div class="line">    [borderColor setFill];</div><div class="line">    [path fill];</div><div class="line">    </div><div class="line">    //3、设置裁剪区域</div><div class="line">    UIBezierPath * clipPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(rect.origin.x + borderW , rect.origin.x + borderW , rect.size.width - borderW * 2, rect.size.height - borderW *2)];</div><div class="line">    [clipPath addClip];</div><div class="line">    </div><div class="line">    //3、绘制图片</div><div class="line">    [image drawAtPoint:CGPointZero];</div><div class="line">    </div><div class="line">    //4、获取新图片</div><div class="line">    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    //5、关闭上下文</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    //6、返回新图片</div><div class="line">    return newImage;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-46bfff18e8bd23fd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="圆形裁剪边框.png"></p>
<p>3、自定义图片圆角</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//裁剪图片自定义圆角</div><div class="line">+ (UIImage *)LX_ClipImageWithImage:(UIImage *)image circleRect:(CGRect)rect radious:(CGFloat) radious;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">+ (UIImage *)LX_ClipImageWithImage:(UIImage *)image circleRect:(CGRect)rect radious:(CGFloat) radious&#123;</div><div class="line">    //1、开启上下文</div><div class="line">    UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);</div><div class="line">    //2、设置裁剪区域</div><div class="line">//    UIBezierPath * path = [UIBezierPath bezierPathWithOvalInRect:rect];</div><div class="line">    UIBezierPath * path = [UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radious];</div><div class="line">    [path addClip];</div><div class="line">    //3、绘制图片</div><div class="line">    [image drawAtPoint:CGPointZero];</div><div class="line">    //4、获取新图片</div><div class="line">    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    //5、关闭上下文</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    //6、返回新图片</div><div class="line">    return newImage;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-03e2aa8fc0a1a419.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义图片裁剪圆角.png"></p>
<p>4、自定义图片边框圆角<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//裁剪带边框的图片 可设置圆角 边框颜色</div><div class="line">+(UIImage *)LX_ClipImageRadiousWithImage:(UIImage *)image circleRect:(CGRect)rect radious:(CGFloat)radious borderWith:(CGFloat)borderW borderColor:( UIColor *)borderColor;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">//裁剪带边框的图片 可设置圆角 边框颜色</div><div class="line">+(UIImage *)LX_ClipImageRadiousWithImage:(UIImage *)image circleRect:(CGRect)rect radious:(CGFloat)radious borderWith:(CGFloat)borderW borderColor:( UIColor *)borderColor&#123;</div><div class="line">    </div><div class="line">   </div><div class="line">    //1、开启上下文</div><div class="line">    UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);</div><div class="line">    </div><div class="line">    //2、设置边框</div><div class="line">    </div><div class="line">    UIBezierPath *path =[UIBezierPath bezierPathWithRoundedRect:rect cornerRadius:radious];</div><div class="line">    </div><div class="line">    [borderColor setFill];</div><div class="line">    </div><div class="line">    [path fill];</div><div class="line">    </div><div class="line">    </div><div class="line">    //3、设置裁剪区域</div><div class="line">    </div><div class="line">    </div><div class="line">    UIBezierPath * clipPath = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(rect.origin.x + borderW , rect.origin.x + borderW , rect.size.width - borderW * 2, rect.size.height - borderW *2) cornerRadius:radious];</div><div class="line">    </div><div class="line">    [clipPath addClip];</div><div class="line">    </div><div class="line">    //3、绘制图片</div><div class="line">    [image drawAtPoint:CGPointZero];</div><div class="line">    </div><div class="line">    //4、获取新图片</div><div class="line">    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    //5、关闭上下文</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    //6、返回新图片</div><div class="line">    return newImage;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-9a99c31770c1feca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义图片边框圆角.png"></p>
<p>5、图片添加水印</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//添加水印图片</div><div class="line">+ (UIImage *)LX_WaterImageWithImage:(UIImage *)image waterImage:(UIImage *)waterImage waterImageRect:(CGRect)rect;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">//添加水印图片</div><div class="line">+ (UIImage *)LX_WaterImageWithImage:(UIImage *)image waterImage:(UIImage *)waterImage waterImageRect:(CGRect)rect&#123;</div><div class="line">    </div><div class="line">    //1.获取图片</div><div class="line">    </div><div class="line">    //2.开启上下文</div><div class="line">    UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);</div><div class="line">    //3.绘制背景图片</div><div class="line">    [image drawInRect:CGRectMake(0, 0, image.size.width, image.size.height)];</div><div class="line">    //绘制水印图片到当前上下文</div><div class="line">    [waterImage drawInRect:rect];</div><div class="line">    </div><div class="line">    //4.从上下文中获取新图片</div><div class="line">    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    //5.关闭图形上下文</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    //返回图片</div><div class="line">    return newImage;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-656f4be13e32f014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图片添加水印.png"></p>
<p>demo 里简单封装了下。效果图</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-eebbae892a9596a5.gif?imageMogr2/auto-orient/strip" alt="二维码.gif"></p>
<blockquote>
<p>最后说明一下访问相册以及识别二维码进行跳转页面。这一块必须用真机测试。</p>
</blockquote>
<p>关于二维码扫描使用<a href="https://github.com/liuxinixn/SGQRCode" target="_blank" rel="noopener">SGQRCode</a>,<br>相册选择选择<a href="https://github.com/liuxinixn/TZImagePickerController" target="_blank" rel="noopener">TZImagePickerController</a></p>
<p>替换掉博主的选择相册。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">TZImagePickerController *pickerController = [[TZImagePickerController alloc]initWithMaxImagesCount:1 delegate:self];</div><div class="line">   </div><div class="line">   NCWS(weakSelf);</div><div class="line">   </div><div class="line">   [pickerController setDidFinishPickingPhotosHandle:^(NSArray&lt;UIImage *&gt; *photo, NSArray *assets, BOOL isSelectOriginalPhoto)&#123;</div><div class="line">       </div><div class="line">       NSLog(@&quot;%@&quot;,photo);</div><div class="line">       </div><div class="line">       UIImage *image = photo[0];</div><div class="line">              // CIDetector(CIDetector可用于人脸识别)进行图片解析，从而使我们可以便捷的从相册中获取到二维码</div><div class="line">       // 声明一个 CIDetector，并设定识别类型 CIDetectorTypeQRCode</div><div class="line">       CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:nil options:@&#123;CIDetectorAccuracy: CIDetectorAccuracyHigh&#125;];</div><div class="line">       </div><div class="line">       // 取得识别结果</div><div class="line">       NSArray *features = [detector featuresInImage:[CIImage imageWithCGImage:image.CGImage]];</div><div class="line">       </div><div class="line">       if (features.count == 0) &#123;</div><div class="line">           </div><div class="line">       &#125;else&#123;</div><div class="line">           for (int index = 0; index &lt; [features count]; index ++) &#123;</div><div class="line">               CIQRCodeFeature *feature = [features objectAtIndex:index];</div><div class="line">               NSString *resultStr = feature.messageString;</div><div class="line">               weakSelf.detectorString = resultStr;</div><div class="line">              </div><div class="line">           &#125;</div><div class="line">           NSString *result = weakSelf.detectorString;</div><div class="line">           </div><div class="line">               if ([result hasPrefix:@&quot;http&quot;]) &#123;</div><div class="line">                   ScanSuccessJumpVC *jumpVC = [[ScanSuccessJumpVC alloc] init];</div><div class="line">                   jumpVC.jump_URL = result;</div><div class="line">                   [self.navigationController pushViewController:jumpVC animated:YES];</div><div class="line">           </div><div class="line">               &#125; else &#123;</div><div class="line">                   ScanSuccessJumpVC *jumpVC = [[ScanSuccessJumpVC alloc] init];</div><div class="line">                   jumpVC.jump_bar_code = result;</div><div class="line">                   [self.navigationController pushViewController:jumpVC animated:YES];</div><div class="line">               &#125;</div><div class="line"></div><div class="line">           </div><div class="line">       &#125;</div><div class="line"></div><div class="line">   &#125;];</div><div class="line">   [self presentViewController:pickerController animated:YES completion:nil];</div></pre></td></tr></table></figure>
<p>demo地址:<a href="https://github.com/liuxinixn/LXQRCode/tree/master" target="_blank" rel="noopener">二维码制作与图片处理</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/06/03/Coregraphics切反向圆角/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/03/Coregraphics切反向圆角/" itemprop="url">CoreGraphices -切反向圆角</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-03T20:19:35+08:00">
                2016-06-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>效果图<br><img src="http://upload-images.jianshu.io/upload_images/1694376-efefdd1b6916140a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="E1819704-B84B-4741-BB28-4B87A1883EDF.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">    UIImageView *iamgeview =[[UIImageView alloc]initWithFrame:CGRectMake(20, 100, 200, 200)];</div><div class="line">    UIImage *image = [UIImage imageNamed:@&quot;gougou&quot;];</div><div class="line"></div><div class="line">//    iamgeview.image =</div><div class="line">    iamgeview.image = [self addClipWithImage:image];</div><div class="line"></div><div class="line">    [self.view addSubview:iamgeview];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">-(UIImage *)addClipWithImage:(UIImage *)image&#123;</div><div class="line">    </div><div class="line">    //1、开启上下文</div><div class="line">    UIGraphicsBeginImageContextWithOptions(image.size, NO, 0);</div><div class="line">   </div><div class="line">    //2、设置裁剪区域</div><div class="line">    //    UIBezierPath * path = [UIBezierPath bezierPathWithOvalInRect:rect];</div><div class="line"> </div><div class="line">    </div><div class="line">    UIBezierPath * path = [UIBezierPath bezierPathWithRect:CGRectMake(0,0,image.size.width, image.size.height)];</div><div class="line">    </div><div class="line">    [path addArcWithCenter:CGPointMake(image.size.width, 0) radius:10 startAngle:- M_PI  endAngle:-M_2_PI clockwise:NO];</div><div class="line">    [path closePath];</div><div class="line">    [path addClip];</div><div class="line">    //3、绘制图片</div><div class="line">    [image drawAtPoint:CGPointZero];</div><div class="line">    //4、获取新图片</div><div class="line">    UIImage * newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    //5、关闭上下文</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    //6、返回新图片</div><div class="line">    return newImage;</div><div class="line"></div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/06/02/CoreGraphics-压缩图片的正确姿势/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/02/CoreGraphics-压缩图片的正确姿势/" itemprop="url">CoreGraphices -压缩图片的正确姿势</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-02T20:19:35+08:00">
                2016-06-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>#####压缩图片的几种方法，我们都知道如果在上传的图片过大，上传会很慢，所以客户端这边需要做图片压缩。当然紧紧是对于加载图片的UIImagview 进行等比例压缩是不正确的，要从根本上改变图片的大小。</p>
<blockquote>
<p> 1 、NSData *imageData = UIImageJPEGRepresentation(image, 0.5);<br>这个返回的是二进制的data值，可以通过打印知道大小确实减少了好多，通过此方法确实能优化性能，需要注意的是这个0.5，并不是说压缩到之前图片的二分之一<br>，应该是个系数之类的数值，这样的话图片压缩之后性能会好很多，但是不建议这个，因为解压缩的时候很耗费性能建议使用第二种方法</p>
<p>2、 使用CoreGraphics 重新绘制一张等比例的图片</p>
</blockquote>
<p>小小的测试一下： </p>
<p>原图<br><img src="http://upload-images.jianshu.io/upload_images/1694376-954d3694707bfc3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原图.png"></p>
<p>经过下面代码压缩后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (UIImage *)imageWithImage:(UIImage*)image</div><div class="line">               scaledToSize:(CGSize)newSize;</div><div class="line">&#123;</div><div class="line">    UIGraphicsBeginImageContext(newSize);</div><div class="line">    [image drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];</div><div class="line">    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    </div><div class="line">    NSString * path = [NSString stringWithFormat:@&quot;%@/Documents/cutSome.jpg&quot;,NSHomeDirectory()];</div><div class="line">    NSData * imagedata = UIImageJPEGRepresentation(newImage, 1);</div><div class="line"></div><div class="line">    if( [imagedata writeToFile:path atomically:YES])&#123;</div><div class="line">        NSLog(@&quot;保存成功%@&quot;,path);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return newImage;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>压缩后 ：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-ec24497911240929.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="压缩后.png"></p>
<blockquote>
<p>如果只是单纯的使用第一种方法，图片确实会变小，分辨率也没有变化，但是在解压缩的过程中，会很耗性能，但是第二种方法 会按等比例的缩放像素，不会失真，对性能的耗损也比较小</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/06/01/CoreGraphics-练习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/01/CoreGraphics-练习/" itemprop="url">CoreGraphices -</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-01T20:19:35+08:00">
                2016-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>主要熟悉 一些 基本的API</p>
</blockquote>
<p>#####获取上下文的集中方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//创建图片类型的上下文</div><div class="line">UIGraphicsBeginImageContextWithOptions</div><div class="line">//UIView,在drawRect中，Cocoa会为你创建一个图形上下文</div><div class="line">- (void)drawRect:(CGRect)rect</div><div class="line">//CALayer</div><div class="line">- (void)drawInContext:(CGContextRef)ctx</div><div class="line">//delegate回调</div><div class="line">- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx</div></pre></td></tr></table></figure></p>
<p>#####先从drawRect开始</p>
<p>先说 一些API的区别 与相同 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">UIBezierPath 可以 直接 stroke 或者fill ，不需要添加到上下文中，也不需要进行绘制。</div><div class="line"> [pathRect stroke];  //可是设置 添加路径然后进行喷绘 UIBezierPath 本身有stroke 方法</div><div class="line">    //添加路径</div><div class="line">//    CGContextAddPath(contextRef, pathRect.CGPath);</div><div class="line">//    CGContextStrokePath(contextRef);</div></pre></td></tr></table></figure></p>
<p>关于设置颜色： 描边与填充同样的道理，当然要选取最简单的代码来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[[UIColor blueColor]set]  等于setFill + setStroke</div><div class="line"> [[UIColor redColor]setFill]; //等同于   CGContextSetFillColorWithColor(contextRef, [UIColor redColor].CGColor);</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//kCGPathFill填充非零绕数规则,</div><div class="line">kCGPathEOFill表示用奇偶规则,</div><div class="line">kCGPathStroke路径,</div><div class="line">kCGPathFillStroke路径填充,</div><div class="line">kCGPathEOFillStroke表示描线，不是填充</div><div class="line">CGContextDrawPath(context, kCGPathFillStroke);//绘制路径 加填充</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//画笑脸弧线</div><div class="line">   //左</div><div class="line">   CGContextMoveToPoint(context, 140, 80);//开始坐标p1</div><div class="line">   //CGContextAddArcToPoint(CGContextRef c, CGFloat x1, CGFloat y1,CGFloat x2, CGFloat y2, CGFloat radius)</div><div class="line">   //x1,y1跟p1形成一条线的坐标p2，x2,y2结束坐标跟p3形成一条线的p3,radius半径,注意, 需要算好半径的长度,</div><div class="line">   CGContextAddArcToPoint(context, 148, 68, 156, 80, 10);//⚠️</div><div class="line">   CGContextStrokePath(context);</div></pre></td></tr></table></figure>
<blockquote>
<p>下面是一些简单的绘制</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d73c30d1c781718d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="绘制.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    </div><div class="line">    CGContextRef contextRef = UIGraphicsGetCurrentContext();</div><div class="line">    </div><div class="line">    NSLog(@&quot;%s&quot;,__func__);</div><div class="line">    </div><div class="line">    </div><div class="line">    UIBezierPath *path =[UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:CGPointMake(10, 10)];</div><div class="line">    [path addLineToPoint:CGPointMake(100, 100)];</div><div class="line">    </div><div class="line">//    [[UIColor whiteColor]setStroke];</div><div class="line">    UIColor *color =[UIColor whiteColor];</div><div class="line">    CGContextSetStrokeColorWithColor(contextRef, color.CGColor);</div><div class="line">    CGContextAddPath(contextRef, path.CGPath);</div><div class="line">    CGContextStrokePath(contextRef);</div><div class="line">//    CGContextDrawPath(contextRef, kCGPathStroke);</div><div class="line">    </div><div class="line">    </div><div class="line">    //通过点 做矩形</div><div class="line">    </div><div class="line">    UIBezierPath *pathRect =[UIBezierPath bezierPath];</div><div class="line">    [pathRect moveToPoint:CGPointMake(10, 110)];</div><div class="line">    [pathRect addLineToPoint:CGPointMake(110, 110)];</div><div class="line">    [pathRect addLineToPoint:CGPointMake(110, 210)];</div><div class="line">    [pathRect addLineToPoint:CGPointMake(10, 210)];</div><div class="line">    //闭合路径</div><div class="line">    [pathRect closePath];</div><div class="line">    </div><div class="line">    //设置颜色</div><div class="line">    [[UIColor redColor]setStroke];</div><div class="line">    </div><div class="line">    [pathRect stroke];  //可是设置 添加路径然后进行喷绘 UIBezierPath 本身有stroke 方法</div><div class="line">    //添加路径</div><div class="line">//    CGContextAddPath(contextRef, pathRect.CGPath);</div><div class="line">    </div><div class="line">//    CGContextStrokePath(contextRef);</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    UIBezierPath *pathRect2 =[UIBezierPath bezierPathWithRect:CGRectMake(110, 10, 100, 100)];</div><div class="line">    CGContextSetFillColorWithColor(contextRef, [UIColor blueColor].CGColor);</div><div class="line">    [pathRect2 fill];</div><div class="line">    </div><div class="line">    </div><div class="line">    //设置颜色</div><div class="line">    [[UIColor brownColor]setStroke];</div><div class="line">    UIBezierPath *pathRect3 =[UIBezierPath bezierPathWithRect:CGRectMake(215, 10, 100, 100)];</div><div class="line"></div><div class="line">    [[UIColor redColor]setFill]; //等同于  [[UIColor redColor]set] CGContextSetFillColorWithColor(contextRef, [UIColor redColor].CGColor);</div><div class="line"></div><div class="line">    //添加路径   这两步等同于 [pathRect3 fill];</div><div class="line">    CGContextAddPath(contextRef, pathRect3.CGPath);</div><div class="line"></div><div class="line">    CGContextFillPath(contextRef);</div><div class="line"></div><div class="line">    </div><div class="line">    //画圆</div><div class="line">    //ArcCenter:中心点</div><div class="line">    //radius:半径</div><div class="line">    //startAngle：起始角度</div><div class="line">    //endAngle：结束角度</div><div class="line">    //clockwise：是否逆时针</div><div class="line">    UIBezierPath *pathCircle =[UIBezierPath bezierPathWithArcCenter:CGPointMake(170, 170) radius:50 startAngle:0 endAngle:M_PI *2 clockwise:NO];</div><div class="line">   </div><div class="line">//    [pathCircle fill];//填充</div><div class="line">    pathCircle.lineWidth = 5;</div><div class="line">    [pathCircle stroke];</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    //椭圆</div><div class="line">    UIBezierPath *pathOvar =[UIBezierPath bezierPathWithOvalInRect:CGRectMake(230, 120, 150, 100)];</div><div class="line">    </div><div class="line">    pathOvar.lineWidth = 5;</div><div class="line">    [pathOvar fill];</div><div class="line">    </div><div class="line"></div><div class="line">    </div><div class="line">    [[UIColor whiteColor]set];</div><div class="line">    //矩形</div><div class="line">    UIBezierPath *pathText =[UIBezierPath bezierPathWithRect:CGRectMake(10, 220, 100, 100)];</div><div class="line">    </div><div class="line">    pathText.lineWidth = 5;</div><div class="line">    [pathText fill];</div><div class="line">    //矩形中画字</div><div class="line">    NSString *str = @&quot;他大舅他二舅都是他舅&quot;;</div><div class="line">    NSMutableDictionary *dic =[NSMutableDictionary dictionary];</div><div class="line">    dic[NSForegroundColorAttributeName]= [UIColor purpleColor];</div><div class="line">    dic[NSFontAttributeName] = [UIFont systemFontOfSize:15];</div><div class="line">    dic[NSUnderlineStyleAttributeName] = @(NSUnderlineStyleSingle);</div><div class="line">    NSShadow *shadow =[[NSShadow alloc]init];</div><div class="line">    shadow.shadowOffset = CGSizeMake(2, 2);</div><div class="line">    shadow.shadowColor =[UIColor cyanColor];</div><div class="line">    dic[NSShadowAttributeName] = shadow;</div><div class="line">    </div><div class="line">    //字体间距</div><div class="line">    dic[NSKernAttributeName] = @5;</div><div class="line">    [str drawInRect:CGRectMake(10, 220, 100, 100) withAttributes:dic];</div><div class="line">    CGContextStrokePath(contextRef);</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    //椭圆 贝塞尔曲线</div><div class="line">    UIBezierPath *pathCurver =[UIBezierPath bezierPath];</div><div class="line"></div><div class="line">    [pathCurver moveToPoint:CGPointMake(120, 230)];</div><div class="line">    [pathCurver addQuadCurveToPoint:CGPointMake(200, 300) controlPoint:CGPointMake(150, 200)];</div><div class="line">    pathCurver.lineWidth = 5;</div><div class="line">    [pathCurver stroke];</div><div class="line">    </div><div class="line"></div><div class="line">    </div><div class="line">    </div><div class="line">    //绘制图片</div><div class="line">    UIImage *image =[UIImage imageNamed:@&quot;1&quot;];</div><div class="line">    </div><div class="line">    //设置绘制模式</div><div class="line">    [image drawInRect:CGRectMake(10, 330, 100, 100) blendMode:kCGBlendModeSoftLight alpha:1];</div><div class="line">    CGContextStrokePath(contextRef);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>#####不用贝塞尔曲线的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    </div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line">    </div><div class="line"></div><div class="line">    </div><div class="line">    //只描边</div><div class="line">    [[UIColor blueColor]setStroke];</div><div class="line">    [[UIColor redColor]setFill];</div><div class="line">   </div><div class="line">    CGContextSetLineWidth(context, 5.0);</div><div class="line">    CGContextStrokeRect(context, CGRectMake(100, 120, 100, 100));</div><div class="line"></div><div class="line">    CGContextFillRect(context, CGRectMake(100, 300, 100, 100));</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    CGContextDrawPath(context, kCGPathFillStroke);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p> 最后详细说明下 CGContextSaveGState CGContextRestoreGState   //保存当前上下文状态，如果做了裁剪就会在裁剪范围内 进行绘制，只有恢复到之前的上下文状态，才可以在裁剪区域之外进行绘制</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6be7c39c780f2522.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上下文状态.png"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    </div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line"></div><div class="line">    </div><div class="line">    //只描边</div><div class="line">    [[UIColor blueColor]setStroke];</div><div class="line">    [[UIColor redColor]setFill];</div><div class="line"></div><div class="line">    </div><div class="line">    //渐变色 采用layer</div><div class="line">    CAGradientLayer *gradient1 = [CAGradientLayer layer];</div><div class="line">    gradient1.frame = CGRectMake(100, 200, 60, 30);</div><div class="line">    gradient1.colors = [NSArray arrayWithObjects:(id)[UIColor whiteColor].CGColor,</div><div class="line">                        (id)[UIColor grayColor].CGColor,</div><div class="line">                        (id)[UIColor blackColor].CGColor,</div><div class="line">                        (id)[UIColor yellowColor].CGColor,</div><div class="line">                        (id)[UIColor blueColor].CGColor,</div><div class="line">                        (id)[UIColor redColor].CGColor,</div><div class="line">                        (id)[UIColor greenColor].CGColor,</div><div class="line">                        (id)[UIColor orangeColor].CGColor,</div><div class="line">                        (id)[UIColor brownColor].CGColor,nil];</div><div class="line">    [self.layer insertSublayer:gradient1 atIndex:0];</div><div class="line">    </div><div class="line"></div><div class="line">    </div><div class="line">    //保存当前上下文状态，如果做了裁剪就会在裁剪范围内 进行绘制，只有恢复到之前的上下文状态，才可以在裁剪区域之外进行绘制</div><div class="line">    CGContextSaveGState(context);</div><div class="line">    </div><div class="line">    CGContextMoveToPoint(context, 250, 300);</div><div class="line">    CGContextAddLineToPoint(context,350, 300);</div><div class="line">    CGContextAddLineToPoint(context, 350, 400);</div><div class="line">    CGContextAddLineToPoint(context, 250, 400);</div><div class="line">    CGContextClip(context);//context裁剪路径,后续操作的路径</div><div class="line"></div><div class="line">    //CGContextDrawLinearGradient(CGContextRef context,CGGradientRef gradient, CGPoint startPoint, CGPoint endPoint,CGGradientDrawingOptions options)</div><div class="line">    //gradient渐变颜色,startPoint开始渐变的起始位置,endPoint结束坐标,options开始坐标之前or开始之后开始渐变</div><div class="line">    CGColorSpaceRef rgb = CGColorSpaceCreateDeviceRGB();</div><div class="line">    CGFloat colors[] =</div><div class="line">    &#123;</div><div class="line">        1,1,1, 1.00,</div><div class="line">        1,1,0, 1.00,</div><div class="line">        1,0,0, 1.00,</div><div class="line">        1,0,1, 1.00,</div><div class="line">        0,1,1, 1.00,</div><div class="line">        0,1,0, 1.00,</div><div class="line">        0,0,1, 1.00,</div><div class="line">        0,0,0, 1.00,</div><div class="line">    &#125;;</div><div class="line">    CGGradientRef gradient = CGGradientCreateWithColorComponents</div><div class="line">    (rgb, colors, NULL, sizeof(colors)/(sizeof(colors[0])*4));//形成梯形，渐变的效果</div><div class="line">    CGColorSpaceRelease(rgb);</div><div class="line">    </div><div class="line">    CGContextDrawLinearGradient(context, gradient, CGPointMake(250, 300), CGPointMake(350, 400), kCGGradientDrawsAfterEndLocation);</div><div class="line"></div><div class="line">    //恢复上下文状态</div><div class="line">    CGContextRestoreGState(context);</div><div class="line">    </div><div class="line">  //如果没有恢复上下文状态，下方的矩形是看不见的</div><div class="line">    CGContextFillRect(context, CGRectMake(100, 450, 100, 100));</div><div class="line">    CGContextDrawPath(context, kCGPathFill);</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/20/CoreGraphics-绘制聊天气泡（图片类型的cell）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/20/CoreGraphics-绘制聊天气泡（图片类型的cell）/" itemprop="url">CoreGraphics-绘制聊天气泡（图片类型的cell）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-20T20:19:35+08:00">
                2016-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先看下效果图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-a6a2e3e20aea4647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果图.png"></p>
<p>在聊天时，如果消息类型是纯图片类型，对于加载图片的bubble 气泡，就不太好处理了，需要将图片充满整个气泡。所以我们需要对图片做一下处理。</p>
<blockquote>
<p>首先我们自定义view里实现类似的效果： 就是裁剪好这么一个带凸起的区域，然后把图片绘制在限定区域内；</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">- (void)drawRect:(CGRect)rect &#123;</div><div class="line">    // Drawing code</div><div class="line">    </div><div class="line">    CGContextRef context = UIGraphicsGetCurrentContext();</div><div class="line"></div><div class="line">    CGContextSetLineWidth(context, 5);</div><div class="line">    CGContextSaveGState(context);</div><div class="line">    //先剪裁区域</div><div class="line">    UIBezierPath *path =[UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 0, 200 -10, 301) cornerRadius:6];</div><div class="line">    path.lineWidth = 5;</div><div class="line">    [path moveToPoint:CGPointMake(200-10, 0)];</div><div class="line">    [path addLineToPoint:CGPointMake(200-10, 13)];</div><div class="line">    [path addLineToPoint:CGPointMake(200-10+5, 16)];</div><div class="line">    [path addLineToPoint:CGPointMake(200-10, 19)];</div><div class="line">    [path closePath];</div><div class="line">    </div><div class="line"></div><div class="line">    [path fill];</div><div class="line">    [path addClip];</div><div class="line">    </div><div class="line">    //裁剪好区域后 然后把图片绘制上去</div><div class="line">    UIImage *iamge =[UIImage imageNamed:@&quot;cutSome&quot;];</div><div class="line">    [iamge drawInRect:path.bounds];</div><div class="line"></div><div class="line">        context = UIGraphicsGetCurrentContext();</div><div class="line">    CGContextStrokePath(context);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####可以实现类似效果</p>
<blockquote>
<p>上面的处理明显是不对的，我们可以对图片进行直接处理，然后用imageview 加载即可 </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &quot;LXView.h&quot;</div><div class="line">#define APP_WIDTH ([UIScreen mainScreen].bounds.size.width)</div><div class="line">#define APP_HEIGHT ([UIScreen mainScreen].bounds.size.height)</div><div class="line">@interface ViewController ()</div><div class="line">@property(nonatomic,strong)UIImageView *imageview;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // Do any additional setup after loading the view, typically from a nib.</div><div class="line">    UIImage *imagecon=[UIImage imageNamed:@&quot;1&quot;];</div><div class="line">    </div><div class="line">   imagecon =  [self imageWithImage:imagecon scaledToSize:CGSizeMake(200, 200 *775.0/515)];</div><div class="line">    </div><div class="line">    self.imageview =[[UIImageView alloc]initWithFrame:CGRectMake(50, 100, imagecon.size.width, imagecon.size.height)];</div><div class="line">//    self.imageview.image = imagecon;</div><div class="line">    self.imageview.image =[self makeArrow:imagecon imageSize:imagecon.size];</div><div class="line">    [self.view addSubview:self.imageview];</div><div class="line">    </div><div class="line">    self.imageview.backgroundColor =[UIColor redColor];</div><div class="line">//    LXView *view =[[LXView alloc]initWithFrame:CGRectMake(20, 100, 210,400)];</div><div class="line">//    view.backgroundColor =[UIColor redColor];</div><div class="line">//    [self.view addSubview:view];</div><div class="line">&#125;</div><div class="line"></div><div class="line">//对图片进行压缩 </div><div class="line">- (UIImage *)imageWithImage:(UIImage*)image</div><div class="line">               scaledToSize:(CGSize)newSize;</div><div class="line">&#123;</div><div class="line">    UIGraphicsBeginImageContext(newSize);</div><div class="line">    [image drawInRect:CGRectMake(0,0,newSize.width,newSize.height)];</div><div class="line">    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    </div><div class="line">//    NSString * path = [NSString stringWithFormat:@&quot;%@/Documents/cutSome.jpg&quot;,NSHomeDirectory()];</div><div class="line">//    NSData * imagedata = UIImageJPEGRepresentation(newImage, 1);</div><div class="line">//</div><div class="line">//    if( [imagedata writeToFile:path atomically:YES])&#123;</div><div class="line">//        NSLog(@&quot;保存成功%@&quot;,path);</div><div class="line">//    &#125;</div><div class="line"></div><div class="line">    return newImage;</div><div class="line">    </div><div class="line">    </div><div class="line">&#125;</div><div class="line">//添加箭头，其实和第一种道理一样，也是绘制一个凸起的区域，然后把图片绘制上去达到效果，不过处理的是图形上下文；</div><div class="line">-(UIImage *)makeArrow:(UIImage *)image  imageSize:(CGSize )imageSize</div><div class="line"></div><div class="line">&#123;</div><div class="line">    </div><div class="line">    CGFloat arrowWidth = 6;</div><div class="line">    CGFloat marginTop = 13;</div><div class="line">    CGFloat arrowHeight = 10;</div><div class="line">    CGFloat imageW = imageSize.width;</div><div class="line"></div><div class="line">    </div><div class="line">    //开始上下文</div><div class="line">    UIGraphicsBeginImageContext(imageSize);</div><div class="line">    //获得上下文</div><div class="line">    CGContextRef context =UIGraphicsGetCurrentContext();</div><div class="line">        UIBezierPath *path =[UIBezierPath bezierPathWithRoundedRect:CGRectMake(0, 0, imageSize.width- arrowWidth, imageSize.height) cornerRadius:6];</div><div class="line">    [path moveToPoint:CGPointMake(imageW - arrowWidth, 0)];</div><div class="line">    [path addLineToPoint:CGPointMake(imageW - arrowWidth, marginTop)];</div><div class="line">    [path addLineToPoint:CGPointMake(imageW, marginTop + 0.5 * arrowHeight)];</div><div class="line">    [path addLineToPoint:CGPointMake(imageW - arrowWidth, marginTop + arrowHeight)];</div><div class="line">    [path closePath];</div><div class="line">    path.lineWidth = 3;</div><div class="line">    CGContextAddPath(context, path.CGPath);</div><div class="line">//    CGContextEOClip(context);</div><div class="line">    [path addClip];</div><div class="line">    [image drawInRect:CGRectMake(0, 0, imageSize.width, imageSize.height)];</div><div class="line">    UIImage *newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    return newImage;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/19/CoreAnimation之maskLayer使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/19/CoreAnimation之maskLayer使用/" itemprop="url">CoreAnimation之maskLayer使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-19T20:19:35+08:00">
                2016-05-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>demo 地址：<a href="https://github.com/liuxinixn/MaskLayer" target="_blank" rel="noopener">MaskLayer使用</a><br><img src="http://upload-images.jianshu.io/upload_images/1694376-979ecf2a4a198745.gif?imageMogr2/auto-orient/strip" alt="1.gif"><br>因为初学动画的缘故，对mask 蒙版理解不是很到位。</p>
<p> demo中的三个例子效果其实都是有<strong>前景和背景图视图，mask只是加在前景视图上</strong>，在使用mask的时候，会直接覆盖掉被遮盖图层（如果frame 与被覆盖层相同的话），然后我们可以通过改变mask layer 的一些属性做一些动画。</p>
<blockquote>
<p>首先看下 ❤️ 形的注水效果 </p>
</blockquote>
<p><strong>1</strong>. 要实现这样的效果，我们需要准备两张图片，比如<br>背景：<img src="http://upload-images.jianshu.io/upload_images/1694376-283a683670025357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="心2.png"><br>前景：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-c104e6bad2904e45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="心.png"><br>我们需要做的就是设置一个mask 蒙版加载前景视图上，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line"> self.maskLayer =[CAShapeLayer layer];</div><div class="line">//大小一样</div><div class="line"> self.maskLayer.frame = self.imageView.bounds;</div><div class="line"> CGPoint center  =  CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2);</div><div class="line"> UIBezierPath *path =[UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:2 *M_PI clockwise:YES];</div><div class="line"> self.maskLayer.path = path.CGPath;</div><div class="line"> self.imageView.layer.mask =  self.maskLayer;</div></pre></td></tr></table></figure></p>
<p><strong>2</strong>. 实现注水效果的第二步，我们要实现那样的动态效果，视图中能看到的是蒙版与前景共同作用的效果。当我们把蒙版从 下方移动到上方，就可以可以实现。<br> 首先在初始化maskLayer时需要设置maskLayer的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">self.maskLayer.position =CGPointMake(self.bounds.size.width/2, self.bounds.size.height * 1.5);</div></pre></td></tr></table></figure></p>
<p>然后做一个基础动画即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CABasicAnimation *animation =[CABasicAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 2;</div><div class="line">    animation.repeatCount = HUGE;</div><div class="line">    animation.fromValue = [NSValue valueWithCGPoint:CGPointMake(self.bounds.size.width/2, self.bounds.size.height * 1.5)]; //因为蒙版大小和前景图大小一样，我们需要把中心点向下移动一倍的高度</div><div class="line">    animation.toValue = [NSValue valueWithCGPoint:CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2)];</div><div class="line">    [self.maskLayer addAnimation:animation forKey:nil];</div><div class="line">    self.maskLayer.position = CGPointMake(self.bounds.size.width/2, self.bounds.size.height * 1.5);</div></pre></td></tr></table></figure></p>
<p>这样基本上 一个简单的动画就实现了，如果想实现两个方向的 注水，可以添加两个subLayer作为蒙版</p>
<blockquote>
<p>文字渐变</p>
</blockquote>
<p><a href="http://www.jianshu.com/p/6c8f645cb604" target="_blank" rel="noopener">参考文章</a><br>也是使用了两个视图 加一个蒙版<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@property(nonatomic,strong)UILabel *forelLabel;</div><div class="line">@property(nonatomic,strong)UILabel *backLabel;</div><div class="line">@property(nonatomic,strong)CAGradientLayer *maskLayer;</div></pre></td></tr></table></figure></p>
<p>动画代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">-(void)setType:(GradientType)type</div><div class="line">&#123;</div><div class="line">    _type = type;</div><div class="line">    switch (type) &#123;</div><div class="line">        case fadeOne:</div><div class="line">            self.maskLayer.colors = @[(id)[UIColor clearColor],(id)[UIColor redColor].CGColor,(id)[UIColor blackColor].CGColor,(id)[UIColor clearColor].CGColor];</div><div class="line">            self.maskLayer.locations = @[@(0.01),@(0.1),@(0.9),@(0.99)];</div><div class="line">            [self fadeString:(self.bounds.size.width)];</div><div class="line">            break;</div><div class="line">        case fadeTwo:</div><div class="line">             self.maskLayer.colors = @[(id)[UIColor clearColor].CGColor,(id)[UIColor redColor].CGColor,(id)[UIColor clearColor].CGColor];</div><div class="line">             self.maskLayer.locations = @[@(0.25),@(0.5),@(0.75)];</div><div class="line">             self.maskLayer.startPoint = CGPointMake(0, 0);</div><div class="line">             self.maskLayer.endPoint = CGPointMake(1, 0);</div><div class="line">           </div><div class="line">             self.maskLayer.position = CGPointMake(-self.bounds.size.width/2.0, self.bounds.size.height/2.0);</div><div class="line">           //默认中心点修改为左侧一半处。</div><div class="line">            [self iphoneFade: (self.bounds.size.width+self.bounds.size.width/2.0)];</div><div class="line">            break;</div><div class="line">        default:</div><div class="line">            break;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">-(void)fadeString:(CGFloat) toValue</div><div class="line">&#123;</div><div class="line">    CABasicAnimation *basicAnimation = [CABasicAnimation animation];</div><div class="line">    basicAnimation.keyPath = @&quot;transform.translation.x&quot;;</div><div class="line">    basicAnimation.fromValue = @(0);</div><div class="line">    basicAnimation.toValue = @(toValue);</div><div class="line">    basicAnimation.duration = 2;</div><div class="line">    basicAnimation.repeatCount = HUGE;</div><div class="line">    basicAnimation.removedOnCompletion = NO;</div><div class="line">    basicAnimation.fillMode = kCAFillModeForwards;</div><div class="line">    [self.maskLayer addAnimation:basicAnimation forKey:nil];</div><div class="line"></div><div class="line">&#125;</div><div class="line">-(void)iphoneFade:(CGFloat) toValue</div><div class="line">&#123;</div><div class="line">    CABasicAnimation *basicAnimation = [CABasicAnimation animation];</div><div class="line">    basicAnimation.keyPath = @&quot;transform.translation.x&quot;;</div><div class="line">    basicAnimation.fromValue = @(0);</div><div class="line">    basicAnimation.toValue = @(toValue);</div><div class="line">    basicAnimation.duration = 2;</div><div class="line">    basicAnimation.repeatCount = HUGE;</div><div class="line">    basicAnimation.removedOnCompletion = NO;</div><div class="line">    basicAnimation.fillMode = kCAFillModeForwards;</div><div class="line">    [self.maskLayer addAnimation:basicAnimation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/18/CoreAnimation之CAReplicatorLayer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/18/CoreAnimation之CAReplicatorLayer/" itemprop="url">CoreAnimation之CAReplicatorLayer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-18T20:19:35+08:00">
                2016-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>CAReplicatorLayer 一般用来复制层或者反射。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-e6fd9c0497884002.gif?imageMogr2/auto-orient/strip" alt="3.gif"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line">@property(nonatomic,strong)UIView *containView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    // Do any additional setup after loading the view, typically from a nib.</div><div class="line">    </div><div class="line"></div><div class="line">    self.containView =[[UIView alloc]initWithFrame:CGRectMake(self.view.frame.size.width/2 -100, self.view.frame.size.height/2 - 100, 200, 200)];</div><div class="line">    self.containView.backgroundColor =[UIColor redColor];</div><div class="line">    [self.view addSubview:self.containView];</div><div class="line">    </div><div class="line"></div><div class="line">    CAReplicatorLayer *replayer =[CAReplicatorLayer layer];</div><div class="line">    replayer.frame = self.containView.bounds;</div><div class="line">    [self.containView.layer addSublayer:replayer];</div><div class="line">    CALayer *layer = [CALayer layer];</div><div class="line">    </div><div class="line"></div><div class="line">    layer.frame = CGRectMake(0, replayer.bounds.size.height -150, 10, 150);</div><div class="line"></div><div class="line">    layer.backgroundColor = [UIColor whiteColor].CGColor;</div><div class="line">    </div><div class="line"></div><div class="line">    </div><div class="line">    [replayer addSublayer:layer];</div><div class="line">    </div><div class="line">    CABasicAnimation *anim = [CABasicAnimation animation];</div><div class="line">    </div><div class="line">    anim.keyPath = @&quot;transform.scale.y&quot;;</div><div class="line">    </div><div class="line">    anim.toValue = @0.1;</div><div class="line">    </div><div class="line">    anim.duration = 0.5;</div><div class="line">    </div><div class="line">    anim.repeatCount = MAXFLOAT;</div><div class="line">    </div><div class="line">    // 设置动画反转</div><div class="line">    anim.autoreverses = YES;</div><div class="line">    </div><div class="line">    </div><div class="line">    [layer addAnimation:anim forKey:nil];</div><div class="line">    </div><div class="line">    </div><div class="line">//     复制层中子层总数</div><div class="line">//     instanceCount：表示复制层里面有多少个子层，包括原始层</div><div class="line">    replayer.instanceCount = 5;</div><div class="line">    </div><div class="line">    // 设置复制子层偏移量，不包括原始层,相对于原始层x偏移</div><div class="line">//    replayer.instanceTransform = CATransform3DIdentity;</div><div class="line"></div><div class="line">   </div><div class="line">    CATransform3D tranform = CATransform3DIdentity;</div><div class="line">    tranform = CATransform3DMakeTranslation(45, 0, 0);</div><div class="line"></div><div class="line">    </div><div class="line"></div><div class="line">    replayer.instanceTransform =tranform;</div><div class="line">    </div><div class="line">    // 设置复制层动画延迟时间</div><div class="line">    replayer.instanceDelay = 0.1;</div><div class="line">    </div><div class="line">    // 如果设置了原始层背景色，就不需要设置这个属性</div><div class="line">    replayer.instanceColor = [UIColor greenColor].CGColor;</div><div class="line">    </div><div class="line">    replayer.instanceGreenOffset = -0.3;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/17/CoreAnimation之CAEmitterLayer(粒子破碎动画)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/17/CoreAnimation之CAEmitterLayer(粒子破碎动画)/" itemprop="url">CoreAnimation之CAEmitterLayer(粒子破碎动画)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-17T20:19:35+08:00">
                2016-05-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在iOS 5中，苹果引入了一个新的CALayer子类叫做CAEmitterLayer。CAEmitterLayer是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。<br>CAEmitterLayer看上去像是许多CAEmitterCell的容器，这些CAEmitierCell定义了一个例子效果。你将会为不同的例子效果定义一个或多个CAEmitterCell作为模版，同时CAEmitterLayer负责基于这些模版实例化一个粒子流。一个CAEmitterCell类似于一个CALayer：它有一个contents属性可以定义为一个CGImage，另外还有一些可设置属性控制着表现和行为。我们不会对这些属性逐一进行详细的描述，你们可以在CAEmitterCell类的头文件中找到。</p>
<blockquote>
<p><strong> CAEmitterLayer类提供了一个粒子发射器系统为核心的动画。这些粒子是由CAEmitterCell组成的实例，它相当于一个管理者，来管理 CAEmitterCell的发射的一些细节，比如发射的位置，发射形状等等</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">emitterPosition</td>
<td style="text-align:center">发射位置</td>
</tr>
<tr>
<td style="text-align:center">emitterSize</td>
<td style="text-align:center">发射源的大小</td>
</tr>
<tr>
<td style="text-align:center">emitterMode</td>
<td style="text-align:center">发射模式</td>
</tr>
<tr>
<td style="text-align:center">emitterShape</td>
<td style="text-align:center">发射源的形状</td>
</tr>
<tr>
<td style="text-align:center">renderMode</td>
<td style="text-align:center">渲染模式</td>
</tr>
<tr>
<td style="text-align:center">birthRate</td>
<td style="text-align:center">粒子产生系数，默认1.0</td>
</tr>
<tr>
<td style="text-align:center">emitterCells</td>
<td style="text-align:center">装着CAEmitterCell对象的数组，被用于把粒子投放到layer上</td>
</tr>
<tr>
<td style="text-align:center">emitterDepth</td>
<td style="text-align:center">决定粒子形状的深度联系</td>
</tr>
<tr>
<td style="text-align:center">emitterZposition</td>
<td style="text-align:center">发射源的z坐标位置</td>
</tr>
<tr>
<td style="text-align:center">lifetime</td>
<td style="text-align:center">粒子生命周期</td>
</tr>
<tr>
<td style="text-align:center">scale</td>
<td style="text-align:center">粒子的缩放比例</td>
</tr>
<tr>
<td style="text-align:center">seed</td>
<td style="text-align:center">用于初始化随机数产生的种子</td>
</tr>
<tr>
<td style="text-align:center">spin</td>
<td style="text-align:center">自旋转速度</td>
</tr>
<tr>
<td style="text-align:center">velocity</td>
<td style="text-align:center">粒子速度</td>
</tr>
</tbody>
</table>
<blockquote>
<p>CAEmitterCell属性 </p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">属性名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">alphaRange</td>
<td style="text-align:center">一个粒子的颜色alpha能改变的范围</td>
</tr>
<tr>
<td style="text-align:center">alphaSpeed</td>
<td style="text-align:center">粒子透明度在生命周期内的改变速度</td>
</tr>
<tr>
<td style="text-align:center">birthrate</td>
<td style="text-align:center">每秒发射的粒子数量</td>
</tr>
<tr>
<td style="text-align:center">blueRange     一个粒子的颜色blue 能改变的范围</td>
</tr>
<tr>
<td style="text-align:center">blueSpeed</td>
<td style="text-align:center">粒子blue在生命周期内的改变速度</td>
</tr>
<tr>
<td style="text-align:center">color</td>
<td style="text-align:center">粒子的颜色</td>
</tr>
<tr>
<td style="text-align:center">contents</td>
<td style="text-align:center">是个CGImageRef的对象,既粒子要展现的图片</td>
</tr>
<tr>
<td style="text-align:center">contentsRect</td>
<td style="text-align:center">应该画在contents里的子rectangle</td>
</tr>
<tr>
<td style="text-align:center">emissionLatitude</td>
<td style="text-align:center">发射的z轴方向的角度</td>
</tr>
<tr>
<td style="text-align:center">emissionLongitude</td>
<td style="text-align:center">x-y平面的发射方向</td>
</tr>
<tr>
<td style="text-align:center">emissionRange</td>
<td style="text-align:center">周围发射角度</td>
</tr>
<tr>
<td style="text-align:center">emitterCells</td>
<td style="text-align:center">粒子发射的粒子的数组</td>
</tr>
<tr>
<td style="text-align:center">enabled</td>
<td style="text-align:center">粒子是否被渲染</td>
</tr>
<tr>
<td style="text-align:center">greenrange</td>
<td style="text-align:center">一个粒子的颜色green 能改变的范围</td>
</tr>
<tr>
<td style="text-align:center">greenSpeed</td>
<td style="text-align:center">粒子green在生命周期内的改变速度</td>
</tr>
<tr>
<td style="text-align:center">lifetime</td>
<td style="text-align:center">生命周期</td>
</tr>
<tr>
<td style="text-align:center">lifetimeRange</td>
<td style="text-align:center">生命周期范围 lifetime= lifetime(+/-) lifetimeRange</td>
</tr>
<tr>
<td style="text-align:center">magnificationFilter</td>
<td style="text-align:center">增加自己的大小</td>
</tr>
<tr>
<td style="text-align:center">minificatonFilter</td>
<td style="text-align:center">减小自己的大小</td>
</tr>
<tr>
<td style="text-align:center">minificationFilterBias</td>
<td style="text-align:center">减小大小的因子</td>
</tr>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">粒子的名字</td>
</tr>
<tr>
<td style="text-align:center">redRange</td>
<td style="text-align:center">一个粒子的颜色red 能改变的范围</td>
</tr>
<tr>
<td style="text-align:center">redSpeed</td>
<td style="text-align:center">粒子red在生命周期内的改变速度</td>
</tr>
<tr>
<td style="text-align:center">scale</td>
<td style="text-align:center">缩放比例</td>
</tr>
<tr>
<td style="text-align:center">scaleRange</td>
<td style="text-align:center">缩放比例范围</td>
</tr>
<tr>
<td style="text-align:center">scaleSpeed</td>
<td style="text-align:center">缩放比例速度</td>
</tr>
<tr>
<td style="text-align:center">spin</td>
<td style="text-align:center">子旋转角度</td>
</tr>
<tr>
<td style="text-align:center">spinrange</td>
<td style="text-align:center">子旋转角度范围</td>
</tr>
<tr>
<td style="text-align:center">velocity</td>
<td style="text-align:center">速度</td>
</tr>
<tr>
<td style="text-align:center">velocityRange</td>
<td style="text-align:center">速度范围</td>
</tr>
<tr>
<td style="text-align:center">xAcceleration</td>
<td style="text-align:center">粒子x方向的加速度分量</td>
</tr>
<tr>
<td style="text-align:center">yAcceleration</td>
<td style="text-align:center">粒子y方向的加速度分量</td>
</tr>
<tr>
<td style="text-align:center">zAcceleration</td>
<td style="text-align:center">粒子z方向的加速度分量</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">@interface ViewController () </div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView; </div><div class="line">@end </div><div class="line">@implementation ViewController </div><div class="line"></div><div class="line">- (void)viewDidLoad &#123;</div><div class="line"> [super viewDidLoad]; </div><div class="line">//create particle emitter layer </div><div class="line">CAEmitterLayer *emitter = [CAEmitterLayer layer];</div><div class="line"> emitter.frame = self.containerView.bounds; [self.containerView.layer addSublayer:emitter]; </div><div class="line">//configure emitter emitter.renderMode = kCAEmitterLayerAdditive; </div><div class="line">emitter.emitterPosition = CGPointMake(emitter.frame.size.width / 2.0, emitter.frame.size.height / 2.0); </div><div class="line">//create a particle template </div><div class="line">CAEmitterCell *cell = [[CAEmitterCell alloc] init]; </div><div class="line">cell.contents = (__bridge id)[UIImage imageNamed:@&quot;Spark.png&quot;].CGImage; cell.birthRate = 150; </div><div class="line">cell.lifetime = 5.0;</div><div class="line"> cell.color = [UIColor colorWithRed:1 green:0.5 blue:0.1 alpha:1.0].CGColor; </div><div class="line">cell.alphaSpeed = -0.4; </div><div class="line">cell.velocity = 50;</div><div class="line"> cell.velocityRange = 50; </div><div class="line">cell.emissionRange = M_PI * 2.0; //add particle template to emitter emitter.emitterCells = @[cell]; </div><div class="line">&#125; </div><div class="line">@end</div></pre></td></tr></table></figure>
<p>#####点赞的破碎动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">self.view.backgroundColor =[UIColor whiteColor];</div><div class="line"></div><div class="line">self.container =[[UIView alloc]initWithFrame:CGRectMake(0, 0, 30, 30)];</div><div class="line">self.container.layer.contents = (__bridge id)[UIImage imageNamed:@&quot;点赞2&quot;].CGImage;</div><div class="line">self.container.center = self.view.center;</div><div class="line">[self.view addSubview:self.container];</div><div class="line">CAEmitterCell *emitterCell = [CAEmitterCell emitterCell];</div><div class="line">emitterCell.name           = @&quot;emitter&quot;;</div><div class="line">emitterCell.alphaRange     = 0.10;</div><div class="line">emitterCell.alphaSpeed     = -1.0;</div><div class="line">emitterCell.lifetime       = 0.6;</div><div class="line">emitterCell.lifetimeRange  = 0.3;</div><div class="line">emitterCell.birthRate      = 0;</div><div class="line">emitterCell.velocity       = 40.00;</div><div class="line">emitterCell.velocityRange  = 10.00;</div><div class="line">emitterCell.scale          = 0.03;</div><div class="line">emitterCell.scaleRange     = 0.02;</div><div class="line">emitterCell.contents       = (id)[UIImage imageNamed:@&quot;Emitter&quot;].CGImage;</div><div class="line"></div><div class="line"> self.emitterLayer               = [CAEmitterLayer layer];</div><div class="line"> self.emitterLayer.name          = @&quot;emitterLayer&quot;;</div><div class="line"> self.emitterLayer.emitterShape  = kCAEmitterLayerCircle;</div><div class="line"> self.emitterLayer.emitterMode   = kCAEmitterLayerOutline;</div><div class="line"> self.emitterLayer.emitterSize   = CGSizeMake(20, 20);</div><div class="line"> self.emitterLayer.emitterCells  = @[emitterCell];</div><div class="line"> self.emitterLayer.renderMode    = kCAEmitterLayerAdditive;</div><div class="line"> self.emitterLayer.masksToBounds = NO;</div><div class="line"> self.emitterLayer.position      = CGPointMake(self.container.frame.size.width/2.0,self.container.frame.size.height/2.0);</div><div class="line"></div><div class="line">[self.container.layer addSublayer:self.emitterLayer];</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/16/CoreAnimation之转场之圆圈缩放动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/16/CoreAnimation之转场之圆圈缩放动画/" itemprop="url">CoreAnimation转场之圆圈缩放动画</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-16T20:19:35+08:00">
                2016-05-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先看动画效果：<br><img src="http://upload-images.jianshu.io/upload_images/1694376-c980b1f7307547e7.gif?imageMogr2/auto-orient/strip" alt="圆圈转场动画.gif"></p>
<p>间客的APP上之前是有这个动画的，拜读了大神的文章：<a href="http://www.kittenyang.com/pingtransition/" target="_blank" rel="noopener">iOS自定义转场详解03——实现通过圆圈放大缩小的转场动画</a>,博客里面很详细。</p>
<blockquote>
<p>因为要自定义转场，所以我们需要一个新的对象集成NSObject，并且遵守转场动画的协议,<code>UIViewControllerAnimatedTransitioning</code></p>
</blockquote>
<p>介绍个知识点：</p>
<p>1、CGRectInsetCGRect<br>    CGRectInset (<br>        CGRect rect,<br>        CGFloat dx,<br>        CGFloat dy);<br>该结构体的应用是以原rect为中心，再参考dx，dy，进行缩放或者放大。
　　</p>
<p>2、CGRectOffsetCGRect<br>   CGRectOffset(<br>      CGRect rect,<br>      CGFloat dx,<br>      CGFloat dy);　<br>相对于源矩形原点rect（左上角的点）沿x轴和y轴偏移, 再rect基础上沿x轴和y轴偏移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// This is used for percent driven interactive transitions, as well as for</div><div class="line">// container controllers that have companion animations that might need to</div><div class="line">// synchronize with the main animation.</div><div class="line">设置转场动画的时间。</div><div class="line">- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div><div class="line"></div><div class="line">// This method can only  be a nop if the transition is interactive and not a percentDriven interactive transition.</div><div class="line">转场的上下文</div><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;</div></pre></td></tr></table></figure>
<p>关于这个参数transitionContext， 该参数是一个实现了 UIViewControllerContextTransitioning可以让我们访问一些实现过渡所必须的对象。<br>    UIViewControllerContextTransitioning 协议中有一些方法：</p>
<ul>
<li>(UIView *)containerView;<br>  //转场动画发生的容器</li>
<li>(UIViewController <em>)viewControllerForKey:(NSString </em>)key;<br>  // 我们可以通过它拿到过渡的两个 ViewController。</li>
</ul>
<p>大致思路是这样从，我们画两个内塞尔曲线的圆，第一个小圆的frame和右上角圆形按钮的大小一样，第二个大圆则是覆盖了整个屏幕。然后，去设置view.layer.mask属性，让这个mask从小圆动画到大圆。</p>
<p>以push 动画为例：pop动画不过是起终点的mask路径相反罢了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123;</div><div class="line"></div><div class="line">   </div><div class="line">    ViewController * fromVC = (ViewController *)[transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];</div><div class="line">    DetailViewController *toVC = (DetailViewController *)[transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];</div><div class="line">    UIView *contView = [transitionContext containerView];</div><div class="line"></div><div class="line">    UIButton *button = fromVC.button;</div><div class="line">    </div><div class="line">    </div><div class="line">    UIBezierPath *maskStartBP =  [UIBezierPath bezierPathWithOvalInRect:button.frame];    </div><div class="line">    [contView addSubview:fromVC.view];</div><div class="line">    [contView addSubview:toVC.view];</div><div class="line"></div><div class="line">    </div><div class="line">    </div><div class="line">    //创建两个圆形的 UIBezierPath 实例；一个是 button 的 size ，另外一个则拥有足够覆盖屏幕的半径。最终的动画则是在这两个贝塞尔路径之间进行的</div><div class="line">    </div><div class="line">    CGPoint finalPoint;</div><div class="line">    //判断触发点在那个象限</div><div class="line">    if(button.frame.origin.x &gt; (toVC.view.bounds.size.width / 2))&#123;</div><div class="line">        if (button.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">            //第一象限</div><div class="line">            finalPoint = CGPointMake(button.center.x - 0, button.center.y - CGRectGetMaxY(toVC.view.bounds)+30);</div><div class="line">        &#125;else&#123;</div><div class="line">            //第四象限</div><div class="line">            finalPoint = CGPointMake(button.center.x - 0, button.center.y - 0);</div><div class="line">        &#125;</div><div class="line">    &#125;else&#123;</div><div class="line">        if (button.frame.origin.y &lt; (toVC.view.bounds.size.height / 2)) &#123;</div><div class="line">            //第二象限</div><div class="line">            finalPoint = CGPointMake(button.center.x - CGRectGetMaxX(toVC.view.bounds), button.center.y - CGRectGetMaxY(toVC.view.bounds)+30);</div><div class="line">        &#125;else&#123;</div><div class="line">            //第三象限</div><div class="line">            finalPoint = CGPointMake(button.center.x - CGRectGetMaxX(toVC.view.bounds), button.center.y - 0);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    </div><div class="line">    </div><div class="line">    CGFloat radius = sqrt((finalPoint.x * finalPoint.x) + (finalPoint.y * finalPoint.y));</div><div class="line">    UIBezierPath *maskFinalBP = [UIBezierPath bezierPathWithOvalInRect:CGRectInset(button.frame, -radius, -radius)];</div><div class="line">    </div><div class="line">    </div><div class="line">    //创建一个 CAShapeLayer 来负责展示圆形遮盖</div><div class="line">    CAShapeLayer *maskLayer = [CAShapeLayer layer];</div><div class="line">    maskLayer.path = maskFinalBP.CGPath; //将它的 path 指定为最终的 path 来避免在动画完成后会回弹</div><div class="line">    toVC.view.layer.mask = maskLayer;</div><div class="line">    maskLayer.backgroundColor =[UIColor redColor].CGColor;</div><div class="line">    </div><div class="line">    CABasicAnimation *maskLayerAnimation = [CABasicAnimation animationWithKeyPath:@&quot;path&quot;];</div><div class="line">    maskLayerAnimation.fromValue = (__bridge id)(maskStartBP.CGPath);</div><div class="line">    maskLayerAnimation.toValue = (__bridge id)((maskFinalBP.CGPath));</div><div class="line">    maskLayerAnimation.duration = [self transitionDuration:transitionContext];</div><div class="line">    maskLayerAnimation.timingFunction = [CAMediaTimingFunction  functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    maskLayerAnimation.delegate = self;</div><div class="line">    </div><div class="line">    [maskLayer addAnimation:maskLayerAnimation forKey:@&quot;path&quot;];</div></pre></td></tr></table></figure></p>
<p> 结束动画后设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#pragma mark - CABasicAnimation的Delegate</div><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag&#123;</div><div class="line"></div><div class="line">    //告诉 iOS 这个 transition 完成</div><div class="line">    [self.transitionContext completeTransition:![self. transitionContext transitionWasCancelled]];</div><div class="line">    //清除 fromVC 的 mask</div><div class="line">    [self.transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey].view.layer.mask = nil;</div><div class="line">    [self.transitionContext viewControllerForKey:UITransitionContextToViewControllerKey].view.layer.mask = nil;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>自定义完push 动画后我们需要进行设置，因为所有的子控制器由UINavgationController进行管理，所有我们需要在ViewCotroller中实现代理;</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()&lt;UINavigationControllerDelegate&gt;</div></pre></td></tr></table></figure>
<p>最好在<code>viewWillAppear</code>中设置代理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-(void)viewWillAppear:(BOOL)animated&#123;</div><div class="line">    self.navigationController.delegate = self;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>实现代理：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#pragma mark - UINavigationControllerDelegate</div><div class="line">- (id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController</div><div class="line">                                   animationControllerForOperation:(UINavigationControllerOperation)operation</div><div class="line">                                                fromViewController:(UIViewController *)fromVC</div><div class="line">                                                  toViewController:(UIViewController *)toVC&#123;</div><div class="line">    if (operation == UINavigationControllerOperationPush) &#123;</div><div class="line">        </div><div class="line">        PingTransition *ping = [PingTransition new];</div><div class="line">        return ping;</div><div class="line">    &#125;else&#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本文demo地址：<a href="https://github.com/liuxinixn/CircleZoomView/tree/master" target="_blank" rel="noopener">圆圈转场动画</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/15/CoreAnimation之隐式动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/15/CoreAnimation之隐式动画/" itemprop="url">CoreAnimation之隐式动画</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-15T20:19:35+08:00">
                2016-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>按照我的意思去做，而不是我说的。 – 埃德娜，辛普森</p>
</blockquote>
<p>我们在第一部分讨论了Core Animation除了动画之外可以做到的任何事情。但是动画师Core Animation库一个非常显著的特性。这一章我们来看看它是怎么做到的。具体来说，我们先来讨论框架自动完成的隐式动画（除非你明确禁用了这个功能）。</p>
<p>####事务<br> Core Animation基于一个假设，说屏幕上的任何东西都可以（或者可能）做动画。动画并不需要你在Core Animation中手动打开，相反需要明确地关闭，否则他会一直存在。</p>
<p>当你改变CALayer的一个可做动画的属性，它并不能立刻在屏幕上体现出来。相反，它是从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作。</p>
<p>这看起来这太棒了，似乎不太真实，我们来用一个demo解释一下：首先和第一章“图层树”一样创建一个蓝色的方块，然后添加一个按钮，随机改变它的颜色。代码见清单7.1。点击按钮，你会发现图层的颜色平滑过渡到一个新值，而不是跳变（图7.1）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-20bb31a74640830f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.1.png"></p>
<p>#####清单7.1 随机改变图层颜色<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    @property (nonatomic, weak) IBOutlet CALayer *colorLayer;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create sublayer</div><div class="line">        self.colorLayer = [CALayer layer];</div><div class="line">        self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">        self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">        //add it to our view</div><div class="line">        [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (IBAction)changeColor</div><div class="line">    &#123;</div><div class="line">        //randomize the layer background color</div><div class="line">        CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">        CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">        CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">        self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;                                                                                       </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p>这其实就是所谓的隐式动画。之所以叫隐式是因为我们并没有指定任何动画的类型。我们仅仅改变了一个属性，然后Core Animation来决定如何并且何时去做动画。CoreAnimaiton同样支持显式动画，下章详细说明。</p>
<p>但当你改变一个属性，Core Animation是如何判断动画类型和持续时间的呢？实际上动画执行的时间取决于当前事务的设置，动画类型取决于图层行为。</p>
<p>事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。</p>
<p>事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction<br>没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。</p>
<p>任何可以做动画的图层属性都会被添加到栈顶的事务，你可以通过+setAnimationDuration:方法设置当前事务的动画时间，或者通过+animationDuration方法来获取值（默认0.25秒）。</p>
<p>Core Animation在每个run loop周期中自动开始一次新的事务（run loop是<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>负责收集用户输入，处理定时器或者网络事件并且重新绘制屏幕的东西），即使你不显式的用[CATransaction begin]开始一次事务，任何在一次run loop循环中属性的改变都会被集中起来，然后做一次0.25秒的动画。</p>
<p>明白这些之后，我们就可以轻松修改变色动画的时间了。我们当然可以用当前事务的+setAnimationDuration:方法来修改动画时间，但在这里我们首先起一个新的事务，于是修改时间就不会有别的副作用。因为修改当前事务的时间可能会导致同一时刻别的动画（如屏幕旋转），所以最好还是在调整动画之前压入一个新的事务。</p>
<p>修改后的代码见清单7.2。运行程序，你会发现色块颜色比之前变得更慢了。</p>
<p>#####清单7.2 使用CATransaction控制动画时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">- (IBAction)changeColor</div><div class="line">&#123;</div><div class="line">    //begin a new transaction</div><div class="line">    [CATransaction begin];</div><div class="line">    //set the animation duration to 1 second</div><div class="line">    [CATransaction setAnimationDuration:1.0];</div><div class="line">    //randomize the layer background color</div><div class="line">    CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">    //commit the transaction</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 如果你用过UIView的动画方法做过一些动画效果，那么应该对这个模式不陌生。UIView有两个方法，+beginAnimations:context:和+commitAnimations，和CATransaction的+begin和+commit方法类似。实际上在+beginAnimations:context:和+commitAnimations之间所有视图或者图层属性的改变而做的动画都是由于设置了CATransaction的原因。</p>
<p>在iOS4中，苹果对UIView添加了一种基于block的动画方法：+animateWithDuration:animations:。这样写对做一堆的属性动画在语法上会更加简单，但实质上它们都是在做同样的事情。</p>
<p>CATransaction的+begin和+commit方法在+animateWithDuration:animations:内部自动调用，这样block中所有属性的改变都会被事务所包含。这样也可以避免开发者由于对+begin和+commit匹配的失误造成的风险。</p>
<p>#####完成块<br>基于UIView的block的动画允许你在动画结束的时候提供一个完成的动作。CATranscation接口提供的+setCompletionBlock:方法也有同样的功能。我们来调整上个例子，在颜色变化结束之后执行一些操作。我们来添加一个完成之后的block，用来在每次颜色变化结束之后切换到另一个旋转90的动画。代码见清单7.3，运行结果见图7.2。</p>
<p>#####清单7.3 在颜色动画完成之后添加一个回调<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (IBAction)changeColor</div><div class="line">   &#123;</div><div class="line">       //begin a new transaction</div><div class="line">       [CATransaction begin];</div><div class="line">       //set the animation duration to 1 second</div><div class="line">       [CATransaction setAnimationDuration:1.0];</div><div class="line">       //add the spin animation on completion</div><div class="line">       [CATransaction setCompletionBlock:^&#123;</div><div class="line">           //rotate the layer 90 degrees</div><div class="line">           CGAffineTransform transform = self.colorLayer.affineTransform;</div><div class="line">           transform = CGAffineTransformRotate(transform, M_PI_2);</div><div class="line">           self.colorLayer.affineTransform = transform;</div><div class="line">       &#125;];</div><div class="line">       //randomize the layer background color</div><div class="line">       CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">       //commit the transaction</div><div class="line">       [CATransaction commit];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0b504d64ca403949.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.2.png"><br>注意旋转动画要比颜色渐变快得多，这是因为完成块是在颜色渐变的事务提交并出栈之后才被执行，于是，用默认的事务做变换，默认的时间也就变成了0.25秒。</p>
<p>#####图层行为<br> 现在来做个实验，试着直接对UIView关联的图层做动画而不是一个单独的图层。清单7.4是对清单7.2代码的一点修改，移除了colorLayer，并且直接设置layerView关联图层的背景色。</p>
<p>#####清单7.4 直接设置图层的属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //set the color of our layerView backing layer directly</div><div class="line">       self.layerView.layer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (IBAction)changeColor</div><div class="line">   &#123;</div><div class="line">       //begin a new transaction</div><div class="line">       [CATransaction begin];</div><div class="line">       //set the animation duration to 1 second</div><div class="line">       [CATransaction setAnimationDuration:1.0];</div><div class="line">       //randomize the layer background color</div><div class="line">       CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">       self.layerView.layer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">       //commit the transaction</div><div class="line">       [CATransaction commit];</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>运行程序，你会发现当按下按钮，图层颜色瞬间切换到新的值，而不是之前平滑过渡的动画。发生了什么呢？隐式动画好像被UIView关联图层给禁用了。</p>
<p>试想一下，如果UIView的属性都有动画特性的话，那么无论在什么时候修改它，我们都应该能注意到的。所以，如果说UIKit建立在Core Animation（默认对所有东西都做动画）之上，那么隐式动画是如何被UIKit禁用掉呢？</p>
<p>我们知道Core Animation通常对CALayer的所有属性（可动画的属性）做动画，但是UIView把它关联的图层的这个特性关闭了。为了更好说明这一点，我们需要知道隐式动画是如何实现的。</p>
<p>我们把改变属性时CALayer自动应用的动画称作行为，当CALayer的属性被修改时候，它会调用-actionForKey:方法，传递属性的名称。剩下的操作都在CALayer的头文件中有详细的说明，实质上是如下几步：</p>
<ul>
<li>图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。</li>
<li>如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。</li>
<li>如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。</li>
<li>最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。<br>所以一轮完整的搜索结束之后，-actionForKey:要么返回空（这种情况下将不会有动画发生），要么是CAAction协议对应的对象，最后CALayer拿这个结果去对先前和当前的值做动画。</li>
</ul>
<p>于是这就解释了UIKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。当不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。我们可以用一个demo做个简单的实验（清单7.5）</p>
<p>#####清单7.5 测试UIView的actionForLayer:forKey:实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //test layer action when outside of animation block</div><div class="line">        NSLog(@&quot;Outside: %@&quot;, [self.layerView actionForLayer:self.layerView.layer forKey:@&quot;backgroundColor&quot;]);</div><div class="line">        //begin animation block</div><div class="line">        [UIView beginAnimations:nil context:nil];</div><div class="line">        //test layer action when inside of animation block</div><div class="line">        NSLog(@&quot;Inside: %@&quot;, [self.layerView actionForLayer:self.layerView.layer forKey:@&quot;backgroundColor&quot;]);</div><div class="line">        //end animation block</div><div class="line">        [UIView commitAnimations];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p>运行程序，控制台显示结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ LayerTest[21215:c07] Outside: &lt;null&gt;</div><div class="line">$ LayerTest[21215:c07] Inside: &lt;CABasicAnimation: 0x757f090&gt;</div></pre></td></tr></table></figure></p>
<p> 于是我们可以预言，当属性在动画块之外发生改变，UIView直接通过返回nil来禁用隐式动画。但如果在动画块范围之内，根据动画具体类型返回相应的属性，在这个例子就是CABasicAnimation（第八章“显式动画”将会提到）。</p>
<p>当然返回nil并不是禁用隐式动画唯一的办法，CATransacition有个方法叫做+setDisableActions:，可以用来对所有属性打开或者关闭隐式动画。如果在清单7.2的[CATransaction begin]之后添加下面的代码，同样也会阻止动画的发生：<br><code>[CATransaction setDisableActions:YES];</code><br>总结一下，我们知道了如下几点:</p>
<ul>
<li>UIView关联的图层禁用了隐式动画，对这种图层做动画的唯一办法就是使用UIView的动画函数（而不是依赖CATransaction），或者继承UIView，并覆盖-actionForLayer:forKey:方法，或者直接创建一个显式动画（具体细节见第八章）。</li>
<li>对于单独存在的图层，我们可以通过实现图层的-actionForLayer:forKey:委托方法，或者提供一个actions字典来控制隐式动画。</li>
</ul>
<p>我们来对颜色渐变的例子使用一个不同的行为，通过给colorLayer设置一个自定义的actions字典。我们也可以使用委托来实现，但是actions字典可以写更少的代码。那么到底改如何创建一个合适的行为对象呢？</p>
<p>行为通常是一个被Core Animation隐式调用的显式动画对象。这里我们使用的是一个实现了CATransaction的实例，叫做推进过渡。</p>
<p>第八章中将会详细解释过渡，不过对于现在，知道CATransition响应CAAction协议，并且可以当做一个图层行为就足够了。结果很赞，不论在什么时候改变背景颜色，新的色块都是从左侧滑入，而不是默认的渐变效果。</p>
<p>#####清单7.6 实现自定义行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">@property (nonatomic, weak) IBOutlet CALayer *colorLayer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //create sublayer</div><div class="line">    self.colorLayer = [CALayer layer];</div><div class="line">    self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">    self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">    //add a custom action</div><div class="line">    CATransition *transition = [CATransition animation];</div><div class="line">    transition.type = kCATransitionPush;</div><div class="line">    transition.subtype = kCATransitionFromLeft;</div><div class="line">    self.colorLayer.actions = @&#123;@&quot;backgroundColor&quot;: transition&#125;;</div><div class="line">    //add it to our view</div><div class="line">    [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (IBAction)changeColor</div><div class="line">&#123;</div><div class="line">    //randomize the layer background color</div><div class="line">    CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">    self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-e5f1538ed0a19aec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.3.png"></p>
<p>#####呈现与模型<br>CALayer<br>的属性行为其实很不正常，因为改变一个图层的属性并没有立刻生效，而是通过一段时间渐变更新。这是怎么做到的呢？<br>当你改变一个图层的属性，属性值的确是立刻更新的（如果你读取它的数据，你会发现它的值在你设置它的那一刻就已经生效了），但是屏幕上并没有马上发生改变。这是因为你设置的属性并没有直接调整图层的外观，相反，他只是定义了图层动画结束之后将要变化的外观。<br>当设置CALayer的属性，实际上是在定义当前事务结束之后图层如何显示的模型。Core Animation扮演了一个控制器的角色，并且负责根据图层行为和事务设置去不断更新视图的这些属性在屏幕上的状态。</p>
<p>我们讨论的就是一个典型的微型MVC模式。CALayer<br>是一个连接用户界面（就是MVC中的view）虚构的类，但是在界面本身这个场景下，CALayer的行为更像是存储了视图如何显示和动画的数据模型。实际上，在苹果自己的文档中，图层树通常都是值的图层树模型。</p>
<p>在iOS中，屏幕每秒钟重绘60次。如果动画时长比60分之一秒要长，Core Animation就需要在设置一次新值和新值生效之间，对屏幕上的图层进行重新组织。这意味着CALayer<br>除了“真实”值（就是你设置的值）之外，必须要知道当前显示在屏幕上的属性值的记录。</p>
<p>每个图层属性的显示值都被存储在一个叫做呈现图层的独立图层当中，他可以通过-presentationLayer方法来访问。这个呈现图层实际上是模型图层的复制，但是它的属性值代表了在任何指定时刻当前外观效果。换句话说，你可以通过呈现图层的值来获取当前屏幕上真正显示出来的值（图7.4）。</p>
<p>我们在第一章中提到除了图层树，另外还有呈现树。呈现树通过图层树中所有图层的呈现图层所形成。注意呈现图层仅仅当图层首次被提交（就是首次第一次在屏幕上显示）的时候创建，所以在那之前调用-presentationLayer<br>将会返回nil。</p>
<p>你可能注意到有一个叫做–modelLayer的方法。在呈现图层上调用–modelLayer将会返回它正在呈现所依赖的CALayer<br>。通常在一个图层上调用-modelLayer会返回–self(实际上我们已经创建的原始图层就是一种数据模型）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-842f562b2414851f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="7.4.png"></p>
<p>大多数情况下，你不需要直接访问呈现图层，你可以通过和模型图层的交互，来让Core Animation更新显示。两种情况下呈现图层会变得很有用，一个是同步动画，一个是处理用户交互。</p>
<ul>
<li>如果你在实现一个基于定时器的动画（见第11章“基于定时器的动画”），而不仅仅是基于事务的动画，这个时候准确地知道在某一时刻图层显示在什么位置就会对正确摆放图层很有用了。</li>
<li>如果你想让你做动画的图层响应用户输入，你可以使用-hitTest:<br>方法（见第三章“图层几何学”）来判断指定图层是否被触摸，这时候对呈现图层而不是模型图层调用-hitTest:<br>会显得更有意义，因为呈现图层代表了用户当前看到的图层位置，而不是当前动画结束之后的位置。</li>
</ul>
<p>我们可以用一个简单的案例来证明后者（见清单7.7）。在这个例子中，点击屏幕上的任意位置将会让图层平移到那里。点击图层本身可以随机改变它的颜色。我们通过对呈现图层调用-hitTest:来判断是否被点击。</p>
<p>如果修改代码让-hitTest:直接作用于colorLayer而不是呈现图层，你会发现当图层移动的时候它并不能正确显示。这时候你就需要点击图层将要移动到的位置而不是图层本身来响应点击（这就是为什么用呈现图层来响应交互的原因）</p>
<p>#####清单7.7 使用presentationLayer图层来判断当前图层位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">  </div><div class="line">  @property (nonatomic, strong) CALayer *colorLayer;</div><div class="line">  </div><div class="line">  @end</div><div class="line">  </div><div class="line">  @implementation ViewController</div><div class="line">  </div><div class="line">  - (void)viewDidLoad</div><div class="line">  &#123;</div><div class="line">      [super viewDidLoad];</div><div class="line">      //create a red layer</div><div class="line">      self.colorLayer = [CALayer layer];</div><div class="line">      self.colorLayer.frame = CGRectMake(0, 0, 100, 100);</div><div class="line">      self.colorLayer.position = CGPointMake(self.view.bounds.size.width / 2, self.view.bounds.size.height / 2);</div><div class="line">      self.colorLayer.backgroundColor = [UIColor redColor].CGColor;</div><div class="line">      [self.view.layer addSublayer:self.colorLayer];</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">  &#123;</div><div class="line">      //get the touch point</div><div class="line">      CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">      //check if we&apos;ve tapped the moving layer</div><div class="line">      if ([self.colorLayer.presentationLayer hitTest:point]) &#123;</div><div class="line">          //randomize the layer background color</div><div class="line">          CGFloat red = arc4random() / (CGFloat)INT_MAX;</div><div class="line">          CGFloat green = arc4random() / (CGFloat)INT_MAX;</div><div class="line">          CGFloat blue = arc4random() / (CGFloat)INT_MAX;</div><div class="line">          self.colorLayer.backgroundColor = [UIColor colorWithRed:red green:green blue:blue alpha:1.0].CGColor;</div><div class="line">      &#125; else &#123;</div><div class="line">          //otherwise (slowly) move the layer to new position</div><div class="line">          [CATransaction begin];</div><div class="line">          [CATransaction setAnimationDuration:4.0];</div><div class="line">          self.colorLayer.position = point;</div><div class="line">          [CATransaction commit];</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  @end</div></pre></td></tr></table></figure></p>
<p>#####总结<br>这一章讨论了隐式动画，还有Core Animation对指定属性选择合适的动画行为的机制。同时你知道了UIKit是如何充分利用Core Animation的隐式动画机制来强化它的显式系统，以及动画是如何被默认禁用并且当需要的时候启用的。最后，你了解了呈现和模型图层，以及Core Animation是如何通过它们来判断出图层当前位置以及将要到达的位置。<br>在下一章中，我们将研究Core Animation提供的显式动画类型，既可以直接对图层属性做动画，也可以覆盖默认的图层行为。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg"
              alt="雪晟" />
          
            <p class="site-author-name" itemprop="name">雪晟</p>
            <p class="site-description motion-element" itemprop="description">多去尝试你从未尝试的。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">97</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liuxinixn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/3d7c50f31b88" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-flag"></i>Jianshu</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雪晟</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
