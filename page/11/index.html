<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="多去尝试你从未尝试的。">
<meta property="og:type" content="website">
<meta property="og:title" content="雪晟">
<meta property="og:url" content="liuxinixn.github.io/page/11/index.html">
<meta property="og:site_name" content="雪晟">
<meta property="og:description" content="多去尝试你从未尝试的。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="雪晟">
<meta name="twitter:description" content="多去尝试你从未尝试的。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="liuxinixn.github.io/page/11/"/>





  <title>雪晟</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">雪晟</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">十年饮冰，难凉热血。我是雪晟。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/10/CoreAnimation之基于定时器的动画/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/10/CoreAnimation之基于定时器的动画/" itemprop="url">CoreAnimation之基于定时器的动画</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-10T20:19:35+08:00">
                2016-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>我可以指导你，但是你必须按照我说的做。 – 骇客帝国</p>
</blockquote>
<p>在第10章“缓冲”中，我们研究了CAMediaTimingFunction，它是一个通过控制动画缓冲来模拟物理效果例如加速或者减速来增强现实感的东西，那么如果想更加真实地模拟物理交互或者实时根据用户输入修改动画改怎么办呢？在这一章中，我们将继续探索一种能够允许我们精确地控制一帧一帧展示的基于定时器的动画。</p>
<p>#####定时帧<br>动画看起来是用来显示一段连续的运动过程，但实际上当在固定位置上展示像素的时候并不能做到这一点。一般来说这种显示都无法做到连续的移动，能做的仅仅是足够快地展示一系列静态图片，只是看起来像是做了运动。</p>
<p>我们之前提到过<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>按照每秒60次刷新屏幕，然后CAAnimation计算出需要展示的新的帧，然后在每次屏幕更新的时候同步绘制上去，CAAnimation最机智的地方在于每次刷新需要展示的时候去计算插值和缓冲。</p>
<p>在第10章中，我们解决了如何自定义缓冲函数，然后根据需要展示的帧的数组来告诉CAKeyframeAnimation的实例如何去绘制。所有的Core Animation实际上都是按照一定的序列来显示这些帧，那么我们可以自己做到这些么？</p>
<p>#####NSTimer<br> 实际上，我们在第三章“图层几何学”中已经做过类似的东西，就是时钟那个例子，我们用了NSTimer来对钟表的指针做定时动画，一秒钟更新一次，但是如果我们把频率调整成一秒钟更新60次的话，原理是完全相同的。</p>
<p>我们来试着用NSTimer来修改第十章中弹性球的例子。由于现在我们在定时器启动之后连续计算动画帧，我们需要在类中添加一些额外的属性来存储动画的fromValue，toValue，duration和当前的timeOffset（见清单11.1）。</p>
<p>#####清单11.1 使用NSTimer实现弹性球动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line">@property (nonatomic, strong) NSTimer *timer;</div><div class="line">@property (nonatomic, assign) NSTimeInterval duration;</div><div class="line">@property (nonatomic, assign) NSTimeInterval timeOffset;</div><div class="line">@property (nonatomic, strong) id fromValue;</div><div class="line">@property (nonatomic, strong) id toValue;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add ball image view</div><div class="line">    UIImage *ballImage = [UIImage imageNamed:@&quot;Ball.png&quot;];</div><div class="line">    self.ballView = [[UIImageView alloc] initWithImage:ballImage];</div><div class="line">    [self.containerView addSubview:self.ballView];</div><div class="line">    //animate</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //replay animation on tap</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">float interpolate(float from, float to, float time)</div><div class="line">&#123;</div><div class="line">    return (to - from) * time + from;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)interpolateFromValue:(id)fromValue toValue:(id)toValue time:(float)time</div><div class="line">&#123;</div><div class="line">    if ([fromValue isKindOfClass:[NSValue class]]) &#123;</div><div class="line">        //get type</div><div class="line">        const char *type = [(NSValue *)fromValue objCType];</div><div class="line">        if (strcmp(type, @encode(CGPoint)) == 0) &#123;</div><div class="line">            CGPoint from = [fromValue CGPointValue];</div><div class="line">            CGPoint to = [toValue CGPointValue];</div><div class="line">            CGPoint result = CGPointMake(interpolate(from.x, to.x, time), interpolate(from.y, to.y, time));</div><div class="line">            return [NSValue valueWithCGPoint:result];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //provide safe default implementation</div><div class="line">    return (time &lt; 0.5)? fromValue: toValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">float bounceEaseOut(float t)</div><div class="line">&#123;</div><div class="line">    if (t &lt; 4/11.0) &#123;</div><div class="line">        return (121 * t * t)/16.0;</div><div class="line">    &#125; else if (t &lt; 8/11.0) &#123;</div><div class="line">        return (363/40.0 * t * t) - (99/10.0 * t) + 17/5.0;</div><div class="line">    &#125; else if (t &lt; 9/10.0) &#123;</div><div class="line">        return (4356/361.0 * t * t) - (35442/1805.0 * t) + 16061/1805.0;</div><div class="line">    &#125;</div><div class="line">    return (54/5.0 * t * t) - (513/25.0 * t) + 268/25.0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //configure the animation</div><div class="line">    self.duration = 1.0;</div><div class="line">    self.timeOffset = 0.0;</div><div class="line">    self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    //stop the timer if it&apos;s already running</div><div class="line">    [self.timer invalidate];</div><div class="line">    //start the timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1/60.0</div><div class="line">                                                  target:self</div><div class="line">                                                selector:@selector(step:)</div><div class="line">                                                userInfo:nil</div><div class="line">                                                 repeats:YES];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)step:(NSTimer *)step</div><div class="line">&#123;</div><div class="line">    //update time offset</div><div class="line">    self.timeOffset = MIN(self.timeOffset + 1/60.0, self.duration);</div><div class="line">    //get normalized time offset (in range 0 - 1)</div><div class="line">    float time = self.timeOffset / self.duration;</div><div class="line">    //apply easing</div><div class="line">    time = bounceEaseOut(time);</div><div class="line">    //interpolate position</div><div class="line">    id position = [self interpolateFromValue:self.fromValue</div><div class="line">                                     toValue:self.toValue</div><div class="line">                                        time:time];</div><div class="line">    //move ball view to new position</div><div class="line">    self.ballView.center = [position CGPointValue];</div><div class="line">    //stop the timer if we&apos;ve reached the end of the animation</div><div class="line">    if (self.timeOffset &gt;= self.duration) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>很赞，而且和基于关键帧例子的代码一样很多，但是如果想一次性在屏幕上对很多东西做动画，很明显就会有很多问题。</p>
<p>NSTimer并不是最佳方案，为了理解这点，我们需要确切地知道NSTimer是如何工作的。iOS上的每个线程都管理了一个NSRunloop，字面上看就是通过一个循环来完成一些任务列表。但是对主线程，这些任务包含如下几项：</p>
<ul>
<li>处理触摸事件</li>
<li>发送和接受网络数据包</li>
<li>执行使用gcd的代码</li>
<li>处理计时器行为</li>
<li>屏幕重绘<br>当你设置一个NSTimer，他会被插入到当前任务列表中，然后直到指定时间过去之后才会被执行。但是何时启动定时器并没有一个时间上限，而且它只会在列表中上一个任务完成之后开始执行。这通常会导致有几毫秒的延迟，但是如果上一个任务过了很久才完成就会导致延迟很长一段时间。</li>
</ul>
<p>屏幕重绘的频率是一秒钟六十次，但是和定时器行为一样，如果列表中上一个执行了很长时间，它也会延迟。这些延迟都是一个随机值，于是就不能保证定时器精准地一秒钟执行六十次。有时候发生在屏幕重绘之后，这就会使得更新屏幕会有个延迟，看起来就是动画卡壳了。有时候定时器会在屏幕更新的时候执行两次，于是动画看起来就跳动了。</p>
<p>我们可以通过一些途径来优化：</p>
<pre><code>- 我们可以用CADisplayLink让更新频率严格控制在每次屏幕刷新之后。
</code></pre><ul>
<li>基于真实帧的持续时间而不是假设的更新频率来做动画。</li>
<li>调整动画计时器的run loop模式，这样就不会被别的事件干扰。</li>
</ul>
<p>#####CADisplayLink<br>CADisplayLink<br>是CoreAnimation提供的另一个类似于NSTimer的类，它总是在屏幕完成一次更新之前启动，它的接口设计的和NSTimer很类似，所以它实际上就是一个内置实现的替代，但是和timeInterval以秒为单位不同，CADisplayLink有一个整型的frameInterval属性，指定了间隔多少帧之后才执行。默认值是1，意味着每次屏幕更新之前都会执行一次。但是如果动画的代码执行起来超过了六十分之一秒，你可以指定frameInterval为2，就是说动画每隔一帧执行一次（一秒钟30帧）或者3，也就是一秒钟20次，等等。</p>
<p>用CADisplayLink而不是NSTimer，会保证帧率足够连续，使得动画看起来更加平滑，但即使CADisplayLink也不能保证每一帧都按计划执行，一些失去控制的离散的任务或者事件（例如资源紧张的后台程序）可能会导致动画偶尔地丢帧。当使用NSTimer的时候，一旦有机会计时器就会开启，但是CADisplayLink却不一样：如果它丢失了帧，就会直接忽略它们，然后在下一次更新的时候接着运行。</p>
<p>#####计算帧的持续时间<br> 无论是使用NSTimer还是CADisplayLink，我们仍然需要处理一帧的时间超出了预期的六十分之一秒。由于我们不能够计算出一帧真实的持续时间，所以需要手动测量。我们可以在每帧开始刷新的时候用CACurrentMediaTime()记录当前时间，然后和上一帧记录的时间去比较。</p>
<p>通过比较这些时间，我们就可以得到真实的每帧持续的时间，然后代替硬编码的六十分之一秒。我们来更新一下上个例子（见清单11.2）。</p>
<p>#####清单11.2 通过测量没帧持续的时间来使得动画更加平滑<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line">@property (nonatomic, strong) CADisplayLink *timer;</div><div class="line">@property (nonatomic, assign) CFTimeInterval duration;</div><div class="line">@property (nonatomic, assign) CFTimeInterval timeOffset;</div><div class="line">@property (nonatomic, assign) CFTimeInterval lastStep;</div><div class="line">@property (nonatomic, strong) id fromValue;</div><div class="line">@property (nonatomic, strong) id toValue;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //configure the animation</div><div class="line">    self.duration = 1.0;</div><div class="line">    self.timeOffset = 0.0;</div><div class="line">    self.fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    self.toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    //stop the timer if it&apos;s already running</div><div class="line">    [self.timer invalidate];</div><div class="line">    //start the timer</div><div class="line">    self.lastStep = CACurrentMediaTime();</div><div class="line">    self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                             selector:@selector(step:)];</div><div class="line">    [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                     forMode:NSDefaultRunLoopMode];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)step:(CADisplayLink *)timer</div><div class="line">&#123;</div><div class="line">    //calculate time delta</div><div class="line">    CFTimeInterval thisStep = CACurrentMediaTime();</div><div class="line">    CFTimeInterval stepDuration = thisStep - self.lastStep;</div><div class="line">    self.lastStep = thisStep;</div><div class="line">    //update time offset</div><div class="line">    self.timeOffset = MIN(self.timeOffset + stepDuration, self.duration);</div><div class="line">    //get normalized time offset (in range 0 - 1)</div><div class="line">    float time = self.timeOffset / self.duration;</div><div class="line">    //apply easing</div><div class="line">    time = bounceEaseOut(time);</div><div class="line">    //interpolate position</div><div class="line">    id position = [self interpolateFromValue:self.fromValue toValue:self.toValue</div><div class="line">                                        time:time];</div><div class="line">    //move ball view to new position</div><div class="line">    self.ballView.center = [position CGPointValue];</div><div class="line">    //stop the timer if we&apos;ve reached the end of the animation</div><div class="line">    if (self.timeOffset &gt;= self.duration) &#123;</div><div class="line">        [self.timer invalidate];</div><div class="line">        self.timer = nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#####Run Loop 模式<br> 注意到当创建CADisplayLink的时候，我们需要指定一个run loop和run loop mode，对于run loop来说，我们就使用了主线程的run loop，因为任何用户界面的更新都需要在主线程执行，但是模式的选择就并不那么清楚了，每个添加到run loop的任务都有一个指定了优先级的模式，为了保证用户界面保持平滑，iOS会提供和用户界面相关任务的优先级，而且当UI很活跃的时候的确会暂停一些别的任务。</p>
<p>一个典型的例子就是当是用UIScrollview滑动的时候，重绘滚动视图的内容会比别的任务优先级更高，所以标准的NSTimer和网络请求就不会启动，一些常见的run loop模式如下：</p>
<pre><code>- NSDefaultRunLoopMode - 标准优先级
- NSRunLoopCommonModes - 高优先级
- UITrackingRunLoopMode - 用于UIScrollView和别的控件的动画
</code></pre><p>在我们的例子中，我们是用了NSDefaultRunLoopMode，但是不能保证动画平滑的运行，所以就可以用NSRunLoopCommonModes来替代。但是要小心，因为如果动画在一个高帧率情况下运行，你会发现一些别的类似于定时器的任务或者类似于滑动的其他iOS动画会暂停，直到动画结束</p>
<p> 同样可以同时对CADisplayLink指定多个run loop模式，于是我们可以同时加入NSDefaultRunLoopMode和UITrackingRunLoopMode来保证它不会被滑动打断，也不会被其他UIKit控件动画影响性能，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">self.timer = [CADisplayLink displayLinkWithTarget:self selector:@selector(step:)];</div><div class="line">[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSDefaultRunLoopMode];</div><div class="line">[self.timer addToRunLoop:[NSRunLoop mainRunLoop] forMode:UITrackingRunLoopMode];</div></pre></td></tr></table></figure></p>
<p>和CADisplayLink类似，NSTimer同样也可以使用不同的run loop模式配置，通过别的函数，而不是+scheduledTimerWithTimeInterval:构造器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">self.timer = [NSTimer timerWithTimeInterval:1/60.0</div><div class="line">                                 target:self</div><div class="line">                               selector:@selector(step:)</div><div class="line">                               userInfo:nil</div><div class="line">                                repeats:YES];</div><div class="line">[[NSRunLoop mainRunLoop] addTimer:self.timer</div><div class="line">                          forMode:NSRunLoopCommonModes];</div></pre></td></tr></table></figure></p>
<p>#####物理模拟<br>即使使用了基于定时器的动画来复制第10章中关键帧的行为，但还是会有一些本质上的区别：在关键帧的实现中，我们提前计算了所有帧，但是在新的解决方案中，我们实际上实在按需要在计算。意义在于我们可以根据用户输入实时修改动画的逻辑，或者和别的实时动画系统例如物理引擎进行整合。</p>
<p>#####Chipmunk<br>我们来基于物理学创建一个真实的重力模拟效果来取代当前基于缓冲的弹性动画，但即使模拟2D的物理效果就已近极其复杂了，所以就不要尝试去实现它了，直接用开源的物理引擎库好了。</p>
<p>我们将要使用的物理引擎叫做Chipmunk。另外的2D物理引擎也同样可以（例如Box2D），但是Chipmunk使用纯C写的，而不是C++，好处在于更容易和Objective-C项目整合。Chipmunk有很多版本，包括一个和Objective-C绑定的“indie”版本。C语言的版本是免费的，所以我们就用它好了。在本书写作的时候6.1.4是最新的版本；你可以从[<a href="http://chipmunk-physics.net]下载它。" target="_blank" rel="noopener">http://chipmunk-physics.net]下载它。</a></p>
<p>Chipmunk完整的物理引擎相当巨大复杂，但是我们只会使用如下几个类：</p>
<ul>
<li>cpSpace- 这是所有的物理结构体的容器。它有一个大小和一个可选的重力矢量</li>
<li>cpBody- 它是一个固态无弹力的刚体。它有一个坐标，以及其他物理属性，例如质量，运动和摩擦系数等等。</li>
<li>cpShape- 它是一个抽象的几何形状，用来检测碰撞。可以给结构体添加一个多边形，而且cpShape<br>有各种子类来代表不同形状的类型。</li>
</ul>
<p>在例子中，我们来对一个木箱建模，然后在重力的影响下下落。我们来创建一个Crate类，包含屏幕上的可视效果（一个UIImageView）和一个物理模型（一个cpBody和一个cpPolyShape，一个cpShape<br>的多边形子类来代表矩形木箱）。</p>
<p>用C版本的Chipmunk会带来一些挑战，因为它现在并不支持Objective-C的引用计数模型，所以我们需要准确的创建和释放对象。为了简化，我们把cpShape和cpBody的生命周期和Crate类进行绑定，然后在木箱的-init方法中创建，在-dealloc中释放。木箱物理属性的配置很复杂，所以阅读了Chipmunk文档会很有意义。</p>
<p>视图控制器用来管理cpSpace，还有和之前一样的计时器逻辑。在每一步中，我们更新cpSpace（用来进行物理计算和所有结构体的重新摆放）然后迭代对象，然后再更新我们的木箱视图的位置来匹配木箱的模型（在这里，实际上只有一个结构体，但是之后我们将要添加更多）。</p>
<p>Chipmunk使用了一个和UIKit颠倒的坐标系（Y轴向上为正方向）。为了使得物理模型和视图之间的同步更简单，我们需要通过使用geometryFlipped属性翻转容器视图的集合坐标（第3章中有提到），于是模型和视图都共享一个相同的坐标系。】</p>
<p> 具体的代码见清单11.3。注意到我们并没有在任何地方释放cpSpace对象。在这个例子中，内存空间将会在整个app的生命周期中一直存在，所以这没有问题。但是在现实世界的场景中，我们需要像创建木箱结构体和形状一样去管理我们的空间，封装在标准的Cocoa对象中，然后来管理Chipmunk对象的生命周期。图11.1展示了掉落的木箱。</p>
<p>#####清单11.3 使用物理学来对掉落的木箱建模<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &quot;chipmunk.h&quot;</div><div class="line">    </div><div class="line">    @interface Crate : UIImageView</div><div class="line">    </div><div class="line">    @property (nonatomic, assign) cpBody *body;</div><div class="line">    @property (nonatomic, assign) cpShape *shape;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation Crate</div><div class="line">    </div><div class="line">#define MASS 100</div><div class="line">    </div><div class="line">    - (id)initWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        if ((self = [super initWithFrame:frame])) &#123;</div><div class="line">            //set image</div><div class="line">            self.image = [UIImage imageNamed:@&quot;Crate.png&quot;];</div><div class="line">            self.contentMode = UIViewContentModeScaleAspectFill;</div><div class="line">            //create the body</div><div class="line">            self.body = cpBodyNew(MASS, cpMomentForBox(MASS, frame.size.width, frame.size.height));</div><div class="line">            //create the shape</div><div class="line">            cpVect corners[] = &#123;</div><div class="line">                cpv(0, 0),</div><div class="line">                cpv(0, frame.size.height),</div><div class="line">                cpv(frame.size.width, frame.size.height),</div><div class="line">                cpv(frame.size.width, 0),</div><div class="line">            &#125;;</div><div class="line">            self.shape = cpPolyShapeNew(self.body, 4, corners, cpv(-frame.size.width/2, -frame.size.height/2));</div><div class="line">            //set shape friction &amp; elasticity</div><div class="line">            cpShapeSetFriction(self.shape, 0.5);</div><div class="line">            cpShapeSetElasticity(self.shape, 0.8);</div><div class="line">            //link the crate to the shape</div><div class="line">            //so we can refer to crate from callback later on</div><div class="line">            self.shape-&gt;data = (__bridge void *)self;</div><div class="line">            //set the body position to match view</div><div class="line">            cpBodySetPos(self.body, cpv(frame.origin.x + frame.size.width/2, 300 - frame.origin.y - frame.size.height/2));</div><div class="line">        &#125;</div><div class="line">        return self;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)dealloc</div><div class="line">    &#123;</div><div class="line">        //release shape and body</div><div class="line">        cpShapeFree(_shape);</div><div class="line">        cpBodyFree(_body);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @property (nonatomic, assign) cpSpace *space;</div><div class="line">    @property (nonatomic, strong) CADisplayLink *timer;</div><div class="line">    @property (nonatomic, assign) CFTimeInterval lastStep;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">#define GRAVITY 1000</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        //invert view coordinate system to match physics</div><div class="line">        self.containerView.layer.geometryFlipped = YES;</div><div class="line">        //set up physics space</div><div class="line">        self.space = cpSpaceNew();</div><div class="line">        cpSpaceSetGravity(self.space, cpv(0, -GRAVITY));</div><div class="line">        //add a crate</div><div class="line">        Crate *crate = [[Crate alloc] initWithFrame:CGRectMake(100, 0, 100, 100)];</div><div class="line">        [self.containerView addSubview:crate];</div><div class="line">        cpSpaceAddBody(self.space, crate.body);</div><div class="line">        cpSpaceAddShape(self.space, crate.shape);</div><div class="line">        //start the timer</div><div class="line">        self.lastStep = CACurrentMediaTime();</div><div class="line">        self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                                 selector:@selector(step:)];</div><div class="line">        [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                         forMode:NSDefaultRunLoopMode];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    void updateShape(cpShape *shape, void *unused)</div><div class="line">    &#123;</div><div class="line">        //get the crate object associated with the shape</div><div class="line">        Crate *crate = (__bridge Crate *)shape-&gt;data;</div><div class="line">        //update crate view position and angle to match physics shape</div><div class="line">        cpBody *body = shape-&gt;body;</div><div class="line">        crate.center = cpBodyGetPos(body);</div><div class="line">        crate.transform = CGAffineTransformMakeRotation(cpBodyGetAngle(body));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)step:(CADisplayLink *)timer</div><div class="line">    &#123;</div><div class="line">        //calculate step duration</div><div class="line">        CFTimeInterval thisStep = CACurrentMediaTime();</div><div class="line">        CFTimeInterval stepDuration = thisStep - self.lastStep;</div><div class="line">        self.lastStep = thisStep;</div><div class="line">        //update physics</div><div class="line">        cpSpaceStep(self.space, stepDuration);</div><div class="line">        //update all the shapes</div><div class="line">        cpSpaceEachShape(self.space, &amp;updateShape, NULL);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d283e91c630081dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="11.1.png"></p>
<p>#####添加用户交互<br> 下一步就是在视图周围添加一道不可见的墙，这样木箱就不会掉落出屏幕之外。或许你会用另一个矩形的cpPolyShape来实现，就和之前创建木箱那样，但是我们需要检测的是木箱何时离开视图，而不是何时碰撞，所以我们需要一个空心而不是固体矩形。</p>
<p>我们可以通过给cpSpace添加四个cpSegmentShape对象（cpSegmentShape代表一条直线，所以四个拼起来就是一个矩形）。然后赋给空间的staticBody属性（一个不被重力影响的结构体）而不是像木箱那样一个新的cpBody实例，因为我们不想让这个边框矩形滑出屏幕或者被一个下落的木箱击中而消失。</p>
<p>同样可以再添加一些木箱来做一些交互。最后再添加一个加速器，这样可以通过倾斜手机来调整重力矢量（为了测试需要在一台真实的设备上运行程序，因为模拟器不支持加速器事件，即使旋转屏幕）。清单11.4展示了更新后的代码，运行结果见图11.2。</p>
<p>由于示例只支持横屏模式，所以交换加速计矢量的x和y值。如果在竖屏下运行程序，请把他们换回来，不然重力方向就错乱了。试一下就知道了，木箱会沿着横向移动。</p>
<p>#####清单11.4 使用围墙和多个木箱的更新后的代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">    - (void)addCrateWithFrame:(CGRect)frame</div><div class="line">    &#123;</div><div class="line">        Crate *crate = [[Crate alloc] initWithFrame:frame];</div><div class="line">        [self.containerView addSubview:crate];</div><div class="line">        cpSpaceAddBody(self.space, crate.body);</div><div class="line">        cpSpaceAddShape(self.space, crate.shape);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)addWallShapeWithStart:(cpVect)start end:(cpVect)end</div><div class="line">    &#123;</div><div class="line">        cpShape *wall = cpSegmentShapeNew(self.space-&gt;staticBody, start, end, 1);</div><div class="line">        cpShapeSetCollisionType(wall, 2);</div><div class="line">        cpShapeSetFriction(wall, 0.5);</div><div class="line">        cpShapeSetElasticity(wall, 0.8);</div><div class="line">        cpSpaceAddStaticShape(self.space, wall);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        //invert view coordinate system to match physics</div><div class="line">        self.containerView.layer.geometryFlipped = YES;</div><div class="line">        //set up physics space</div><div class="line">        self.space = cpSpaceNew();</div><div class="line">        cpSpaceSetGravity(self.space, cpv(0, -GRAVITY));</div><div class="line">        //add wall around edge of view</div><div class="line">        [self addWallShapeWithStart:cpv(0, 0) end:cpv(300, 0)];</div><div class="line">        [self addWallShapeWithStart:cpv(300, 0) end:cpv(300, 300)];</div><div class="line">        [self addWallShapeWithStart:cpv(300, 300) end:cpv(0, 300)];</div><div class="line">        [self addWallShapeWithStart:cpv(0, 300) end:cpv(0, 0)];</div><div class="line">        //add a crates</div><div class="line">        [self addCrateWithFrame:CGRectMake(0, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(32, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(64, 0, 64, 64)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(128, 0, 32, 32)];</div><div class="line">        [self addCrateWithFrame:CGRectMake(0, 32, 64, 64)];</div><div class="line">        //start the timer</div><div class="line">        self.lastStep = CACurrentMediaTime();</div><div class="line">        self.timer = [CADisplayLink displayLinkWithTarget:self</div><div class="line">                                                 selector:@selector(step:)];</div><div class="line">        [self.timer addToRunLoop:[NSRunLoop mainRunLoop]</div><div class="line">                         forMode:NSDefaultRunLoopMode];</div><div class="line">        //update gravity using accelerometer</div><div class="line">        [UIAccelerometer sharedAccelerometer].delegate = self;</div><div class="line">        [UIAccelerometer sharedAccelerometer].updateInterval = 1/60.0;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)accelerometer:(UIAccelerometer *)accelerometer didAccelerate:(UIAcceleration *)acceleration</div><div class="line">    &#123;</div><div class="line">        //update gravity</div><div class="line">        cpSpaceSetGravity(self.space, cpv(acceleration.y * GRAVITY, -acceleration.x * GRAVITY));</div><div class="line">    &#125;</div><div class="line">   ``` </div><div class="line">    </div><div class="line">![11.2.png](http://upload-images.jianshu.io/upload_images/1694376-72bafe2f6175f44d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</div><div class="line">#####模拟时间以及固定的时间步长</div><div class="line"></div><div class="line"> 对于实现动画的缓冲效果来说，计算每帧持续的时间是一个很好的解决方案，但是对模拟物理效果并不理想。通过一个可变的时间步长来实现有着两个弊端：</div><div class="line">- 如果时间步长不是固定的，精确的值，物理效果的模拟也就随之不确定。这意味着即使是传入相同的输入值，也可能在不同场合下有着不同的效果。有时候没多大影响，但是在基于物理引擎的游戏下，玩家就会由于相同的操作行为导致不同的结果而感到困惑。同样也会让测试变得麻烦。</div><div class="line">- 由于性能故常造成的丢帧或者像电话呼入的中断都可能会造成不正确的结果。考虑一个像子弹那样快速移动物体，每一帧的更新都需要移动子弹，检测碰撞。如果两帧之间的时间加长了，子弹就会在这一步移动更远的距离，穿过围墙或者是别的障碍，这样就丢失了碰撞。</div><div class="line"></div><div class="line"></div><div class="line">我们想得到的理想的效果就是通过固定的时间步长来计算物理效果，但是在屏幕发生重绘的时候仍然能够同步更新视图（可能会由于在我们控制范围之外造成不可预知的效果）。</div><div class="line"></div><div class="line">幸运的是，由于我们的模型（在这个例子中就是Chipmunk的cpSpace中的cpBody）被视图（就是屏幕上代表木箱的UIView对象）分离，于是就很简单了。我们只需要根据屏幕刷新的时间跟踪时间步长，然后根据每帧去计算一个或者多个模拟出来的效果。</div><div class="line">    </div><div class="line"> 我们可以通过一个简单的循环来实现。通过每次CADisplayLink的启动来通知屏幕将要刷新，然后记录下当前的CACurrentMediaTime()。我们需要在一个小增量中提前重复物理模拟（这里用120分之一秒）直到赶上显示的时间。然后更新我们的视图，在屏幕刷新的时候匹配当前物理结构体的显示位置。</div><div class="line"></div><div class="line">清单11.5展示了固定时间步长版本的代码</div><div class="line"></div><div class="line">#####清单11.5 固定时间步长的木箱模拟</div></pre></td></tr></table></figure></p>
<p>#define SIMULATION_STEP (1/120.0)</p>
<pre><code>- (void)step:(CADisplayLink *)timer
{
    //calculate frame step duration
    CFTimeInterval frameTime = CACurrentMediaTime();
    //update simulation
    while (self.lastStep &lt; frameTime) {
        cpSpaceStep(self.space, SIMULATION_STEP);
        self.lastStep += SIMULATION_STEP;
    }

    //update all the shapes
    cpSpaceEachShape(self.space, &amp;updateShape, NULL);
}
</code></pre><p>```</p>
<p>#####避免死亡螺旋<br> 当使用固定的模拟时间步长时候，有一件事情一定要注意，就是用来计算物理效果的现实世界的时间并不会加速模拟时间步长。在我们的例子中，我们随意选择了120分之一秒来模拟物理效果。Chipmunk很快，我们的例子也很简单，所以cpSpaceStep()会完成的很好，不会延迟帧的更新。</p>
<p>但是如果场景很复杂，比如有上百个物体之间的交互，物理计算就会很复杂，cpSpaceStep()的计算也可能会超出1/120秒。我们没有测量出物理步长的时间，因为我们假设了相对于帧刷新来说并不重要，但是如果模拟步长更久的话，就会延迟帧率。</p>
<p>如果帧刷新的时间延迟的话会变得很糟糕，我们的模拟需要执行更多的次数来同步真实的时间。这些额外的步骤就会继续延迟帧的更新，等等。这就是所谓的死亡螺旋，因为最后的结果就是帧率变得越来越慢，直到最后应用程序卡死了。</p>
<p>我们可以通过添加一些代码在设备上来对物理步骤计算真实世界的时间，然后自动调整固定时间步长，但是实际上它不可行。其实只要保证你给容错留下足够的边长，然后在期望支持的最慢的设备上进行测试就可以了。如果物理计算超过了模拟时间的50%，就需要考虑增加模拟时间步长（或者简化场景）。如果模拟时间步长增加到超过1/60秒（一个完整的屏幕更新时间），你就需要减少动画帧率到一秒30帧或者增加CADisplayLink的frameInterval来保证不会随机丢帧，不然你的动画将会看起来不平滑。</p>
<p>#####总结<br> 在这一章中，我们了解了如何通过一个计时器创建一帧帧的实时动画，包括缓冲，物理模拟等等一系列动画技术，以及用户输入（通过加速计）。</p>
<p>在第三部分中，我们将研究动画性能是如何被被设备限制所影响的，以及如何调整我们的代码来活的足够好的帧率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/09/CoreAnimation之缓冲/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/09/CoreAnimation之缓冲/" itemprop="url">CoreAnimation缓冲</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-09T20:19:35+08:00">
                2016-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>生活和艺术一样，最美的永远是曲线。 – 爱德华布尔沃 - 利顿</p>
</blockquote>
<p>在第九章“图层时间”中，我们讨论了动画时间和CAMediaTiming<br>协议。现在我们来看一下另一个和时间相关的机制–所谓的缓冲。Core Animation使用缓冲来使动画移动更平滑更自然，而不是看起来的那种机械和人工，在这一章我们将要研究如何对你的动画控制和自定义缓冲曲线。</p>
<p>#####动画速度<br>动画实际上就是一段时间内的变化，这就暗示了变化一定是随着某个特定的速率进行。速率由以下公式计算而来：</p>
<p><code>velocity = change / time</code></p>
<p>这里的变化可以指的是一个物体移动的距离，时间指动画持续的时长，用这样的一个移动可以更加形象的描述（比如position<br>和bounds属性的动画），但实际上它应用于任意可以做动画的属性（比如color和opacity）。</p>
<p>上面的等式假设了速度在整个动画过程中都是恒定不变的（就如同第八章“显式动画”的情况），对于这种恒定速度的动画我们称之为“线性步调”，而且从技术的角度而言这也是实现动画最简单的方式，但也是完全不真实的一种效果。</p>
<p>考虑一个场景，一辆车行驶在一定距离内，它并不会一开始就以60mph的速度行驶，然后到达终点后突然变成0mph。一是因为需要无限大的加速度（即使是最好的车也不会在0秒内从0跑到60），另外不然的话会干死所有乘客。在现实中，它会慢慢地加速到全速，然后当它接近终点的时候，它会慢慢地减速，直到最后停下来。</p>
<p>那么对于一个掉落到地上的物体又会怎样呢？它会首先停在空中，然后一直加速到落到地面，然后突然停止（然后由于积累的动能转换伴随着一声巨响，砰！）。</p>
<p>现实生活中的任何一个物体都会在运动中加速或者减速。那么我们如何在动画中实现这种加速度呢？一种方法是使用物理引擎来对运动物体的摩擦和动量来建模，然而这会使得计算过于复杂。我们称这种类型的方程为缓冲函数，幸运的是，Core Animation内嵌了一系列标准函数提供给我们使用。</p>
<p>#####CAMediaTimingFunction<br> 那么该如何使用缓冲方程式呢？首先需要设置CAAnimation的timingFunction属性，是CAMediaTimingFunction类的一个对象。如果想改变隐式动画的计时函数，同样也可以使用CATransaction的+setAnimationTimingFunction:方法。</p>
<p>这里有一些方式来创建CAMediaTimingFunction，最简单的方式是调用+timingFunctionWithName:的构造方法。这里传入如下几个常量之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">kCAMediaTimingFunctionLinear </div><div class="line">kCAMediaTimingFunctionEaseIn </div><div class="line">kCAMediaTimingFunctionEaseOut </div><div class="line">kCAMediaTimingFunctionEaseInEaseOut</div><div class="line">kCAMediaTimingFunctionDefault</div></pre></td></tr></table></figure></p>
<p>kCAMediaTimingFunctionLinear选项创建了一个线性的计时函数，同样也是CAAnimation的timingFunction属性为空时候的默认函数。线性步调对于那些立即加速并且保持匀速到达终点的场景会有意义（例如射出枪膛的子弹），但是默认来说它看起来很奇怪，因为对大多数的动画来说确实很少用到。</p>
<p>kCAMediaTimingFunctionEaseIn常量创建了一个慢慢加速然后突然停止的方法。对于之前提到的自由落体的例子来说很适合，或者比如对准一个目标的导弹的发射。</p>
<p>kCAMediaTimingFunctionEaseOut则恰恰相反，它以一个全速开始，然后慢慢减速停止。它有一个削弱的效果，应用的场景比如一扇门慢慢地关上，而不是砰地一声。</p>
<p>kCAMediaTimingFunctionEaseInEaseOut创建了一个慢慢加速然后再慢慢减速的过程。这是现实世界大多数物体移动的方式，也是大多数动画来说最好的选择。如果只可以用一种缓冲函数的话，那就必须是它了。那么你会疑惑为什么这不是默认的选择，实际上当使用UIView的动画方法时，他的确是默认的，但当创建CAAnimation<br>的时候，就需要手动设置它了。</p>
<p>最后还有一个kCAMediaTimingFunctionDefault，它和kCAMediaTimingFunctionEaseInEaseOut很类似，但是加速和减速的过程都稍微有些慢。它kCAMediaTimingFunctionEaseInEaseOut<br>的区别很难察觉，可能是苹果觉得它对于隐式动画来说更适合（然后对UIKit就改变了想法，而是使用kCAMediaTimingFunctionEaseInEaseOut作为默认效果），虽然它的名字说是默认的，但还是要记住当创建显式的CAAnimation<br>它并不是默认选项（换句话说，默认的图层行为动画用kCAMediaTimingFunctionDefault作为它们的计时方法）。</p>
<p>你可以使用一个简单的测试工程来实验一下（清单10.1），在运行之前改变缓冲函数的代码，然后点击任何地方来观察图层是如何通过指定的缓冲移动的。</p>
<p>#####清单10.1 缓冲函数的简单测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) CALayer *colorLayer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a red layer</div><div class="line">    self.colorLayer = [CALayer layer];</div><div class="line">    self.colorLayer.frame = CGRectMake(0, 0, 100, 100);</div><div class="line">    self.colorLayer.position = CGPointMake(self.view.bounds.size.width/2.0, self.view.bounds.size.height/2.0);</div><div class="line">    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;</div><div class="line">    [self.view.layer addSublayer:self.colorLayer];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //configure the transaction</div><div class="line">    [CATransaction begin];</div><div class="line">    [CATransaction setAnimationDuration:1.0];</div><div class="line">    [CATransaction setAnimationTimingFunction:[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseOut]];</div><div class="line">    //set the position</div><div class="line">    self.colorLayer.position = [[touches anyObject] locationInView:self.view];</div><div class="line">    //commit transaction</div><div class="line">    [CATransaction commit];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>#####UIView的动画缓冲<br>UIKit的动画也同样支持这些缓冲方法的使用，尽管语法和常量有些不同，为了改变UIView动画的缓冲选项，给options参数添加如下常量之一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">UIViewAnimationOptionCurveEaseInOut </div><div class="line">UIViewAnimationOptionCurveEaseIn </div><div class="line">UIViewAnimationOptionCurveEaseOut </div><div class="line">UIViewAnimationOptionCurveLinear</div></pre></td></tr></table></figure></p>
<p> 它们和CAMediaTimingFunction紧密关联，UIViewAnimationOptionCurveEaseInOut是默认值（这里没有kCAMediaTimingFunctionDefault相对应的值了）。</p>
<p>具体使用方法见清单10.2（注意到这里不再使用UIView额外添加的图层，因为UIKit的动画并不支持这类图层）。</p>
<p>#####清单10.2 使用UIKit动画的缓冲测试工程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, strong) UIView *colorView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a red layer</div><div class="line">    self.colorView = [[UIView alloc] init];</div><div class="line">    self.colorView.bounds = CGRectMake(0, 0, 100, 100);</div><div class="line">    self.colorView.center = CGPointMake(self.view.bounds.size.width / 2, self.view.bounds.size.height / 2);</div><div class="line">    self.colorView.backgroundColor = [UIColor redColor];</div><div class="line">    [self.view addSubview:self.colorView];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //perform the animation</div><div class="line">    [UIView animateWithDuration:1.0 delay:0.0</div><div class="line">                        options:UIViewAnimationOptionCurveEaseOut</div><div class="line">                     animations:^&#123;</div><div class="line">                         //set the position</div><div class="line">                         self.colorView.center = [[touches anyObject] locationInView:self.view];</div><div class="line">                     &#125;</div><div class="line">                     completion:NULL];</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>#####缓冲和关键帧动画<br>或许你会回想起第八章里面颜色切换的关键帧动画由于线性变换的原因（见清单8.5）看起来有些奇怪，使得颜色变换非常不自然。为了纠正这点，我们来用更加合适的缓冲方法，例如kCAMediaTimingFunctionEaseIn，给图层的颜色变化添加一点脉冲效果，让它更像现实中的一个彩色灯泡。</p>
<p>我们不想给整个动画过程应用这个效果，我们希望对每个动画的过程重复这样的缓冲，于是每次颜色的变换都会有脉冲效果。</p>
<p>CAKeyframeAnimation有一个NSArray类型的timingFunctions<br>属性，我们可以用它来对每次动画的步骤指定不同的计时函数。但是指定函数的个数一定要等于keyframes数组的元素个数减一，因为它是描述每一帧之间动画速度的函数。</p>
<p>在这个例子中，我们自始至终想使用同一个缓冲函数，但我们同样需要一个函数的数组来告诉动画不停地重复每个步骤，而不是在整个动画序列只做一次缓冲，我们简单地使用包含多个相同函数拷贝的数组就可以了（见清单10.3）。</p>
<p>运行更新后的代码，你会发现动画看起来更加自然了。</p>
<p>#####清单10.3 对CAKeyframeAnimation使用CAMediaTimingFunction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    @property (nonatomic, weak) IBOutlet CALayer *colorLayer;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create sublayer</div><div class="line">        self.colorLayer = [CALayer layer];</div><div class="line">        self.colorLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">        self.colorLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">        //add it to our view</div><div class="line">        [self.layerView.layer addSublayer:self.colorLayer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (IBAction)changeColor</div><div class="line">    &#123;</div><div class="line">        //create a keyframe animation</div><div class="line">        CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">        animation.keyPath = @&quot;backgroundColor&quot;;</div><div class="line">        animation.duration = 2.0;</div><div class="line">        animation.values = @[</div><div class="line">                             (__bridge id)[UIColor blueColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor redColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor greenColor].CGColor,</div><div class="line">                             (__bridge id)[UIColor blueColor].CGColor ];</div><div class="line">        //add timing function</div><div class="line">        CAMediaTimingFunction *fn = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn];</div><div class="line">        animation.timingFunctions = @[fn, fn, fn];</div><div class="line">        //apply animation to layer</div><div class="line">        [self.colorLayer addAnimation:animation forKey:nil];</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>#####自定义缓冲函数<br> 在第八章中，我们给时钟项目添加了动画。看起来很赞，但是如果有合适的缓冲函数就更好了。在显示世界中，钟表指针转动的时候，通常起步很慢，然后迅速啪地一声，最后缓冲到终点。但是标准的缓冲函数在这里每一个适合它，那该如何创建一个新的呢？</p>
<p>除了+functionWithName:之外，CAMediaTimingFunction同样有另一个构造函数，一个有四个浮点参数的+functionWithControlPoints::::（注意这里奇怪的语法，并没有包含具体每个参数的名称，这在objective-C中是合法的，但是却违反了苹果对方法命名的指导方针，而且看起来是一个奇怪的设计）。</p>
<p>使用这个方法，我们可以创建一个自定义的缓冲函数，来匹配我们的时钟动画，为了理解如何使用这个方法，我们要了解一些CAMediaTimingFunction是如何工作的。</p>
<p>#####三次贝塞尔曲线<br>CAMediaTimingFunction函数的主要原则在于它把输入的时间转换成起点和终点之间成比例的改变。我们可以用一个简单的图标来解释，横轴代表时间，纵轴代表改变的量，于是线性的缓冲就是一条从起点开始的简单的斜线（图10.1）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-dcd616ebc1d7d817.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.1.png"></p>
<p>这条曲线的斜率代表了速度，斜率的改变代表了加速度，原则上来说，任何加速的曲线都可以用这种图像来表示，但是CAMediaTimingFunction使用了一个叫做三次贝塞尔曲线的函数，它只可以产出指定缓冲函数的子集（我们之前在第八章中创建CAKeyframeAnimation路径的时候提到过三次贝塞尔曲线）。</p>
<p>你或许会回想起，一个三次贝塞尔曲线通过四个点来定义，第一个和最后一个点代表了曲线的起点和终点，剩下中间两个点叫做控制点，因为它们控制了曲线的形状，贝塞尔曲线的控制点其实是位于曲线之外的点，也就是说曲线并不一定要穿过它们。你可以把它们想象成吸引经过它们曲线的磁铁。</p>
<p>图10.2展示了一个三次贝塞尔缓冲函数的例子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-b85f8cfe5566baaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.2.png"></p>
<p> 实际上它是一个很奇怪的函数，先加速，然后减速，最后快到达终点的时候又加速，那么标准的缓冲函数又该如何用图像来表示呢？</p>
<p>CAMediaTimingFunction有一个叫做-getControlPointAtIndex:values:的方法，可以用来检索曲线的点，这个方法的设计的确有点奇怪（或许也就只有苹果能回答为什么不简单返回一个CGPoint），但是使用它我们可以找到标准缓冲函数的点，然后用UIBezierPath和CAShapeLayer来把它画出来。</p>
<p>曲线的起始和终点始终是{0, 0}和{1, 1}，于是我们只需要检索曲线的第二个和第三个点（控制点）。具体代码见清单10.4。所有的标准缓冲函数的图像见图10.3。</p>
<p>#####清单10.4 使用UIBezierPath绘制CAMediaTimingFunction<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //create timing function</div><div class="line">        CAMediaTimingFunction *function = [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut];</div><div class="line">        //get control points</div><div class="line">        CGPoint controlPoint1, controlPoint2;</div><div class="line">        [function getControlPointAtIndex:1 values:(float *)&amp;controlPoint1];</div><div class="line">        [function getControlPointAtIndex:2 values:(float *)&amp;controlPoint2];</div><div class="line">        //create curve</div><div class="line">        UIBezierPath *path = [[UIBezierPath alloc] init];</div><div class="line">        [path moveToPoint:CGPointZero];</div><div class="line">        [path addCurveToPoint:CGPointMake(1, 1)</div><div class="line">                controlPoint1:controlPoint1 controlPoint2:controlPoint2];</div><div class="line">        //scale the path up to a reasonable size for display</div><div class="line">        [path applyTransform:CGAffineTransformMakeScale(200, 200)];</div><div class="line">        //create shape layer</div><div class="line">        CAShapeLayer *shapeLayer = [CAShapeLayer layer];</div><div class="line">        shapeLayer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">        shapeLayer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">        shapeLayer.lineWidth = 4.0f;</div><div class="line">        shapeLayer.path = path.CGPath;</div><div class="line">        [self.layerView.layer addSublayer:shapeLayer];</div><div class="line">        //flip geometry so that 0,0 is in the bottom-left</div><div class="line">        self.layerView.layer.geometryFlipped = YES;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-54afa74cbf2aa63d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.3.png"></p>
<p>那么对于我们自定义时钟指针的缓冲函数来说，我们需要初始微弱，然后迅速上升，最后缓冲到终点的曲线，通过一些实验之后，最终结果如下：<br><code>[CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];</code></p>
<p>如果把它转换成缓冲函数的图像，最后如图10.4所示，如果把它添加到时钟的程序，就形成了之前一直期待的非常赞的效果（见代清单10.5）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c0827049652cabd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.4.png"></p>
<p>###清单10.5 添加了自定义缓冲函数的时钟程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (void)setAngle:(CGFloat)angle forHand:(UIView *)handView ￼animated:(BOOL)animated</div><div class="line">  &#123;</div><div class="line">      //generate transform</div><div class="line">      CATransform3D transform = CATransform3DMakeRotation(angle, 0, 0, 1);</div><div class="line">      if (animated) &#123;</div><div class="line">          //create transform animation</div><div class="line">          CABasicAnimation *animation = [CABasicAnimation animation];</div><div class="line">          animation.keyPath = @&quot;transform&quot;;</div><div class="line">          animation.fromValue = [handView.layer.presentationLayer valueForKey:@&quot;transform&quot;];</div><div class="line">          animation.toValue = [NSValue valueWithCATransform3D:transform];</div><div class="line">          animation.duration = 0.5;</div><div class="line">          animation.delegate = self;</div><div class="line">          animation.timingFunction = [CAMediaTimingFunction functionWithControlPoints:1 :0 :0.75 :1];</div><div class="line">          //apply animation</div><div class="line">          handView.layer.transform = transform;</div><div class="line">          [handView.layer addAnimation:animation forKey:nil];</div><div class="line">      &#125; else &#123;</div><div class="line">          //set transform directly</div><div class="line">          handView.layer.transform = transform;</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>#####更加复杂的动画曲线<br>考虑一个橡胶球掉落到坚硬的地面的场景，当开始下落的时候，它会持续加速知道落到地面，然后经过几次反弹，最后停下来。如果用一张图来说明，它会如图10.5所示。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-272872ff5eb96c3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.5.png"></p>
<p>这种效果没法用一个简单的三次贝塞尔曲线表示，于是不能用CAMediaTimingFunction来完成。但如果想要实现这样的效果，可以用如下几种方法：</p>
<ul>
<li>用CAKeyframeAnimation创建一个动画，然后分割成几个步骤，每个小步骤使用自己的计时函数（具体下节介绍）。</li>
<li>使用定时器逐帧更新实现动画（见第11章，“基于定时器的动画”）。<br>#####基于关键帧的缓冲<br>为了使用关键帧实现反弹动画，我们需要在缓冲曲线中对每一个显著的点创建一个关键帧（在这个情况下，关键点也就是每次反弹的峰值），然后应用缓冲函数把每段曲线连接起来。同时，我们也需要通过keyTimes<br>来指定每个关键帧的时间偏移，由于每次反弹的时间都会减少，于是关键帧并不会均匀分布。<br>清单10.6展示了实现反弹球动画的代码（见图10.6）<br>#####清单10.6 使用关键帧实现反弹球的动画<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) UIImageView *ballView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //add ball image view</div><div class="line">    UIImage *ballImage = [UIImage imageNamed:@&quot;Ball.png&quot;];</div><div class="line">    self.ballView = [[UIImageView alloc] initWithImage:ballImage];</div><div class="line">    [self.containerView addSubview:self.ballView];</div><div class="line">    //animate</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //replay animation on tap</div><div class="line">    [self animate];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = @[</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 32)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 140)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 220)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 250)],</div><div class="line">                         [NSValue valueWithCGPoint:CGPointMake(150, 268)]</div><div class="line">                         ];</div><div class="line">    </div><div class="line">    animation.timingFunctions = @[</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseOut],</div><div class="line">                                  [CAMediaTimingFunction functionWithName: kCAMediaTimingFunctionEaseIn]</div><div class="line">                                  ];</div><div class="line">    </div><div class="line">    animation.keyTimes = @[@0.0, @0.3, @0.5, @0.7, @0.8, @0.9, @0.95, @1.0];</div><div class="line">    //apply animation</div><div class="line">    self.ballView.layer.position = CGPointMake(150, 268);</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-256c3ef34723c976.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="10.6.png"><br>这种方式还算不错，但是实现起来略显笨重（因为要不停地尝试计算各种关键帧和时间偏移）并且和动画强绑定了（因为如果要改变动画的一个属性，那就意味着要重新计算所有的关键帧）。那该如何写一个方法，用缓冲函数来把任何简单的属性动画转换成关键帧动画呢，下面我们来实现它</p>
<p>#####流程自动化<br>在清单10.6中，我们把动画分割成相当大的几块，然后用Core Animation的缓冲进入和缓冲退出函数来大约形成我们想要的曲线。但如果我们把动画分割成更小的几部分，那么我们就可以用直线来拼接这些曲线（也就是线性缓冲）。为了实现自动化，我们需要知道如何做如下两件事情：</p>
<ul>
<li>自动把任意属性动画分割成多个关键帧</li>
<li>用一个数学函数表示弹性动画，使得可以对帧做便宜</li>
</ul>
<p>为了解决第一个问题，我们需要复制Core Animation的插值机制。这是一个传入起点和终点，然后在这两个点之间指定时间点产出一个新点的机制。对于简单的浮点起始值，公式如下（假设时间从0到1）：<br><code>value = (endValue – startValue) × time + startValue;</code></p>
<p> 那么如果要插入一个类似于CGPoint，CGColorRef或者CATransform3D这种更加复杂类型的值，我们可以简单地对每个独立的元素应用这个方法（也就CGPoint中的x和y值，CGColorRef中的红，蓝，绿，透明值，或者是CATransform3D中独立矩阵的坐标）。我们同样需要一些逻辑在插值之前对对象拆解值，然后在插值之后在重新封装成对象，也就是说需要实时地检查类型。</p>
<p>一旦我们可以用代码获取属性动画的起始值之间的任意插值，我们就可以把动画分割成许多独立的关键帧，然后产出一个线性的关键帧动画。清单10.7展示了相关代码。</p>
<p>注意到我们用了60 x 动画时间（秒做单位）作为关键帧的个数，这时因为Core Animation按照每秒60帧去渲染屏幕更新，所以如果我们每秒生成60个关键帧，就可以保证动画足够的平滑（尽管实际上很可能用更少的帧率就可以达到很好的效果）。</p>
<p>我们在示例中仅仅引入了对CGPoint类型的插值代码。但是，从代码中很清楚能看出如何扩展成支持别的类型。作为不能识别类型的备选方案，我们仅仅在前一半返回了fromValue，在后一半返回了toValue。</p>
<p>清单10.7 使用插入的值创建一个关键帧动画<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">float interpolate(float from, float to, float time)</div><div class="line">&#123;</div><div class="line">    return (to - from) * time + from;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (id)interpolateFromValue:(id)fromValue toValue:(id)toValue time:(float)time</div><div class="line">&#123;</div><div class="line">    if ([fromValue isKindOfClass:[NSValue class]]) &#123;</div><div class="line">        //get type</div><div class="line">        const char *type = [fromValue objCType];</div><div class="line">        if (strcmp(type, @encode(CGPoint)) == 0) &#123;</div><div class="line">            CGPoint from = [fromValue CGPointValue];</div><div class="line">            CGPoint to = [toValue CGPointValue];</div><div class="line">            CGPoint result = CGPointMake(interpolate(from.x, to.x, time), interpolate(from.y, to.y, time));</div><div class="line">            return [NSValue valueWithCGPoint:result];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    //provide safe default implementation</div><div class="line">    return (time &lt; 0.5)? fromValue: toValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //set up animation parameters</div><div class="line">    NSValue *fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    NSValue *toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    CFTimeInterval duration = 1.0;</div><div class="line">    //generate keyframes</div><div class="line">    NSInteger numFrames = duration * 60;</div><div class="line">    NSMutableArray *frames = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; numFrames; i++) &#123;</div><div class="line">        float time = 1 / (float)numFrames * i;</div><div class="line">        [frames addObject:[self interpolateFromValue:fromValue toValue:toValue time:time]];</div><div class="line">    &#125;</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = frames;</div><div class="line">    //apply animation</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这可以起到作用，但效果并不是很好，到目前为止我们所完成的只是一个非常复杂的方式来使用线性缓冲复制CABasicAnimation的行为。这种方式的好处在于我们可以更加精确地控制缓冲，这也意味着我们可以应用一个完全定制的缓冲函数。那么该如何做呢？</p>
<p>缓冲背后的数学并不很简单，但是幸运的是我们不需要一一实现它。罗伯特·彭纳有一个网页关于缓冲函数（<a href="http://www.robertpenner.com/easing" target="_blank" rel="noopener">http://www.robertpenner.com/easing</a>），包含了大多数普遍的缓冲函数的多种编程语言的实现的链接，包括C。这里是一个缓冲进入缓冲退出函数的示例（实际上有很多不同的方式去实现它）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">float quadraticEaseInOut(float t)</div><div class="line">&#123;</div><div class="line">    return (t &lt; 0.5)? (2 * t * t): (-2 * t * t) + (4 * t) - 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">对我们的弹性球来说，我们可以使用bounceEaseOut函数：</div><div class="line"></div><div class="line">float bounceEaseOut(float t)</div><div class="line">&#123;</div><div class="line">    if (t &lt; 4/11.0) &#123;</div><div class="line">        return (121 * t * t)/16.0;</div><div class="line">    &#125; else if (t &lt; 8/11.0) &#123;</div><div class="line">        return (363/40.0 * t * t) - (99/10.0 * t) + 17/5.0;</div><div class="line">    &#125; else if (t &lt; 9/10.0) &#123;</div><div class="line">        return (4356/361.0 * t * t) - (35442/1805.0 * t) + 16061/1805.0;</div><div class="line">    &#125;</div><div class="line">    return (54/5.0 * t * t) - (513/25.0 * t) + 268/25.0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">如果修改清单10.7的代码来引入bounceEaseOut方法，我们的任务就是仅仅交换缓冲函数，现在就可以选择任意的缓冲类型创建动画了（见清单10.8）。</div><div class="line"></div><div class="line">清单10.8 用关键帧实现自定义的缓冲函数</div><div class="line"></div><div class="line">- (void)animate</div><div class="line">&#123;</div><div class="line">    //reset ball to top of screen</div><div class="line">    self.ballView.center = CGPointMake(150, 32);</div><div class="line">    //set up animation parameters</div><div class="line">    NSValue *fromValue = [NSValue valueWithCGPoint:CGPointMake(150, 32)];</div><div class="line">    NSValue *toValue = [NSValue valueWithCGPoint:CGPointMake(150, 268)];</div><div class="line">    CFTimeInterval duration = 1.0;</div><div class="line">    //generate keyframes</div><div class="line">    NSInteger numFrames = duration * 60;</div><div class="line">    NSMutableArray *frames = [NSMutableArray array];</div><div class="line">    for (int i = 0; i &lt; numFrames; i++) &#123;</div><div class="line">        float time = 1/(float)numFrames * i;</div><div class="line">        //apply easing</div><div class="line">        time = bounceEaseOut(time);</div><div class="line">        //add keyframe</div><div class="line">        [frames addObject:[self interpolateFromValue:fromValue toValue:toValue time:time]];</div><div class="line">    &#125;</div><div class="line">    //create keyframe animation</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animation];</div><div class="line">    animation.keyPath = @&quot;position&quot;;</div><div class="line">    animation.duration = 1.0;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.values = frames;</div><div class="line">    //apply animation</div><div class="line">    [self.ballView.layer addAnimation:animation forKey:nil];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#####总结<br> 在这一章中，我们了解了有关缓冲和CAMediaTimingFunction类，它可以允许我们创建自定义的缓冲函数来完善我们的动画，同样了解了如何用CAKeyframeAnimation来避开CAMediaTimingFunction的限制，创建完全自定义的缓冲函数。</p>
<p>在下一章中，我们将要研究基于定时器的动画–另一个给我们对动画更多控制的选择，并且实现对动画的实时操纵。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/08/CoreAnimation之动画继承/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/08/CoreAnimation之动画继承/" itemprop="url">CoreAnimation之动画继承</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-08T20:19:35+08:00">
                2016-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1694376-5bbcf21b1ece3a71.gif?imageMogr2/auto-orient/strip" alt="1.gif"><br> demo地址 :    <a href="https://github.com/liuxinixn/CoreAnimation-" target="_blank" rel="noopener">属性动画</a><br>在做属性动画的时候，先了解下动画继承关系：</p>
<p>####CAAnimation ：父类 遵守了<strong>CAMediaTiming</strong>协议</p>
<blockquote>
<p>CAMediaTiming媒体时间类协议</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">CAMediaTiming中的协议内容</div><div class="line"> 1.beginTime 动画开始的时间 默认为0</div><div class="line"> 2.duration 动画的持续时间 默认为0 持续时间 受速度的影响 实际动画完成时间 = 持续时间/速度</div><div class="line"> 3.speed 动画的播放速度 默认为1 速度设置为0 可以暂停动画 如果speed 2秒 duration 60秒 那么动画真正播放完成的时间 30秒 </div><div class="line"> 4.timeOffset 动画播放时间的偏移量</div><div class="line"> 5.repeatCount 动画的循环次数 默认是0 只播放一次 </div><div class="line"> 6.repeatDuration 动画循环的持续时间 repeatCount/repeatDuration 只能设置其中的一个属性 </div><div class="line"> 7.autoreverses 是否以动画的形式返回 返回到播放之前的状态 </div><div class="line"> 8.fillMode 设置当前对象在非活动时间段的状态 要想fillMode有效 需设置removedOnCompletion = NO</div><div class="line">  kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态 </div><div class="line">  kCAFillModeBackwards 立即进入动画的初始状态并等待动画开始 </div><div class="line">  kCAFillModeBoth 动画加入后开始之前 layer处于动画初始状态 动画结束后layer保持动画最后的状态</div><div class="line">  kCAFillModeRemoved 默认值 动画结束后 layer会恢复到之前的状态</div></pre></td></tr></table></figure>
<blockquote>
<p>CAAnimation动画属性方法介绍</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">1.初始化的方法 animation </div><div class="line">2.timingFunction 速度控制类 控制动画运行的节奏 </div><div class="line">初始化:functionWithName:</div><div class="line"> kCAMediaTimingFunctionLinear 匀速 </div><div class="line">kCAMediaTimingFunctionEaseIn 慢进快出 </div><div class="line">kCAMediaTimingFunctionEaseOut 快进慢出 </div><div class="line">kCAMediaTimingFunctionEaseInEaseOut 慢进慢出 中间加速 </div><div class="line">kCAMediaTimingFunctionDefault 默认 </div><div class="line">3.delegate 代理</div><div class="line">4.removedOnCompletion 完成动画的时候 是否移除动画效果 </div><div class="line">5.代理方法 </div><div class="line">- (void)animationDidStart:(CAAnimation *)anim</div><div class="line">- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div></pre></td></tr></table></figure>
<blockquote>
<p>#####三个常用个子类</p>
</blockquote>
<ul>
<li><p>CAPropertyAnimation</p>
<ul>
<li><p>CABasicAnimation 扩充属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">介绍：通过改变某个属性的值 到某个值 只能设置两个值 产生的动画</div><div class="line">fromValue 开始值 如果不设置不会返回到初始位置</div><div class="line">toValue 结束值</div><div class="line">byValue 通过哪个值</div><div class="line">@property(nullable, strong) id fromValue;</div><div class="line">@property(nullable, strong) id toValue;</div><div class="line">@property(nullable, strong) id byValue;</div></pre></td></tr></table></figure>
</li>
<li><p>CAKeyframeAnimation</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> 属性解析：</div><div class="line"></div><div class="line">- values：就是上述的NSArray对象。里面的元素称为”关键帧”(keyframe)。动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧</div><div class="line"></div><div class="line">- path：可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。如果你设置了path，那么values将被忽略</div><div class="line"></div><div class="line">- keyTimes：可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧.当keyTimes没有设置的时候,各个关键帧的时间是平分的</div><div class="line"></div><div class="line">- 说明：CABasicAnimation可看做是最多只有2个关键帧的CAKeyframeAnimation</div></pre></td></tr></table></figure>
<ul>
<li><p>CAAnimationGroup<br><code>@property(nullable, copy) NSArray&lt;CAAnimation *&gt; *animations;//组动画</code></p>
</li>
<li><p>CATransition 提供渐变效果:(推拉push效果,消退fade效果,揭开reveal效果)。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">type：动画过渡的类型</div><div class="line">subtype：动画过渡的方向</div><div class="line">@property(copy) NSString *type;</div><div class="line">@property(nullable, copy) NSString *subtype;</div><div class="line">@property float startProgress;</div><div class="line">@property float endProgress;</div><div class="line"></div><div class="line">/* Common transition types. */</div><div class="line"></div><div class="line">CA_EXTERN NSString * const kCATransitionFade</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionMoveIn</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionPush</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionReveal</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line"></div><div class="line">/* Common transition subtypes. */</div><div class="line"></div><div class="line">CA_EXTERN NSString * const kCATransitionFromRight</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionFromLeft</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionFromTop</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div><div class="line">CA_EXTERN NSString * const kCATransitionFromBottom</div><div class="line">    CA_AVAILABLE_STARTING (10.5, 2.0, 9.0, 2.0);</div></pre></td></tr></table></figure>
<blockquote>
<h5 id="keyPath可以使用的key-可以做动画的属性，包括虚拟属性"><a href="#keyPath可以使用的key-可以做动画的属性，包括虚拟属性" class="headerlink" title="keyPath可以使用的key ,可以做动画的属性，包括虚拟属性"></a>keyPath可以使用的key ,可以做动画的属性，包括虚拟属性</h5></blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">- #define angle2Radian(angle) ((angle)/180.0*M_PI)</div><div class="line">- transform.rotation.x 围绕x轴翻转 参数：角度 angle2Radian(4)</div><div class="line"></div><div class="line">transform.rotation.y 围绕y轴翻转 参数：同上</div><div class="line"></div><div class="line">transform.rotation.z 围绕z轴翻转 参数：同上</div><div class="line"></div><div class="line">transform.rotation 默认围绕z轴</div><div class="line"></div><div class="line">transform.scale.x x方向缩放 参数：缩放比例 1.5</div><div class="line"></div><div class="line">transform.scale.y y方向缩放 参数：同上</div><div class="line"></div><div class="line">transform.scale.z z方向缩放 参数：同上</div><div class="line"></div><div class="line">transform.scale 所有方向缩放 参数：同上</div><div class="line"></div><div class="line">transform.translation.x x方向移动 参数：x轴上的坐标 100</div><div class="line"></div><div class="line">transform.translation.y x方向移动 参数：y轴上的坐标</div><div class="line"></div><div class="line">transform.translation.z x方向移动 参数：z轴上的坐标</div><div class="line"></div><div class="line">transform.translation 移动 参数：移动到的点 （100，100）</div><div class="line"></div><div class="line">opacity 透明度 参数：透明度 0.5</div><div class="line"></div><div class="line">backgroundColor 背景颜色 参数：颜色 (id)[[UIColor redColor] CGColor]</div><div class="line"></div><div class="line">cornerRadius 圆角 参数：圆角半径 5</div><div class="line"></div><div class="line">borderWidth 边框宽度 参数：边框宽度 5</div><div class="line"></div><div class="line">bounds 大小 参数：CGRect</div><div class="line"></div><div class="line">contents 内容 参数：CGImage</div><div class="line"></div><div class="line">contentsRect 可视内容 参数：CGRect 值是0～1之间的小数</div><div class="line"></div><div class="line">hidden 是否隐藏</div><div class="line"></div><div class="line">position</div><div class="line"></div><div class="line">shadowColor</div><div class="line"></div><div class="line">shadowOffset</div><div class="line"></div><div class="line">shadowOpacity</div><div class="line"></div><div class="line">shadowRadius</div></pre></td></tr></table></figure>
<blockquote>
<p>#####基础动画 基础动画可以看做只有两帧。</p>
</blockquote>
<p>经常做的有个  心跳动画，可以尝试一波，有两个方法： </p>
<ol>
<li>改变bounds</li>
<li><p>改变 transform.scale </p>
<ul>
<li>第一种</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// 创建动画对象</div><div class="line">       CABasicAnimation *anim = [CABasicAnimation animation];</div><div class="line">   </div><div class="line">       anim.keyPath = @&quot;bounds&quot;;  // transform.scale 表示长和宽都缩放</div><div class="line">       anim.fromValue = [NSValue valueWithCGRect:self.subLayer.bounds];</div><div class="line">       anim.toValue = [NSValue valueWithCGRect:CGRectMake(0, 0, self.bounds.size.width , self.bounds.size.height )];                  // @0 缩放到最小</div><div class="line">   </div><div class="line">       anim.duration = 0.5;                // 设置动画执行时间</div><div class="line">       anim.repeatCount = MAXFLOAT;        // MAXFLOAT 表示动画执行次数为无限次</div><div class="line">   </div><div class="line">       anim.autoreverses = YES;            // 控制动画反转 默认情况下动画从尺寸1到0的过程中是有动画的，但是从0到1的过程中是没有动画的，设置autoreverses属性可以让尺寸0到1也是有过程的</div><div class="line">   </div><div class="line">       [self.subLayer addAnimation: anim forKey: nil];</div></pre></td></tr></table></figure>
<ul>
<li>第二种<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// 创建动画对象</div><div class="line">       CABasicAnimation *anim = [CABasicAnimation animation];</div><div class="line">   </div><div class="line">       anim.keyPath = @&quot;transform.scale&quot;;  // transform.scale 表示长和宽都缩放</div><div class="line">       anim.toValue = @0;                  // @0 缩放到最小</div><div class="line">   </div><div class="line">       anim.duration = 0.5;                // 设置动画执行时间</div><div class="line">       anim.repeatCount = MAXFLOAT;        // MAXFLOAT 表示动画执行次数为无限次</div><div class="line">   </div><div class="line">       anim.autoreverses = YES;            // 控制动画反转 默认情况下动画从尺寸1到0的过程中是有动画的，但是从0到1的过程中是没有动画的，设置autoreverses属性可以让尺寸0到1也是有过程的</div><div class="line">   </div><div class="line">       [self.icon.layer addAnimation: anim forKey: nil];</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>#####关键帧动画  tranfrom.rotation 其实是虚拟属性</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#define angle2Radio(angle) ((angle) * M_PI / 180.0)</div><div class="line">   CAKeyframeAnimation *animation =[CAKeyframeAnimation animationWithKeyPath:@&quot;transform.rotation&quot;];</div><div class="line">   animation.values = @[@(angle2Radio(-5)), @(angle2Radio(5)), @(angle2Radio(-5))]; // 把度数转换为弧度  度数/180*M_PI</div><div class="line">   animation.repeatCount = HUGE;</div><div class="line">   [self.subLayer addAnimation:animation forKey:nil];</div></pre></td></tr></table></figure>
<blockquote>
<p>#####过渡动画  在平常imageview切换时是没有动画的，我们可以在图片切换过程中增加个过渡动画</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">- (IBAction)btnAction:(UIButton *)sender &#123;</div><div class="line">    </div><div class="line">    // 0、切换图片</div><div class="line">    a++;</div><div class="line">    if (a&gt; 3) &#123;</div><div class="line">        a = 1;</div><div class="line">    &#125;</div><div class="line">     sender.userInteractionEnabled = NO;</div><div class="line">    self.icon.image = [UIImage imageNamed: [NSString stringWithFormat: @&quot;%d.jpg&quot;, a]];</div><div class="line">    CATransition *animation =[CATransition animation];</div><div class="line">    animation.type = @&quot;rippleEffect&quot;;</div><div class="line">    animation.duration = 2;</div><div class="line">    animation.delegate = self;</div><div class="line">    animation.timingFunction =[CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    [self.icon.layer addAnimation:animation forKey:nil];</div><div class="line">    sender.userInteractionEnabled = NO;</div><div class="line">&#125;</div><div class="line">-(void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag</div><div class="line">&#123;</div><div class="line">    //动画执行完后打开按钮的交互</div><div class="line">    self.button.userInteractionEnabled = YES;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/07/CoreAnimation之变换/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/07/CoreAnimation之变换/" itemprop="url">CoreAnimation之变化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-07T20:19:35+08:00">
                2016-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>很不幸，没人能告诉你母体是什么，你只能自己体会 – 骇客帝国</p>
</blockquote>
<p>在第四章“可视效果”中，我们研究了一些增强图层和它的内容显示效果的一些技术，在这一章中，我们将要研究可以用来对图层旋转，摆放或者扭曲的CGAffineTransform，以及可以将扁平物体转换成三维空间对象的CATransform3D（而不是仅仅对圆角矩形添加下沉阴影）。</p>
<ul>
<li>####<strong>仿射变换</strong></li>
</ul>
<p>在第三章“图层几何学”中，我们使用了UIView的transform属性旋转了钟的指针，但并没有解释背后运作的原理，实际上UIView的transform属性是一个CGAffineTransform类型，用于在二维空间做旋转，缩放和平移。CGAffineTransform是一个可以和二维空间向量（例如CGPoint）做乘法的3X2的矩阵（见图5.1）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-3045549ea178fed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.1.png"><br> 用CGPoint的每一列和CGAffineTransform矩阵的每一行对应元素相乘再求和，就形成了一个新的CGPoint类型的结果。要解释一下图中显示的灰色元素，为了能让矩阵做乘法，左边矩阵的列数一定要和右边矩阵的行数个数相同，所以要给矩阵填充一些标志值，使得既可以让矩阵做乘法，又不改变运算结果，并且没必要存储这些添加的值，因为它们的值不会发生变化，但是要用来做运算。</p>
<p>因此，通常会用3×3（而不是2×3）的矩阵来做二维变换，你可能会见到3行2列格式的矩阵，这是所谓的以列为主的格式，图5.1所示的是以行为主的格式，只要能保持一致，用哪种格式都无所谓。</p>
<p>当对图层应用变换矩阵，图层矩形内的每一个点都被相应地做变换，从而形成一个新的四边形的形状。CGAffineTransform中的“仿射”的意思是无论变换矩阵用什么值，图层中平行的两条线在变换之后任然保持平行，CGAffineTransform可以做出任意符合上述标注的变换，图5.2显示了一些仿射的和非仿射的变换：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-942383d3231167ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.2.png"></p>
<pre><code>仿射和非仿射变换
</code></pre><p><strong>创建一个CGAffineTransform</strong></p>
<p>对矩阵数学做一个全面的阐述就超出本书的讨论范围了，不过如果你对矩阵完全不熟悉的话，矩阵变换可能会使你感到畏惧。幸运的是，Core Graphics提供了一系列函数，对完全没有数学基础的开发者也能够简单地做一些变换。如下几个函数都创建了一个CGAffineTransform实例：<br><code>CGAffineTransformMakeRotation(CGFloat angle) 
CGAffineTransformMakeScale(CGFloat sx, CGFloat sy)
CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty)</code><br>  旋转和缩放变换都可以很好解释–分别旋转或者缩放一个向量的值。平移变换是指每个点都移动了向量指定的x或者y值–所以如果向量代表了一个点，那它就平移了这个点的距离。</p>
<p>我们用一个很简单的项目来做个demo，把一个原始视图旋转45度角度（图5.3）<br><img src="http://upload-images.jianshu.io/upload_images/1694376-378ef29aa545c385.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.3.png"><br> UIView可以通过设置transform属性做变换，但实际上它只是封装了内部图层的变换。</p>
<p>CALayer同样也有一个transform属性，但它的类型是CATransform3D，而不是CGAffineTransform，本章后续将会详细解释。CALayer对应于UIView的transform属性叫做affineTransform，清单5.1的例子就是使用affineTransform对图层做了45度顺时针旋转。</p>
<p>#####清单5.1 使用affineTransform对图层旋转45度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //rotate the layer 45 degrees</div><div class="line">    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);</div><div class="line">    self.layerView.layer.affineTransform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>注意我们使用的旋转常量是M_PI_4，而不是你想象的45，因为<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>的变换函数使用弧度而不是角度作为单位。弧度用数学常量pi的倍数表示，一个pi代表180度，所以四分之一的pi就是45度。</p>
<p>C的数学函数库（iOS会自动引入）提供了pi的一些简便的换算，M_PI_4于是就是pi的四分之一，如果对换算不太清楚的话，可以用如下的宏做换算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#define RADIANS_TO_DEGREES(x) ((x)/M_PI*180.0) </div><div class="line">#define DEGREES_TO_RADIANS(x) ((x)/180.0*M_PI)</div></pre></td></tr></table></figure></p>
<p><strong>混合变换</strong><br>Core Graphics提供了一系列的函数可以在一个变换的基础上做更深层次的变换，如果做一个既要缩放又要旋转的变换，这就会非常有用了。例如下面几个函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CGAffineTransformRotate(CGAffineTransform t, CGFloat angle)     </div><div class="line">CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy)      </div><div class="line">CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)</div></pre></td></tr></table></figure></p>
<p>当操纵一个变换的时候，初始生成一个什么都不做的变换很重要–也就是创建一个CGAffineTransform<br>类型的空值，矩阵论中称作单位矩阵，Core Graphics同样也提供了一个方便的常量：<br><code>CGAffineTransformIdentity</code><br>最后，如果需要混合两个已经存在的变换矩阵，就可以使用如下方法，在两个变换的基础上创建一个新的变换：<br><code>CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);</code></p>
<p>我们来用这些函数组合一个更加复杂的变换，先缩小50%，再旋转30度，最后向右移动200个像素（清单5.2）。图5.4显示了图层变换最后的结果。</p>
<p>#####清单5.2 使用若干方法创建一个复合变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad]; //create a new transform</div><div class="line">    CGAffineTransform transform = CGAffineTransformIdentity; //scale by 50%</div><div class="line">    transform = CGAffineTransformScale(transform, 0.5, 0.5); //rotate by 30 degrees</div><div class="line">    transform = CGAffineTransformRotate(transform, M_PI / 180.0 * 30.0); //translate by 200 points</div><div class="line">    transform = CGAffineTransformTranslate(transform, 200, 0);</div><div class="line">    //apply transform to layer</div><div class="line">    self.layerView.layer.affineTransform = transform;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-336be9d648d56cd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.4.png"></p>
<p> 图5.4中有些需要注意的地方：图片向右边发生了平移，但并没有指定距离那么远（200像素），另外它还有点向下发生了平移。原因在于当你按顺序做了变换，上一个变换的结果将会影响之后的变换，所以200像素的向右平移同样也被旋转了30度，缩小了50%，所以它实际上是斜向移动了100像素。</p>
<p>这意味着变换的顺序会影响最终的结果，也就是说旋转之后的平移和平移之后的旋转结果可能不同。</p>
<p><strong>剪切变换</strong><br>Core Graphics为你提供了计算变换矩阵的一些方法，所以很少需要直接设置CGAffineTransform<br>的值。除非需要创建一个斜切的变换，Core Graphics并没有提供直接的函数。<br>斜切变换是放射变换的第四种类型，较于平移，旋转和缩放并不常用（这也是Core Graphics没有提供相应函数的原因），但有些时候也会很有用。我们用一张图片可以很直接的说明效果（图5.5）。也许用“倾斜”描述更加恰当，具体做变换的代码见清单5.3。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-6817472cb15dc214.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="斜切变换.png"></p>
<p>####清单5.3 实现一个斜切变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">CGAffineTransform CGAffineTransformMakeShear(CGFloat x, CGFloat y)</div><div class="line">&#123;</div><div class="line">    CGAffineTransform transform = CGAffineTransformIdentity;</div><div class="line">    transform.c = -x;</div><div class="line">    transform.b = y;</div><div class="line">    return transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //shear the layer at a 45-degree angle</div><div class="line">    self.layerView.layer.affineTransform = CGAffineTransformMakeShear(1, 0);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>3D变换</strong><br> CG的前缀告诉我们，CGAffineTransform类型属于Core Graphics框架，Core Graphics实际上是一个严格意义上的2D绘图API，并且CGAffineTransform仅仅对2D变换有效。</p>
<p>在第三章中，我们提到了zPosition属性，可以用来让图层靠近或者远离相机（用户视角），transform属性（CATransform3D类型）可以真正做到这点，即让图层在3D空间内移动或者旋转。</p>
<p>和CGAffineTransform类似，CATransform3D也是一个矩阵，但是和2x3的矩阵不同，CATransform3D是一个可以在3维空间内做变换的4x4的矩阵（图5.6）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-474ebda43a0f86d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.6.png"></p>
<pre><code>对一个3D像素点做CATransform3D矩阵变换
</code></pre><p>和CGAffineTransform矩阵类似，Core Animation提供了一系列的方法用来创建和组合CATransform3D类型的矩阵，和Core Graphics的函数类似，但是3D的平移和旋转多处了一个z参数，并且旋转函数除了angle之外多出了x,y,z三个参数，分别决定了每个坐标轴方向上的旋转：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z)</div><div class="line">CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz) </div><div class="line">CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz)</div></pre></td></tr></table></figure></p>
<p>你应该对X轴和Y轴比较熟悉了，分别以右和下为正方向（回忆第三章，这是iOS上的标准结构，在Mac OS，Y轴朝上为正方向），Z轴和这两个轴分别垂直，指向视角外为正方向（图5.7)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0808e997f038e4a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.7.png"></p>
<p> 由图所见，绕Z轴的旋转等同于之前二维空间的仿射旋转，但是绕X轴和Y轴的旋转就突破了屏幕的二维空间，并且在用户视角看来发生了倾斜。</p>
<p>举个例子：清单5.4的代码使用了CATransform3DMakeRotation对视图内的图层绕Y轴做了45度角的旋转，我们可以把视图向右倾斜，这样会看得更清晰。</p>
<p>结果见图5.8，但并不像我们期待的那样。</p>
<p>#####清单5.4 绕Y轴旋转图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //rotate the layer 45 degrees along the Y axis</div><div class="line">        CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);</div><div class="line">        self.layerView.layer.transform = transform;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-740459ecf2961450.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.8.png"></p>
<p>看起来图层并没有被旋转，而是仅仅在水平方向上的一个压缩，是哪里出了问题呢？<br>其实完全没错，视图看起来更窄实际上是因为我们在用一个斜向的视角看它，而不是透视。</p>
<p><strong>透视投影</strong><br>在真实世界中，当物体远离我们的时候，由于视角的原因看起来会变小，理论上说远离我们的视图的边要比靠近视角的边跟短，但实际上并没有发生，而我们当前的视角是等距离的，也就是在3D变换中任然保持平行，和之前提到的仿射变换类似。</p>
<p>在等距投影中，远处的物体和近处的物体保持同样的缩放比例，这种投影也有它自己的用处（例如建筑绘图，颠倒，和伪3D视频），但当前我们并不需要。</p>
<p>为了做一些修正，我们需要引入投影变换（又称作z变换）来对除了旋转之外的变换矩阵做一些修改，Core Animation并没有给我们提供设置透视变换的函数，因此我们需要手动修改矩阵值，幸运的是，很简单：</p>
<p>CATransform3D的透视效果通过一个矩阵中一个很简单的元素来控制：m34。m34（图5.9）用于按比例缩放X和Y的值来计算到底要离视角多远。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d9b4df52bdf13918.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.9.png"><br> m34的默认值是0，我们可以通过设置m34为-1.0 / d来应用透视效果，d代表了想象中视角相机和屏幕之间的距离，以像素为单位，那应该如何计算这个距离呢？实际上并不需要，大概估算一个就好了。</p>
<p>因为视角相机实际上并不存在，所以可以根据屏幕上的显示效果自由决定它的防止的位置。通常500-1000就已经很好了，但对于特定的图层有时候更小后者更大的值会看起来更舒服，减少距离的值会增强透视效果，所以一个非常微小的值会让它看起来更加失真，然而一个非常大的值会让它基本失去透视效果，对视图应用透视的代码见清单5.5，结果见图5.10。</p>
<p>#####清单5.5 对变换应用透视效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //create a new transform</div><div class="line">    CATransform3D transform = CATransform3DIdentity;</div><div class="line">    //apply perspective</div><div class="line">    transform.m34 = - 1.0 / 500.0;</div><div class="line">    //rotate by 45 degrees along the Y axis</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_4, 0, 1, 0);</div><div class="line">    //apply to layer</div><div class="line">    self.layerView.layer.transform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-b2c36c95bd0d9de2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.10.png"></p>
<p><strong>灭点</strong><br> 当在透视角度绘图的时候，远离相机视角的物体将会变小变远，当远离到一个极限距离，它们可能就缩成了一个点，于是所有的物体最后都汇聚消失在同一个点。</p>
<p>在现实中，这个点通常是视图的中心（图5.11），于是为了在应用中创建拟真效果的透视，这个点应该聚在屏幕中点，或者至少是包含所有3D对象的视图中点。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0009ba0f03440c28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.11.png"><br> Core Animation定义了这个点位于变换图层的anchorPoint（通常位于图层中心，但也有例外，见第三章）。这就是说，当图层发生变换时，这个点永远位于图层变换之前anchorPoint的位置。</p>
<p>当改变一个图层的position，你也改变了它的灭点，做3D变换的时候要时刻记住这一点，当你视图通过调整m34来让它更加有3D效果，应该首先把它放置于屏幕中央，然后通过平移来把它移动到指定位置（而不是直接改变它的position），这样所有的3D图层都共享一个灭点。</p>
<ul>
<li>####<strong>sublayerTransform属性</strong></li>
</ul>
<p>如果有多个视图或者图层，每个都做3D变换，那就需要分别设置相同的m34值，并且确保在变换之前都在屏幕中央共享同一个position，如果用一个函数封装这些操作的确会更加方便，但仍然有限制（例如，你不能在Interface Builder中摆放视图），这里有一个更好的方法。</p>
<p>CALayer有一个属性叫做sublayerTransform。它也是CATransform3D类型，但和对一个图层的变换不同，它影响到所有的子图层。这意味着你可以一次性对包含这些图层的容器做变换，于是所有的子图层都自动继承了这个变换方法。</p>
<p>相较而言，通过在一个地方设置透视变换会很方便，同时它会带来另一个显著的优势：灭点被设置在容器图层的中点，从而不需要再对子图层分别设置了。这意味着你可以随意使用position<br>和frame来放置子图层，而不需要把它们放置在屏幕中点，然后为了保证统一的灭点用变换来做平移。</p>
<p>我们来用一个demo举例说明。这里用Interface Builder并排放置两个视图（图5.12），然后通过设置它们容器视图的透视变换，我们可以保证它们有相同的透视和灭点，代码见清单5.6，结果见图5.13。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-99bde2090f46140c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.12.png"></p>
<p>#####清单5.6 应用sublayerTransform<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //apply perspective transform to container</div><div class="line">    CATransform3D perspective = CATransform3DIdentity;</div><div class="line">    perspective.m34 = - 1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = perspective;</div><div class="line">    //rotate layerView1 by 45 degrees along the Y axis</div><div class="line">    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);</div><div class="line">    self.layerView1.layer.transform = transform1;</div><div class="line">    //rotate layerView2 by 45 degrees along the Y axis</div><div class="line">    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);</div><div class="line">    self.layerView2.layer.transform = transform2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-550f11f77952d490.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.13通过相同的透视效果分别对视图做变换.png"><br><strong>背面</strong><br>我们既然可以在3D场景下旋转图层，那么也可以从背面去观察它。如果我们在清单5.4中把角度修改为M_PI（180度）而不是当前的M_PI_4（45度），那么将会把图层完全旋转一个半圈，于是完全背对了相机视角。<br>那么从背部看图层是什么样的呢，见图5.14</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d410b79466859b60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.14.png"></p>
<p> 如你所见，图层是双面绘制的，反面显示的是正面的一个镜像图片。</p>
<p>但这并不是一个很好的特性，因为如果图层包含文本或者其他控件，那用户看到这些内容的镜像图片当然会感到困惑。另外也有可能造成资源的浪费：想象用这些图层形成一个不透明的固态立方体，既然永远都看不见这些图层的背面，那为什么浪费GPU来绘制它们呢？</p>
<p>CALayer有一个叫做doubleSided的属性来控制图层的背面是否要被绘制。这是一个BOOL类型，默认为YES，如果设置为NO，那么当图层正面从相机视角消失的时候，它将不会被绘制。</p>
<p><strong>扁平化图层</strong><br>如果对包含已经做过变换的图层的图层做反方向的变换将会发什么什么呢？是不是有点困惑？见图5.15</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-8c0d287a3d5365db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.15.png"></p>
<p>意做了-45度旋转的内部图层是怎样抵消旋转45度的图层，从而恢复正常状态的。</p>
<p>如果内部图层相对外部图层做了相反的变换（这里是绕Z轴的旋转），那么按照逻辑这两个变换将被相互抵消。</p>
<p>验证一下，相应代码见清单5.7，结果见5.16</p>
<p>#####清单5.7 绕Z轴做相反的旋转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *outerView;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *innerView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //rotate the outer layer 45 degrees</div><div class="line">       CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);</div><div class="line">       self.outerView.layer.transform = outer;</div><div class="line">       //rotate the inner layer -45 degrees</div><div class="line">       CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);</div><div class="line">       self.innerView.layer.transform = inner;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c628c844d39fcbf2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.16.png"></p>
<p>运行结果和我们预期的一致。现在在3D情况下再试一次。修改代码，让内外两个视图绕Y轴旋转而不是Z轴，再加上透视效果，以便我们观察。注意不能用sublayerTransform属性，因为内部的图层并不直接是容器图层的子图层，所以这里分别对图层设置透视变换（清单5.8）。</p>
<p>#####清单5.8 绕Y轴相反的旋转变换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //rotate the outer layer 45 degrees</div><div class="line">    CATransform3D outer = CATransform3DIdentity;</div><div class="line">    outer.m34 = -1.0 / 500.0;</div><div class="line">    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0);</div><div class="line">    self.outerView.layer.transform = outer;</div><div class="line">    //rotate the inner layer -45 degrees</div><div class="line">    CATransform3D inner = CATransform3DIdentity;</div><div class="line">    inner.m34 = -1.0 / 500.0;</div><div class="line">    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0);</div><div class="line">    self.innerView.layer.transform = inner;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-d0ede7526b6d95b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.17.png"></p>
<p>但其实这并不是我们所看到的，相反，我们看到的结果如图5.18所示。发什么了什么呢？内部的图层仍然向左侧旋转，并且发生了扭曲，但按道理说它应该保持正面朝上，并且显示正常的方块。</p>
<p>这是由于尽管Core Animation图层存在于3D空间之内，但它们并不都存在同一个3D空间。每个图层的3D场景其实是扁平化的，当你从正面观察一个图层，看到的实际上由子图层创建的想象出来的3D场景，但当你倾斜这个图层，你会发现实际上这个3D场景仅仅是被绘制在图层的表面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-77d09181063d3aa7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="518.png"></p>
<p> 类似的，当你在玩一个3D游戏，实际上仅仅是把屏幕做了一次倾斜，或许在游戏中可以看见有一面墙在你面前，但是倾斜屏幕并不能够看见墙里面的东西。所有场景里面绘制的东西并不会随着你观察它的角度改变而发生变化；图层也是同样的道理。</p>
<p>这使得用Core Animation创建非常复杂的3D场景变得十分困难。你不能够使用图层树去创建一个3D结构的层级关系–在相同场景下的任何3D表面必须和同样的图层保持一致，这是因为每个的父视图都把它的子视图扁平化了。</p>
<p>至少当你用正常的CALayer的时候是这样，CALayer有一个叫做CATransformLayer的子类来解决这个问题。具体在第六章“特殊的图层”中将会具体讨论。</p>
<p><strong>固体对象</strong><br>现在你懂得了在3D空间的一些图层布局的基础，我们来试着创建一个固态的3D对象（实际上是一个技术上所谓的空洞对象，但它以固态呈现）。我们用六个独立的视图来构建一个立方体的各个面。<br>在这个例子中，我们用Interface Builder来构建立方体的面（图5.19），我们当然可以用代码来写，但是用Interface Builder的好处是可以方便的在每一个面上添加子视图。记住这些面仅仅是包含视图和控件的普通的用户界面元素，它们完全是我们界面交互的部分，并且当把它折成一个立方体之后也不会改变这个性质。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-9ac8ecb9aac49eb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.19.png"><br> 这些面视图并没有放置在主视图当中，而是松散地排列在根nib文件里面。我们并不关心在这个容器中如何摆放它们的位置，因为后续将会用图层的transform对它们进行重新布局，并且用Interface Builder在容器视图之外摆放他们可以让我们容易看清楚它们的内容，如果把它们一个叠着一个都塞进主视图，将会变得很难看。</p>
<p>我们把一个有颜色的UILabel放置在视图内部，是为了清楚的辨别它们之间的关系，并且UIButton被放置在第三个面视图里面，后面会做简单的解释。</p>
<p>具体把视图组织成立方体的代码见清单5.9，结果见图5.20</p>
<p>#####清单5.9 创建一个立方体<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">   </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">@property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform</div><div class="line">&#123;</div><div class="line">    //get the face view and add it to the container</div><div class="line">    UIView *face = self.faces[index];</div><div class="line">    [self.containerView addSubview:face];</div><div class="line">    //center the face view within the container</div><div class="line">    CGSize containerSize = self.containerView.bounds.size;</div><div class="line">    face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div><div class="line">    // apply the transform</div><div class="line">    face.layer.transform = transform;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //set up the container sublayer transform</div><div class="line">    CATransform3D perspective = CATransform3DIdentity;</div><div class="line">    perspective.m34 = -1.0 / 500.0;</div><div class="line">    self.containerView.layer.sublayerTransform = perspective;</div><div class="line">    //add cube face 1</div><div class="line">    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);</div><div class="line">    [self addFace:0 withTransform:transform];</div><div class="line">    //add cube face 2</div><div class="line">    transform = CATransform3DMakeTranslation(100, 0, 0);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);</div><div class="line">    [self addFace:1 withTransform:transform];</div><div class="line">    //add cube face 3</div><div class="line">    transform = CATransform3DMakeTranslation(0, -100, 0);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);</div><div class="line">    [self addFace:2 withTransform:transform];</div><div class="line">    //add cube face 4</div><div class="line">    transform = CATransform3DMakeTranslation(0, 100, 0);</div><div class="line">    transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);</div><div class="line">    [self addFace:3 withTransform:transform];</div><div class="line">    //add cube face 5</div><div class="line">    transform = CATransform3DMakeTranslation(-100, 0, 0);</div><div class="line">    transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);</div><div class="line">    [self addFace:4 withTransform:transform];</div><div class="line">    //add cube face 6</div><div class="line">    transform = CATransform3DMakeTranslation(0, 0, -100);</div><div class="line">    transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);</div><div class="line">    [self addFace:5 withTransform:transform];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-27336b3a305d88a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="520.png"></p>
<p>从这个角度看立方体并不是很明显；看起来只是一个方块，为了更好地欣赏它，我们将更换一个不同的视角。</p>
<p>旋转这个立方体将会显得很笨重，因为我们要单独对每个面做旋转。另一个简单的方案是通过调整容器视图的sublayerTransform去旋转照相机。添加如下几行去旋转containerView图层的perspective变换矩阵：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0); </div><div class="line">perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);</div></pre></td></tr></table></figure></p>
<p>这就对相机（或者相对相机的整个场景，你也可以这么认为）绕Y轴旋转45度，并且绕X轴旋转45度。现在从另一个角度去观察立方体，就能看出它的真实面貌（图5.21）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-358730cc31f8063f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.21.png"><br><strong>光亮和阴影</strong></p>
<p>现在它看起来更像是一个立方体没错了，但是对每个面之间的连接还是很难分辨。Core Animation可以用3D显示图层，但是它对光线并没有概念。如果想让立方体看起来更加真实，需要自己做一个阴影效果。你可以通过改变每个面的背景颜色或者直接用带光亮效果的图片来调整。</p>
<p>如果需要动态地创建光线效果，你可以根据每个视图的方向应用不同的alpha值做出半透明的阴影图层，但为了计算阴影图层的不透明度，你需要得到每个面的正太向量（垂直于表面的向量），然后根据一个想象的光源计算出两个向量叉乘结果。叉乘代表了光源和图层之间的角度，从而决定了它有多大程度上的光亮。</p>
<p>清单5.10实现了这样一个结果，我们用GLKit框架来做向量的计算（你需要引入GLKit库来运行代码），每个面的CATransform3D都被转换成GLKMatrix4，然后通过GLKMatrix4GetMatrix3函数得出一个3×3的旋转矩阵。这个旋转矩阵指定了图层的方向，然后可以用它来得到正太向量的值。结果如图5.22所示，试着调整LIGHT_DIRECTION和AMBIENT_LIGHT的值来切换光线效果</p>
<p>#####清单5.10 对立方体的表面应用动态的光线效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">    </div><div class="line">#import &quot;ViewController.h&quot;</div><div class="line">#import &lt;QuartzCore/QuartzCore.h&gt;</div><div class="line">#import &lt;GLKit/GLKit.h&gt;</div><div class="line">    </div><div class="line">#define LIGHT_DIRECTION 0, 1, -0.5</div><div class="line">#define AMBIENT_LIGHT 0.5</div><div class="line">    </div><div class="line">    @interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @property (nonatomic, strong) IBOutletCollection(UIView) NSArray *faces;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (void)applyLightingToFace:(CALayer *)face</div><div class="line">    &#123;</div><div class="line">        //add lighting layer</div><div class="line">        CALayer *layer = [CALayer layer];</div><div class="line">        layer.frame = face.bounds;</div><div class="line">        [face addSublayer:layer];</div><div class="line">        //convert the face transform to matrix</div><div class="line">        //(GLKMatrix4 has the same structure as CATransform3D)</div><div class="line">        //译者注：GLKMatrix4和CATransform3D内存结构一致，但坐标类型有长度区别，所以理论上应该做一次float到CGFloat的转换，感谢[@zihuyishi](https://github.com/zihuyishi)同学~</div><div class="line">        CATransform3D transform = face.transform;</div><div class="line">        GLKMatrix4 matrix4 = *(GLKMatrix4 *)&amp;transform;</div><div class="line">        GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);</div><div class="line">        //get face normal</div><div class="line">        GLKVector3 normal = GLKVector3Make(0, 0, 1);</div><div class="line">        normal = GLKMatrix3MultiplyVector3(matrix3, normal);</div><div class="line">        normal = GLKVector3Normalize(normal);</div><div class="line">        //get dot product with light direction</div><div class="line">        GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));</div><div class="line">        float dotProduct = GLKVector3DotProduct(light, normal);</div><div class="line">        //set lighting layer opacity</div><div class="line">        CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;</div><div class="line">        UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];</div><div class="line">        layer.backgroundColor = color.CGColor;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)addFace:(NSInteger)index withTransform:(CATransform3D)transform</div><div class="line">    &#123;</div><div class="line">        //get the face view and add it to the container</div><div class="line">        UIView *face = self.faces[index];</div><div class="line">        [self.containerView addSubview:face];</div><div class="line">        //center the face view within the container</div><div class="line">        CGSize containerSize = self.containerView.bounds.size;</div><div class="line">        face.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);</div><div class="line">        // apply the transform</div><div class="line">        face.layer.transform = transform;</div><div class="line">        //apply lighting</div><div class="line">        [self applyLightingToFace:face.layer];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        //set up the container sublayer transform</div><div class="line">        CATransform3D perspective = CATransform3DIdentity;</div><div class="line">        perspective.m34 = -1.0 / 500.0;</div><div class="line">        perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);</div><div class="line">        perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);</div><div class="line">        self.containerView.layer.sublayerTransform = perspective;</div><div class="line">        //add cube face 1</div><div class="line">        CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);</div><div class="line">        [self addFace:0 withTransform:transform];</div><div class="line">        //add cube face 2</div><div class="line">        transform = CATransform3DMakeTranslation(100, 0, 0);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);</div><div class="line">        [self addFace:1 withTransform:transform];</div><div class="line">        //add cube face 3</div><div class="line">        transform = CATransform3DMakeTranslation(0, -100, 0);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);</div><div class="line">        [self addFace:2 withTransform:transform];</div><div class="line">        //add cube face 4</div><div class="line">        transform = CATransform3DMakeTranslation(0, 100, 0);</div><div class="line">        transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);</div><div class="line">        [self addFace:3 withTransform:transform];</div><div class="line">        //add cube face 5</div><div class="line">        transform = CATransform3DMakeTranslation(-100, 0, 0);</div><div class="line">        transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);</div><div class="line">        [self addFace:4 withTransform:transform];</div><div class="line">        //add cube face 6</div><div class="line">        transform = CATransform3DMakeTranslation(0, 0, -100);</div><div class="line">        transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);</div><div class="line">        [self addFace:5 withTransform:transform];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    @end</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-5326f4bc4b613368.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.22.png"></p>
<p><strong>点击事件</strong></p>
<p>你应该能注意到现在可以在第三个表面的顶部看见按钮了，点击它，什么都没发生，为什么呢？</p>
<p>这并不是因为iOS在3D场景下正确地处理响应事件，实际上是可以做到的。问题在于视图顺序。在第三章中我们简要提到过，点击事件的处理由视图在父视图中的顺序决定的，并不是3D空间中的Z轴顺序。当给立方体添加视图的时候，我们实际上是按照一个顺序添加，所以按照视图/图层顺序来说，4，5，6在3的前面。</p>
<p>即使我们看不见4，5，6的表面（因为被1，2，3遮了），iOS在事件响应上仍然保持之前的顺序。当试图点击表面3上的按钮，表面4，5，6截断了点击事件（取决于点击的位置），这就和普通的2D布局在按钮上覆盖物体一样。</p>
<p>你也许认为把doubleSided设置成NO可以解决这个问题，因为它不再渲染视图后面的内容，但实际上并不起作用。因为背对相机而隐藏的视图仍然会响应点击事件（这和通过设置hidden<br>属性或者设置alpha为0而隐藏的视图不同，那两种方式将不会响应事件）。所以即使禁止了双面渲染仍然不能解决这个问题（虽然由于性能问题，还是需要把它设置成NO）。</p>
<p>这里有几种正确的方案：把除了表面3的其他视图userInteractionEnabled属性都设置成NO来禁止事件传递。或者简单通过代码把视图3覆盖在视图6上。无论怎样都可以点击按钮了（图5.23）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-589bc9df2efcabfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="5.23.png"></p>
<p>#####总结<br> 这一章涉及了一些2D和3D的变换。你学习了一些矩阵计算的基础，以及如何用Core Animation创建3D场景。你看到了图层背后到底是如何呈现的，并且知道了不能把扁平的图片做成真实的立体效果，最后我们用demo说明了触摸事件的处理，视图中图层添加的层级顺序会比屏幕上显示的顺序更有意义。</p>
<p>第六章我们会研究一些Core Animation提供不同功能的具体的CALayer子类</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/06/-Swift之集合类型-(Collection-Types)（集合篇）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/06/-Swift之集合类型-(Collection-Types)（集合篇）/" itemprop="url">Swift之集合类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-06T20:19:36+08:00">
                2016-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>集合(Sets)</p>
</blockquote>
<p> 集合(Set)用来存储相同类型并且没有确定顺序的值。当 合元素顺序不重要时或者希望确保每个元素只出现一次 时可以使用 合而不是数组。<br><code>注意:Swift的 Set 类型被桥接到 Foundation 中的 NSSet 类。</code></p>
<p> 集合类型的哈希值<br>一个类型为了存储在 集合中，该类型必须是可哈希化的–也就是说，该类型必须提供一个方法来计算它的哈希 值。一个哈希值是 <code>Int</code> 类型的，相等的对象哈希值必须相同，比如 <code>a==b</code>,因此必须 <code>a.hashValue == b.hashValu e</code>。</p>
<p><code>Swift</code>的所有基本类型(比如 <code>String</code>,<code>Int</code> , <code>Double</code> 和 <code>Bool</code>)默认都是可哈希化的，可以作为 合的值的类型或 者字典的键的类型。没有关联值的枚举成员值(在枚举有讲述)默认也是可哈希化的。</p>
<p><strong>合类型语法</strong></p>
<p><code>Swift</code> 中的 <code>Set</code> 类型被写为<code>Set&lt;Element&gt;</code> ，这里的 <code>Element</code> 表示 <code>Set</code>中允许存储的类型，和数组不同的是，  合没有等价的简化形式。</p>
<p><strong>创建和构造一个空的 集合</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var letters = Set&lt;Character&gt;()</div><div class="line">print(&quot;letters is of type Set&lt;Character&gt; with \(letters.count) items.&quot;) // 打印 &quot;letters is of type Set&lt;Character&gt; with 0 items.&quot;</div></pre></td></tr></table></figure>
<p><code>注意:通过构造器，这里的 letters 变量的类型被推断为 Set&lt;Character&gt; 。</code></p>
<p>此外，如果上下文提供了类型信息，比如作为函数的参数或者已知类型的变量或常量，我们可以通过一个空的数 组字面量创建一个空的 <code>Set</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">letters.insert(&quot;a&quot;)</div><div class="line">// letters 现在含有1个 Character 类型的值</div><div class="line">letters = []</div><div class="line">// letters 现在是一个空的 Set, 但是它依然是 Set&lt;Character&gt; 类型</div></pre></td></tr></table></figure>
<p><strong>用数组字面量创建集合</strong></p>
<p>你可以使用数组字面量来构造 合，并且可以使用简化形式写一个或者多个值作为 合元素。<br>下面的例子创建一个称之为<code>favoriteGenres</code> 的 合来存储 <code>String</code>类型的值:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;] </div><div class="line">// favoriteGenres 被构造成含有三个初始值的 集合</div></pre></td></tr></table></figure></p>
<p>这个<code>favoriteGenres</code>变量被声明为“一个 <code>String</code>值的 合”，写为 <code>Set&lt;String&gt;</code>。由于这个特定的 合含有指 定 <code>String</code> 类型的值，所以它只允许存储 <code>String</code>类型值。这里的 <code>favoriteGenres</code>变量有三个 String 类型的初始 值(<code>&quot;Rock&quot;</code> ，<code>&quot;Classical&quot;</code> 和 <code>&quot;Hip hop&quot;</code> )，并以数组字面量的方式出现。</p>
<p><code>注意:
favoriteGenres 被声明为一个变量(拥有 var 标示符)而不是一个常量(拥有 let 标示符),因为它里面的元素将 会在下面的例子中被增加或者移除。</code></p>
<p>一个 <code>Set</code> 类型不能从数组字面量中被单独推断出来，因此<code>Set</code> 类型必须显式声明。然而，由于 <code>Swift</code> 的类型推 断功能，如果你想使用一个数组字面量构造一个<code>Set</code> 并且该数组字面量中的所有元素类型相同，那么你无须写出<br><code>Set</code> 的具体类型。 <code>favoriteGenres</code> 的构造形式可以采用简化的方式代替:</p>
<p><code>var favoriteGenres: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]</code></p>
<p>由于数组字面量中的所有元素类型相同，<code>Swift</code>可以推断出 <code>Set&lt;String&gt;</code> 作为 <code>favoriteGenres</code>变量的正确类型。</p>
<p><strong>访问和修改一个集合</strong><br>你可以通过 <code>Set</code> 的属性和方法来访问和修改一个 <code>Set</code> 。</p>
<p>为了找出一个<code>Set</code> 中元素的数量，可以使用其只读属性<code>count</code> :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(&quot;I have \(favoriteGenres.count) favorite music genres.&quot;) // 打印 &quot;I have 3 favorite music genres.</div></pre></td></tr></table></figure>
<p>使用布尔属性 <code>isEmpty</code>作为一个缩写形式去检查 <code>count</code>属性是否为 <code>0</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> if favoriteGenres.isEmpty &#123;</div><div class="line">     print(&quot;As far as music goes, I&apos;m not picky.&quot;)</div><div class="line"> &#125; else &#123;</div><div class="line">     print(&quot;I have particular music preferences.&quot;)</div><div class="line">&#125;</div><div class="line">// 打印 &quot;I have particular music preferences.&quot;</div></pre></td></tr></table></figure>
<p>你可以通过调用 <code>Set</code> 的 <code>insert(_:)</code>方法来添加一个新元素:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">favoriteGenres.insert(&quot;Jazz&quot;)</div><div class="line">// favoriteGenres 现在包含4个元素</div></pre></td></tr></table></figure></p>
<p>你可以通过调用 <code>Set</code> 的 <code>remove(_:)</code>方法去删除一个元素，如果该值是该 <code>Set</code>的一个元素则删除该元素并且返回 被删除的元素值，否则如果该<code>Set</code> 不包含该值，则返回 <code>nil</code> 。另外， <code>Set</code> 中的所有元素可以通过它的<code>removeAl l()</code>方法删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> if let removedGenre = favoriteGenres.remove(&quot;Rock&quot;) &#123;</div><div class="line">     print(&quot;\(removedGenre)? I&apos;m over it.&quot;)</div><div class="line"> &#125; else &#123;</div><div class="line">     print(&quot;I never much cared for that.&quot;)</div><div class="line">&#125;</div><div class="line">// 打印 &quot;Rock? I&apos;m over it.&quot;</div></pre></td></tr></table></figure>
<p>使用<code>contains(_:)</code> 方法去检查<code>Set</code> 中是否包含一个特定的值:</p>
<p><strong>遍历一个集合</strong></p>
<p>你可以在一个<code>for-in</code>循环中遍历一个 <code>Set</code>中的所有值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for genre in favoriteGenres &#123;</div><div class="line">    print(&quot;\(genre)&quot;)</div><div class="line">&#125;</div><div class="line">// Classical</div><div class="line">// Jazz</div><div class="line">// Hip hop</div></pre></td></tr></table></figure>
<p><code>Swift</code>的 <code>Set</code>类型没有确定的顺序，为了按照特定顺序来遍历一个 <code>Set</code> 中的值可以使用 <code>sorted()</code> 方法，它将返<br>回一个有序数组，这个数组的元素排列顺序由操作符<code>&#39;&lt;&#39;</code>对元素进行比较的结果来确定.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for genre in favoriteGenres.sorted() &#123;</div><div class="line">    print(&quot;(genre)&quot;)</div><div class="line">&#125;</div><div class="line">// prints &quot;Classical&quot;</div><div class="line">// prints &quot;Hip hop&quot;</div><div class="line">// prints &quot;Jazz</div></pre></td></tr></table></figure>
<blockquote>
<p>集合操作</p>
</blockquote>
<p>你可以高效地完成 Set 的一些基本操作，比如把两个 集合组合到一起，判断两个 合共有元素，或者判断两个  集合是否全包含，部分包含或者不相交。</p>
<p><strong>基本集合操作</strong><br>• 使用 intersection(<em>:) 方法根据两个 合中都包含的值创建的一个新的 集合。<br>• 使用 symmetricDifference(</em>:) 方法根据在一个 集合中但不在两个 合中的值创建一个新的 集合。 • 使用 union(<em>:) 方法根据两个集合的值创建一个新的集 合。<br>• 使用 subtracting(</em>:) 方法根据不在该 合中的值创建一个新的 集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">let oddDigits: Set = [1, 3, 5, 7, 9]</div><div class="line">let evenDigits: Set = [0, 2, 4, 6, 8]</div><div class="line">let singleDigitPrimeNumbers: Set = [2, 3, 5, 7]</div><div class="line">oddDigits.union(evenDigits).sort()</div><div class="line">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</div><div class="line">oddDigits. intersection(evenDigits).sorted()</div><div class="line">// []</div><div class="line">oddDigits.subtracting(singleDigitPrimeNumbers).sorted()</div><div class="line">// [1, 9]  以 singleDigitPrimeNumbers集合为标准，取出oddDigits集合中不在singleDigitPrimeNumbers的值</div><div class="line">oddDigits. symmetricDifference(singleDigitPrimeNumbers).sorted()</div><div class="line">// [1, 2, 9] 取出两个集合的并集去掉交集的集合</div></pre></td></tr></table></figure>
<p><strong>集合成员关系和相等</strong></p>
<p>• 使用“是否相等”运算符( == )来判断两个 集合是否包含全部相同的值。<br>• 使用 isSubset(of:) 方法来判断一个集 合中的值是否也被包含在另外一个 合中。<br>• 使用 isSuperset(of:) 方法来判断一个 集合中包含另一个集合中所有的值。<br>• 使用 isStrictSubset(of:) 或者 isStrictSuperset(of:) 方法来判断一个 合是否是另外一个集 合的子集 合或 者父集 合并且两个集 合并不相等。<br>• 使用 isDisjoint(with:) 方法来判断两个集 合是否不含有相同的值(是否没有交集)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let houseAnimals: Set = [&quot;?&quot;, &quot;?&quot;]</div><div class="line">let farmAnimals: Set = [&quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;, &quot;?&quot;]</div><div class="line">let cityAnimals: Set = [&quot;?&quot;, &quot;?&quot;]</div><div class="line">houseAnimals.isSubset(of: farmAnimals)</div><div class="line">// true</div><div class="line">farmAnimals.isSuperset(of: houseAnimals)</div><div class="line">// true</div><div class="line">farmAnimals.isDisjoint(with: cityAnimals)</div><div class="line">// true</div></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/06/ios-两种方式扩大button点击范围/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/06/ios-两种方式扩大button点击范围/" itemprop="url">iOS -两种方式扩大button的点击范围</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-06T20:19:35+08:00">
                2016-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>UI给的图有时候很小，或者有个需求需要我们扩大button的点击区域， 我们一般的操作是在button 上添加一个view 增加点击事件，但是我们还有其他更方便的方法去扩大button 的点击区域。有需要可以了解下事件的分发机制。<br>有两种方式扩大button 的点击区域：</p>
<blockquote>
<p>第一种：重写方法     -(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event</p>
</blockquote>
<p>继承与UIButton，实现如下效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(BOOL)pointInside:(CGPoint)point withEvent:(UIEvent*)event</div><div class="line">&#123;</div><div class="line">    CGRect bounds = self.bounds;</div><div class="line">    //扩大原热区直径至26，可以暴露个接口，用来设置需要扩大的半径。</div><div class="line">    CGFloat widthDelta = MAX(26, 0);</div><div class="line">    CGFloat heightDelta = MAX(26, 0);</div><div class="line">    bounds = CGRectInset(bounds, -0.5 * widthDelta, -0.5 * heightDelta);</div><div class="line">    return CGRectContainsPoint(bounds, point);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>第二种： 重写方法  - (UIView <em>)hitTest:(CGPoint)point withEvent:(UIEvent </em>)event</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    CGRect rectBig = CGRectInset(self.bounds, -(27.0/2), -(27.0/2));</div><div class="line">    </div><div class="line">    if (CGRectContainsPoint(rectBig, point)) &#123;</div><div class="line">        return self;</div><div class="line">    &#125;else&#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>######其实我们上面所做的变化其实如果仔细看点击区域还是个矩形，如果需要我们将点击区域规定在圆形范围 内，我们可以这样做：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">-(UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event&#123;</div><div class="line">    [super hitTest:point withEvent:event];</div><div class="line">    </div><div class="line">    CGPoint center = CGPointMake(self.bounds.size.width/2, self.bounds.size.height/2);</div><div class="line">    </div><div class="line">    </div><div class="line">   //当然这个半径也可以扩大</div><div class="line">    CGFloat raidus = self.frame.size.height &gt;= self.frame.size.width ?self.frame.size.width/2 :self.frame.size.width/2;</div><div class="line">    </div><div class="line">   //传入中心点 实时点击点 与半径判断 点击点是否在半径区域内</div><div class="line">    BOOL pointInRound =[self touchPointInsideCircle:center radius:raidus targetPoint:point];</div><div class="line">    </div><div class="line">    if (pointInRound) &#123;</div><div class="line">        return self;</div><div class="line">    &#125;else</div><div class="line">    &#123;</div><div class="line">        return nil;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//用来判断 圆形点击区域</div><div class="line">- (BOOL)touchPointInsideCircle:(CGPoint)center radius:(CGFloat)radius targetPoint:(CGPoint)point</div><div class="line">&#123;</div><div class="line">    CGFloat dist = sqrtf((point.x - center.x) * (point.x - center.x) +</div><div class="line">                         (point.y - center.y) * (point.y - center.y));</div><div class="line">    return (dist &lt;= radius);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/06/CoreAnimation之贝塞尔曲线（加入购物车动画）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/06/CoreAnimation之贝塞尔曲线（加入购物车动画）/" itemprop="url">CoreAnimation之贝塞尔曲线</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-06T20:19:35+08:00">
                2016-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="http://upload-images.jianshu.io/upload_images/1694376-c32df5200c40e600.gif?imageMogr2/auto-orient/strip" alt="12.gif"></p>
<blockquote>
<p><strong>加入购物车这个动画关键是贝塞尔曲线的绘制，然后给购物车加上一个关键帧动画即可。</strong></p>
</blockquote>
<p>贝塞尔曲线的起点从cell 中button开始，到购物车位置结束，控制点取 起点的纵坐标，终点的横坐标。<br>因为不在一个坐标系内，所以我们需要转换：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;</div><div class="line">- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;</div><div class="line">- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;</div><div class="line">- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;</div></pre></td></tr></table></figure></p>
<p><strong>在这里我们把购物车以及 cell 上的加入购物车按钮 全部转换到selv.view上（ps:本来想把购物车的中心点转化到tableview，上，把动画封装在cell的button 点击事件里，可是失败了， 代理方法会走，但是没有动画效果😢）</strong></p>
<blockquote>
<p>cell 中的回调处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">[self layoutIfNeeded];//xib初始化，需要获得正确的frame</div><div class="line">   </div><div class="line">   CGPoint carButtonCenter = sender.center;</div><div class="line">   </div><div class="line">   //把button在cell坐标转化为在tableView上的坐标</div><div class="line">   CGPoint point = [self convertPoint:carButtonCenter toView:self.superview.superview];</div><div class="line">   </div><div class="line">   //回调</div><div class="line">   if (_shoppingButtonBlock)</div><div class="line">   &#123;</div><div class="line">       _shoppingButtonBlock(point);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>viewcontroller中的处理</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath</div><div class="line">&#123;</div><div class="line">    MyCell *cell =[tableView dequeueReusableCellWithIdentifier:cellId];</div><div class="line">    if (!cell) &#123;</div><div class="line">        cell =[[MyCell alloc]initWithStyle:UITableViewCellStyleDefault reuseIdentifier:cellId];</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    __weak ViewController *weakSelf = self;</div><div class="line">    [cell setShoppingButtonBlock:^(CGPoint centerPoint) &#123;</div><div class="line">        //关键帧动画处理</div><div class="line">        [weakSelf startAnimate:centerPoint];</div><div class="line">    &#125;];</div><div class="line">   </div><div class="line">    return cell;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>可以把CAShapeLayer去掉，只是为了直观的看到动画效果</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimate:(CGPoint)centerPoint</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    CGPoint startPoint = [self.tableview convertPoint:centerPoint toView:self.view];;</div><div class="line">    CGPoint endpoint = self.shopView.center;</div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(endpoint.x, startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:startPoint];</div><div class="line">    [path addQuadCurveToPoint:endpoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [self.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    </div><div class="line">    [self.shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>还是将动画抽取出来，只需要起点和终点以及动画宿主视图,实现解耦。</p>
</blockquote>
<p>定义一个NSObject类，接口如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#import &lt;Foundation/Foundation.h&gt;</div><div class="line">#import &lt;UIKit/UIKit.h&gt;</div><div class="line">@interface AddToShopAnimation : NSObject</div><div class="line">-(instancetype)initWithStartPoint:(CGPoint)startPoint entPoint:(CGPoint)endPoint ViewController:(UIViewController *)viewController HostView:(UIView *)shopView;</div><div class="line">-(void)startAnimation;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">-(void)startAnimation</div><div class="line">&#123;</div><div class="line">    //起点</div><div class="line">    </div><div class="line">    //控点</div><div class="line">    CGPoint controlPoint = CGPointMake(_endPoint.x, _startPoint.y);</div><div class="line">    </div><div class="line">    UIBezierPath *path = [UIBezierPath bezierPath];</div><div class="line">    [path moveToPoint:_startPoint];</div><div class="line">    [path addQuadCurveToPoint:_endPoint controlPoint:controlPoint];</div><div class="line">    </div><div class="line">    CAShapeLayer *layer =[CAShapeLayer layer];</div><div class="line">    layer.path = path.CGPath;</div><div class="line">    layer.fillColor = [UIColor clearColor].CGColor;</div><div class="line">    layer.strokeColor = [UIColor redColor].CGColor;</div><div class="line">    layer.lineWidth = 3.0f;</div><div class="line">    layer.shouldRasterize = YES;//抗锯齿</div><div class="line">    [_viewController.view.layer addSublayer:layer];</div><div class="line">    </div><div class="line">    //创建关键帧</div><div class="line">    CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@&quot;position&quot;];</div><div class="line">    </div><div class="line">    //动画时间</div><div class="line">    animation.duration = 1;</div><div class="line">    animation.path = path.CGPath</div><div class="line">    ;</div><div class="line">    //当动画完成，停留到结束位置</div><div class="line">    animation.removedOnCompletion = YES;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    animation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseInEaseOut];</div><div class="line">    [_shopView.layer addAnimation:animation forKey:nil];</div><div class="line">    path = nil;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>demo地址：<a href="https://github.com/liuxinixn/UIBezierPathAddtoShop" target="_blank" rel="noopener">贝塞尔曲线之加入购物车</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/05/CoreAnimation图层几何学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/05/CoreAnimation图层几何学/" itemprop="url">CoreAnimation图层几何学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-05T20:19:35+08:00">
                2016-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在第二章里面，我们介绍了图层背后的图片，和一些控制图层坐标和旋转的属性。在这一章中，我们将要看一看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<ul>
<li>####<strong>布局</strong></li>
</ul>
<p> UIView有三个比较重要的布局属性：frame，bounds和center，CALayer对应地叫做frame，bounds和position。为了能清楚区分，图层用了“position”，视图用了“center”，但是他们都代表同样的值。</p>
<p>frame代表了图层的外部坐标（也就是在父图层上占据的空间），bounds是内部坐标（{0, 0}通常是图层的左上角），center和position都代表了相对于父图层anchorPoint所在的位置。anchorPoint的属性将会在后续介绍到，现在把它想成图层的中心点就好了。图3.1显示了这些属性是如何相互依赖的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-60c2a6313ce9cad9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.1.png"></p>
<p>视图的frame，bounds和center属性仅仅是存取方法，当操纵视图的frame，实际上是在改变位于视图下方CALayer的frame<br>，不能够独立于图层之外改变视图的frame。</p>
<p>对于视图或者图层来说，frame并不是一个非常清晰的属性，它其实是一个虚拟属性，是根据bounds，position和transform<br>计算而来，所以当其中任何一个值发生改变，frame都会变化。相反，改变frame的值同样会影响到他们当中的值</p>
<p>记住当对图层做变换的时候，比如旋转或者缩放，frame实际上代表了覆盖在图层旋转之后的整个轴对齐的矩形区域，也就是说frame的宽高可能和bounds的宽高不再一致了（图3.2）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-962d369cf221fcfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.2.png"></p>
<ul>
<li>####<strong>锚点</strong></li>
</ul>
<p>之前提到过，视图的center属性和图层的position属性都指定了anchorPoint相对于父图层的位置。图层的anchorPoint通过position来控制它的frame的位置，你可以认为anchorPoint是用来移动图层的把柄。</p>
<p>默认来说，anchorPoint位于图层的中点，所以图层的将会以这个点为中心放置。anchorPoint属性并没有被UIView接口暴露出来，这也是视图的position属性被叫做“center”的原因。但是图层的anchorPoint可以被移动，比如你可以把它置于图层frame的左上角，于是图层的内容将会向右下角的position方向移动（图3.3），而不是居中了。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-7827e0f4aceeba78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.3.png"></p>
<p>和第二章提到的contentsRect和contentsCenter属性类似，anchorPoint用单位坐标来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。anchorPoint可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。</p>
<p>注意在图3.3中，当改变了anchorPoint，position属性保持固定的值并没有发生改变，但是frame却移动了。</p>
<p>那在什么场合需要改变anchorPoint呢？既然我们可以随意改变图层位置，那改变anchorPoint不会造成困惑么？为了举例说明，我们来举一个实用的例子，创建一个模拟闹钟的项目。</p>
<p>钟面和钟表由四张图片组成（图3.4），为了简单说明，我们还是用传统的方式来装载和加载图片，使用四个UIImageView<br>实例（当然你也可以用正常的视图，设置他们图层的contents<br>图片）。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-2e8b159f0f65cc54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.4.png"></p>
<p> 闹钟的组件通过IB来排列（图3.5），这些图片视图嵌套在一个容器视图之内，并且自动调整和自动布局都被禁用了。这是因为自动调整会影响到视图的frame，而根据图3.2的演示，当视图旋转的时候，frame是会发生改变的，这将会导致一些布局上的失灵。</p>
<p>我们用NSTimer来更新闹钟，使用视图的transform属性来旋转钟表（如果你对这个属性不太熟悉，不要着急，我们将会在第5章“变换”当中详细说明），具体代码见清单3.1</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-0a145b572f694e7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.5.png"></p>
<p>#####清单3.1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *hourHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *minuteHand;</div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *secondHand;</div><div class="line">@property (nonatomic, weak) NSTimer *timer;</div><div class="line"></div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    //start timer</div><div class="line">    self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">    ￼</div><div class="line">    //set initial hand positions</div><div class="line">    [self tick];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (void)tick</div><div class="line">&#123;</div><div class="line">    //convert time to hours, minutes and seconds</div><div class="line">    NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSGregorianCalendar];</div><div class="line">    NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">    NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">    CGFloat hoursAngle = (components.hour / 12.0) * M_PI * 2.0;</div><div class="line">    //calculate hour hand angle //calculate minute hand angle</div><div class="line">    CGFloat minsAngle = (components.minute / 60.0) * M_PI * 2.0;</div><div class="line">    //calculate second hand angle</div><div class="line">    CGFloat secsAngle = (components.second / 60.0) * M_PI * 2.0;</div><div class="line">    //rotate hands</div><div class="line">    self.hourHand.transform = CGAffineTransformMakeRotation(hoursAngle);</div><div class="line">    self.minuteHand.transform = CGAffineTransformMakeRotation(minsAngle);</div><div class="line">    self.secondHand.transform = CGAffineTransformMakeRotation(secsAngle);</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>运行项目，看起来有点奇怪（图3.6），因为钟表的图片在围绕着中心旋转，这并不是我们期待的一个支点。<br><img src="http://upload-images.jianshu.io/upload_images/1694376-63fdc55a5c4ba280.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.6.png"><br> 你也许会认为可以在Interface Builder当中调整指针图片的位置来解决，但其实并不能达到目的，因为如果不放在钟面中间的话，同样不能正确的旋转。</p>
<p>也许在图片末尾添加一个透明空间也是个解决方案，但这样会让图片变大，也会消耗更多的内存，这样并不优雅。</p>
<p>更好的方案是使用anchorPoint属性，我们来在-viewDidLoad方法中添加几行代码来给每个钟指针的anchorPoint做一些平移（清单3.2），图3.7显示了正确的结果。</p>
<p>#####清单3.2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       // adjust anchor points</div><div class="line">       </div><div class="line">       self.secondHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       self.minuteHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       self.hourHand.layer.anchorPoint = CGPointMake(0.5f, 0.9f);</div><div class="line">       </div><div class="line">       </div><div class="line">       // start timer</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-73c01bb8b7088a5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.7.png"></p>
<ul>
<li>####<strong>坐标系</strong><br>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds<br>，如果父图层发生了移动，它的所有子图层也会跟着移动。</li>
</ul>
<p>这样对于放置图层会更加方便，因为你可以通过移动根图层来将它的子图层作为一个整体来移动，但是有时候你需要知道一个图层的绝对位置，或者是相对于另一个图层的位置，而不是它当前父图层的位置。<br>CALayer给不同坐标系之间的图层转换提供了一些工具类方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- (CGPoint)convertPoint:(CGPoint)point fromLayer:(CALayer *)layer; </div><div class="line">- (CGPoint)convertPoint:(CGPoint)point toLayer:(CALayer *)layer; </div><div class="line">- (CGRect)convertRect:(CGRect)rect fromLayer:(CALayer *)layer;</div><div class="line">- (CGRect)convertRect:(CGRect)rect toLayer:(CALayer *)layer;</div></pre></td></tr></table></figure>
<p>这些方法可以把定义在一个图层坐标系下的点或者矩形转换成另一个图层坐标系下的点或者矩形</p>
<ul>
<li>####<strong>翻转的几何结构</strong></li>
</ul>
<p>常规说来，在<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>上，一个图层的position位于父图层的左上角，但是在Mac OS上，通常是位于左下角。Core Animation可以通过geometryFlipped属性来适配这两种情况，它决定了一个图层的坐标是否相对于父图层垂直翻转，是一个BOOL类型。在iOS上通过设置它为YES,意味着它的子图层将会被垂直翻转，也就是将会沿着底部排版而不是通常的顶部（它的所有子图层也同理，除非把它们geometryFlipped<br>属性也设为YES）。</p>
<ul>
<li>####<strong>Z坐标轴</strong></li>
</ul>
<p>和UIView严格的二维坐标系不同，CALayer存在于一个三维空间当中。除了我们已经讨论过的position和anchorPoint属性之外，CALayer还有另外两个属性，zPosition和anchorPointZ<br>，二者都是在Z轴上描述图层位置的浮点类型。</p>
<p>注意这里并没有更深的属性来描述由宽和高做成的bounds<br>了，图层是一个完全扁平的对象，你可以把它们想象成类似于一页二维的坚硬的纸片，用胶水粘成一个空洞，就像三维结构的折纸一样。</p>
<p>zPosition属性在大多数情况下其实并不常用。在第五章，我们将会涉及CATransform3D，你会知道如何在三维空间移动和旋转图层，除了做变换之外，zPosition最实用的功能就是改变图层的显示顺序了。</p>
<p>通常，图层是根据它们子图层的sublayers<br>出现的顺序来类绘制的，这就是所谓的画家的<a href="http://lib.csdn.net/base/31" target="_blank" rel="noopener">算法</a>–就像一个画家在墙上作画–后被绘制上的图层将会遮盖住之前的图层，但是通过增加图层的zPosition，就可以把图层向相机方向前置，于是它就在所有其他图层的前面了（或者至少是小于它的zPosition值的图层的前面）。</p>
<p>这里所谓的“相机”实际上是相对于用户是视角，这里和iPhone背后的内置相机没任何关系。</p>
<p>图3.8显示了在Interface Builder内的一对视图，正如你所见，首先出现在视图层级绿色的视图被绘制在红色视图的后面。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-68e4281dd52477ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.8.png"><br>我们希望在真实的应用中也能显示出绘图的顺序，同样地，如果我们提高绿色视图的zPosition（清单3.3），我们会发现顺序就反了（图3.9）。其实并不需要增加太多，视图都非常地薄，所以给zPosition提高一个像素就可以让绿色视图前置，当然0.1或者0.0001也能够做到，但是最好不要这样，因为浮点类型四舍五入的计算可能会造成一些不便的麻烦。</p>
<p>#####清单3.3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *greenView;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *redView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       ￼</div><div class="line">       //move the green view zPosition nearer to the camera</div><div class="line">       self.greenView.layer.zPosition = 1.0f;</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-e7ea5f6f69f43a5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.9绿色视图被绘制在红色视图的前面.png"></p>
<ul>
<li>####<strong>Hit Testing</strong></li>
</ul>
<p> 第一章“图层树”证实了最好使用图层相关视图，而不是创建独立的图层关系。其中一个原因就是要处理额外复杂的触摸事件。</p>
<p>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：-containsPoint:和-hitTest:。</p>
<p>-containsPoint:接受一个在本图层坐标系下的CGPoint，如果这个点在图层frame范围内就返回YES。如清单3.4所示第一章的项目的另一个合适的版本，也就是使用-containsPoint:方法来判断到底是白色还是蓝色的图层被触摸了 （图3.10）。这需要把触摸坐标转换成每个图层坐标系下的坐标，结果很不方便。</p>
<p>#####清单3.4 使用containsPoint判断被点击的图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView;</div><div class="line">   @property (nonatomic, weak) CALayer *blueLayer;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       //create sublayer</div><div class="line">       self.blueLayer = [CALayer layer];</div><div class="line">       self.blueLayer.frame = CGRectMake(50.0f, 50.0f, 100.0f, 100.0f);</div><div class="line">       self.blueLayer.backgroundColor = [UIColor blueColor].CGColor;</div><div class="line">       //add it to our view</div><div class="line">       [self.layerView.layer addSublayer:self.blueLayer];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">   &#123;</div><div class="line">       //get touch position relative to main view</div><div class="line">       CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">       //convert point to the white layer&apos;s coordinates</div><div class="line">       point = [self.layerView.layer convertPoint:point fromLayer:self.view.layer];</div><div class="line">       //get layer using containsPoint:</div><div class="line">       if ([self.layerView.layer containsPoint:point]) &#123;</div><div class="line">           //convert point to blueLayer’s coordinates</div><div class="line">           point = [self.blueLayer convertPoint:point fromLayer:self.layerView.layer];</div><div class="line">           if ([self.blueLayer containsPoint:point]) &#123;</div><div class="line">               [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                           message:nil</div><div class="line">                                          delegate:nil</div><div class="line">                                 cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                                 otherButtonTitles:nil] show];</div><div class="line">           &#125; else &#123;</div><div class="line">               [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                           message:nil</div><div class="line">                                          delegate:nil</div><div class="line">                                 cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                                 otherButtonTitles:nil] show];</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-71820c2c4fb8faac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3.10点击图层被正确标识.png"></p>
<p>-hitTest:方法同样接受一个CGPoint类型参数，而不是BOOL类型，它返回图层本身，或者包含这个坐标点的叶子节点图层。这意味着不再需要像使用-containsPoint:那样，人工地在每个子图层变换或者测试点击的坐标。如果这个点在最外面图层的范围之外，则返回nil。具体使用-hitTest:方法被点击图层的代码如清单3.5所示。</p>
<p>#####使用hitTest判断被点击的图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</div><div class="line">&#123;</div><div class="line">    //get touch position</div><div class="line">    CGPoint point = [[touches anyObject] locationInView:self.view];</div><div class="line">    //get touched layer</div><div class="line">    CALayer *layer = [self.layerView.layer hitTest:point];</div><div class="line">    //get layer using hitTest</div><div class="line">    if (layer == self.blueLayer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside Blue Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125; else if (layer == self.layerView.layer) &#123;</div><div class="line">        [[[UIAlertView alloc] initWithTitle:@&quot;Inside White Layer&quot;</div><div class="line">                                    message:nil</div><div class="line">                                   delegate:nil</div><div class="line">                          cancelButtonTitle:@&quot;OK&quot;</div><div class="line">                          otherButtonTitles:nil] show];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p> 注意当调用图层的-hitTest:方法时，测算的顺序严格依赖于图层树当中的图层顺序（和UIView处理事件类似）。之前提到的zPosition属性可以明显改变屏幕上图层的顺序，但不能改变事件传递的顺序。</p>
<p>这意味着如果改变了图层的z轴顺序，你会发现将不能够检测到最前方的视图点击事件，这是因为被另一个图层遮盖住了，虽然它的zPosition值较小，但是在图层树中的顺序靠前。我们将在第五章详细讨论这个问题。</p>
<ul>
<li>####<strong>自动布局属性</strong></li>
</ul>
<p>你可能用过UIViewAutoresizingMask类型的一些常量，应用于当父视图改变尺寸的时候，相应UIView的frame也跟着更新的场景（通常用于横竖屏切换）。</p>
<p>在iOS6中，苹果介绍了自动排版机制，它和自动调整不同，并且更加复杂。在Mac OS平台，CALayer有一个叫做layoutManager的属性可以通过CALayoutManager协议和CAConstraintLayoutManager类来实现自动排版的机制。但由于某些原因，这在iOS上并不适用。</p>
<p>当使用视图的时候，可以充分利用UIView类接口暴露出来的UIViewAutoresizingMask和NSLayoutConstraintAPI，但如果想随意控制CALayer的布局，就需要手工操作。最简单的方法就是使用CALayerDelegate如下函数：<br><code>- (void)layoutSublayersOfLayer:(CALayer *)layer;</code></p>
<p>#####总结<br> 本章涉及了CALayer的集合结构，包括它的frame，position和bounds，介绍了三维空间内图层的概念，以及如何在独立的图层内响应事件，最后简单说明了在iOS平台，Core Animation对自动调整和自动布局支持的缺乏。</p>
<p>在第四章“视觉效果”当中，我们接着介绍一些图层外表的特性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/04/CoreAnimation视觉效果/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/04/CoreAnimation视觉效果/" itemprop="url">CoreAnimation视觉效果</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-04T20:19:35+08:00">
                2016-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>嗯，圆和椭圆还不错，但如果是带圆角的矩形呢<br>我们现在能做到那样了么？<br>史蒂芬·乔布斯</p>
</blockquote>
<p>我们在第三章『图层几何学』中讨论了图层的frame，第二章『寄宿图』则讨论了图层的寄宿图。但是图层不仅仅可以是图片或是颜色的容器；还有一系列内建的特性使得创造美丽优雅的令人深刻的界面元素成为可能。在这一章，我们将会探索一些能够通过使用CALayer属性实现的视觉效果。</p>
<ul>
<li>####<strong>圆角</strong></li>
</ul>
<p>圆角矩形是<a href="http://lib.csdn.net/base/1" target="_blank" rel="noopener">iOS</a>的一个标志性审美特性。这在iOS的每一个地方都得到了体现，不论是主屏幕图标，还是警告弹框，甚至是文本框。按照这流行程度，你可能会认为一定有不借助Photoshop就能轻易创建圆角举行的方法。恭喜你，猜对了。<br>CALayer有一个叫做conrnerRadius的属性控制着图层角的曲率。它是一个浮点数，默认为0（为0的时候就是直角），但是你可以把它设置成任意值。默认情况下，这个曲率值只影响背景颜色而不影响背景图片或是子图层。不过，如果把masksToBounds设置成YES的话，图层里面的所有东西都会被截取。</p>
<p>我们可以通过一个简单的项目来演示这个效果。在Interface Builder中，我们放置一些视图，他们有一些子视图。而且这些子视图有一些超出了边界（如图4.1）。你可能无法看到他们超出了边界，因为在编辑界面的时候，超出的部分总是被Interface Builder裁切掉了。不过，你相信我就好了 :)</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-07f645d5d7004552.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.1.png"></p>
<p>然后在代码中，我们设置角的半径为20个点，并裁剪掉第一个视图的超出部分（见清单4.1）。技术上来说，这些属性都可以在Interface Builder的探测板中分别通过『用户定义运行时属性』和勾选『裁剪子视图』(Clip Subviews)选择框来直接设置属性的值。不过，在这个示例中，代码能够表示得更清楚。图4.2是运行代码的结果</p>
<p>#####清单4.1 设置cornerRadius和masksToBounds<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">    </div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">    </div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;￼￼￼</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //set the corner radius on our layers</div><div class="line">        self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">        self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">        </div><div class="line">        //enable clipping on the second layer</div><div class="line">        self.layerView2.layer.masksToBounds = YES;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-3a0579b2db95b743.png" alt="4.2.png"><br>如你所见，右边的子视图沿边界被裁剪了。<br>单独控制每个层的圆角曲率也不是不可能的。如果想创建有些圆角有些直角的图层或视图时，你可能需要一些不同的方法。比如使用一个图层蒙板（本章稍后会讲到）或者CAShapeLayer（见第六章『专用图层』）。</p>
<ul>
<li>####<strong>图层边框</strong></li>
</ul>
<p> CALayer另外两个非常有用属性就是borderWidth和borderColor。二者共同定义了图层边的绘制样式。这条线（也被称作stroke）沿着图层的bounds绘制，同时也包含图层的角。</p>
<p>borderWidth是以点为单位的定义边框粗细的浮点数，默认为0.borderColor定义了边框的颜色，默认为黑色。</p>
<p>borderColor是CGColorRef类型，而不是UIColor，所以它不是Cocoa的内置对象。不过呢，你肯定也清楚图层引用了borderColor，虽然属性声明并不能证明这一点。CGColorRef在引用/释放时候的行为表现得与NSObject极其相似。但是Objective-C语法并不支持这一做法，所以CGColorRef属性即便是强引用也只能通过assign关键字来声明。</p>
<p>边框是绘制在图层边界里面的，而且在所有子内容之前，也在子图层之前。如果我们在之前的示例中（清单4.2）加入图层的边框，你就能看到到底是怎么一回事了（如图4.3）.</p>
<p>#####清单4.2 加上边框<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">@implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       </div><div class="line">       //set the corner radius on our layers</div><div class="line">       self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">       self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">       </div><div class="line">       //add a border to our layers</div><div class="line">       self.layerView1.layer.borderWidth = 5.0f;</div><div class="line">       self.layerView2.layer.borderWidth = 5.0f;</div><div class="line">       </div><div class="line">       //enable clipping on the second layer</div><div class="line">       self.layerView2.layer.masksToBounds = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-c76368bfcc883724.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.3.png"><br>仔细观察会发现边框并不会把寄宿图或子图层的形状计算进来，如果图层的子图层超过了边界，或者是寄宿图在透明区域有一个透明蒙板，边框仍然会沿着图层的边界绘制出来（如图4.4）.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-767f323d4a8bcdb5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.4.png"></p>
<ul>
<li>####<strong>contentsScale属性</strong></li>
</ul>
<p> iOS的另一个常见特性呢，就是阴影。阴影往往可以达到图层深度暗示的效果。也能够用来强调正在显示的图层和优先级（比如说一个在其他视图之前的弹出框），不过有时候他们只是单纯的装饰目的。</p>
<p>给shadowOpacity属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：shadowColor，shadowOffset和shadowRadius。</p>
<p>显而易见，shadowColor属性控制着阴影的颜色，和borderColor和backgroundColor一样，它的类型也是CGColorRef。阴影默认是黑色，大多数时候你需要的阴影也是黑色的（其他颜色的阴影看起来是不是有一点点奇怪。。）。</p>
<p>shadowOffset属性控制着阴影的方向和距离。它是一个CGSize的值，宽度控制这阴影横向的位移，高度控制着纵向的位移。shadowOffset的默认值是 {0, -3}，意即阴影相对于Y轴有3个点的向上位移。</p>
<p>为什么要默认向上的阴影呢？尽管Core Animation是从图层套装演变而来（可以认为是为iOS创建的私有动画框架），但是呢，它却是在Mac OS上面世的，前面有提到，二者的Y轴是颠倒的。这就导致了默认的3个点位移的阴影是向上的。在Mac上，shadowOffset的默认值是阴影向下的，这样你就能理解为什么iOS上的阴影方向是向上的了（如图4.5）.</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-209274f1478b34a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.5.png"></p>
<p>苹果更倾向于用户界面的阴影应该是垂直向下的，所以在iOS把阴影宽度设为0，然后高度设为一个正值不失为一个做法。</p>
<p>shadowRadius属性控制着阴影的模糊度，当它的值是0的时候，阴影就和视图一样有一个非常确定的边界线。当值越来越大的时候，边界线看上去就会越来越模糊和自然。苹果自家的应用设计更偏向于自然的阴影，所以一个非零值再合适不过了。</p>
<p>通常来讲，如果你想让视图或控件非常醒目独立于背景之外（比如弹出框遮罩层），你就应该给shadowRadius<br>设置一个稍大的值。阴影越模糊，图层的深度看上去就会更明显（如图4.6）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-be8052dd45ee1287.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.6.png"></p>
<ul>
<li>####<strong>阴影裁剪</strong></li>
</ul>
<p>和图层边框不同，图层的阴影继承自内容的外形，而不是根据边界和角半径来确定。为了计算出阴影的形状，Core Animation会将寄宿图（包括子视图，如果有的话）考虑在内，然后通过这些来完美搭配图层形状从而创建一个阴影（见图4.7）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-55db4a5ddd630e6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.7.png"></p>
<p>当阴影和裁剪扯上关系的时候就有一个头疼的限制：阴影通常就是在Layer的边界之外，如果你开启了masksToBounds属性，所有从图层中突出来的内容都会被才剪掉。如果我们在我们之前的边框示例项目中增加图层的阴影属性时，你就会发现问题所在（见图4.8）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-d6faa3736b29968d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.8.png"></p>
<p> 从技术角度来说，这个结果是可以是可以理解的，但确实又不是我们想要的效果。如果你想沿着内容裁切，你需要用到两个图层：一个只画阴影的空的外图层，和一个用masksToBounds裁剪内容的内图层。</p>
<p>如果我们把之前项目的右边用单独的视图把裁剪的视图包起来，我们就可以解决这个问题（如图4.9）.<br><img src="http://upload-images.jianshu.io/upload_images/1694376-4c8e77c6cf05751f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.9.png"></p>
<p>我们只把阴影用在最外层的视图上，内层视图进行裁剪。清单4.3是代码实现，图4.10是运行结果。</p>
<p>#####清单4.3 用一个额外的视图来解决阴影裁切的问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">   @property (nonatomic, weak) IBOutlet UIView *shadowView;</div><div class="line">   </div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   ￼</div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad];</div><div class="line">       </div><div class="line">       //set the corner radius on our layers</div><div class="line">       self.layerView1.layer.cornerRadius = 20.0f;</div><div class="line">       self.layerView2.layer.cornerRadius = 20.0f;</div><div class="line">       </div><div class="line">       //add a border to our layers</div><div class="line">       self.layerView1.layer.borderWidth = 5.0f;</div><div class="line">       self.layerView2.layer.borderWidth = 5.0f;</div><div class="line">       </div><div class="line">       //add a shadow to layerView1</div><div class="line">       self.layerView1.layer.shadowOpacity = 0.5f;</div><div class="line">       self.layerView1.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);</div><div class="line">       self.layerView1.layer.shadowRadius = 5.0f;</div><div class="line">       </div><div class="line">       //add same shadow to shadowView (not layerView2)</div><div class="line">       self.shadowView.layer.shadowOpacity = 0.5f;</div><div class="line">       self.shadowView.layer.shadowOffset = CGSizeMake(0.0f, 5.0f);</div><div class="line">       self.shadowView.layer.shadowRadius = 5.0f;</div><div class="line">       </div><div class="line">       //enable clipping on the second layer</div><div class="line">       self.layerView2.layer.masksToBounds = YES;</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-fd2670824eb2870b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.10.png"></p>
<ul>
<li><p>####<strong>shadowPath属性</strong></p>
<p>我们已经知道图层阴影并不总是方的，而是从图层内容的形状继承而来。这看上去不错，但是实时计算阴影也是一个非常消耗资源的，尤其是图层有多个子图层，每个图层还有一个有透明效果的寄宿图的时候。</p>
</li>
</ul>
<p>如果你事先知道你的阴影形状会是什么样子的，你可以通过指定一个shadowPath来提高性能。shadowPath是一个CGPathRef类型（一个指向CGPath的指针）。CGPath是一个Core Graphics对象，用来指定任意的一个矢量图形。我们可以通过这个属性单独于图层形状之外指定阴影的形状。</p>
<p>图4.11 展示了同一寄宿图的不同阴影设定。如你所见，我们使用的图形很简单，但是它的阴影可以是你想要的任何形状。清单4.4是代码实现。</p>
<p>#####清单4.4 创建简单的阴影形状<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView1;</div><div class="line">@property (nonatomic, weak) IBOutlet UIView *layerView2;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //enable layer shadows</div><div class="line">    self.layerView1.layer.shadowOpacity = 0.5f;</div><div class="line">    self.layerView2.layer.shadowOpacity = 0.5f;</div><div class="line">    </div><div class="line">    //create a square shadow</div><div class="line">    CGMutablePathRef squarePath = CGPathCreateMutable();</div><div class="line">    CGPathAddRect(squarePath, NULL, self.layerView1.bounds);</div><div class="line">    self.layerView1.layer.shadowPath = squarePath; CGPathRelease(squarePath);</div><div class="line">    </div><div class="line">    ￼//create a circular shadow</div><div class="line">    CGMutablePathRef circlePath = CGPathCreateMutable();</div><div class="line">    CGPathAddEllipseInRect(circlePath, NULL, self.layerView2.bounds);</div><div class="line">    self.layerView2.layer.shadowPath = circlePath; CGPathRelease(circlePath);</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-eb06f611b0a94d9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.11.png"></p>
<p>如果是一个矩形或者是圆，用CGPath会相当简单明了。但是如果是更加复杂一点的图形，UIBezierPath类会更合适，它是一个由UIKit提供的在CGPath基础上的Objective-C包装类。</p>
<ul>
<li>####<strong>图层蒙板</strong></li>
</ul>
<p> 通过masksToBounds属性，我们可以沿边界裁剪图形；通过cornerRadius属性，我们还可以设定一个圆角。但是有时候你希望展现的内容不是在一个矩形或圆角矩形。比如，你想展示一个有星形框架的图片，又或者想让一些古卷文字慢慢渐变成背景色，而不是一个突兀的边界。</p>
<p>使用一个32位有alpha通道的png图片通常是创建一个无矩形视图最方便的方法，你可以给它指定一个透明蒙板来实现。但是这个方法不能让你以编码的方式动态地生成蒙板，也不能让子图层或子视图裁剪成同样的形状。</p>
<p>CALayer有一个属性叫做mask可以解决这个问题。这个属性本身就是个CALayer类型，有和其他图层一样的绘制和布局属性。它类似于一个子图层，相对于父图层（即拥有该属性的图层）布局，但是它却不是一个普通的子图层。不同于那些绘制在父图层中的子图层，mask图层定义了父图层的部分可见区域。</p>
<p>mask图层的Color属性是无关紧要的，真正重要的是图层的轮廓。mask属性就像是一个饼干切割机，mask图层实心的部分会被保留下来，其他的则会被抛弃。（如图4.12）</p>
<p>如果mask图层比父图层要小，只有在mask图层里面的内容才是它关心的，除此以外的一切都会被隐藏起来。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-15fab782b87c7c86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.12.png"><br>我们将代码演示一下这个过程，创建一个简单的项目，通过图层的mask属性来作用于图片之上。为了简便一些，我们用Interface Builder来创建一个包含UIImageView的图片图层。这样我们就只要代码实现蒙板图层了。清单4.5是最终的代码，图4.13是运行后的结果。</p>
<p>#####清单4.5 应用蒙板图层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">  </div><div class="line">@interface ViewController ()</div><div class="line"></div><div class="line">@property (nonatomic, weak) IBOutlet UIImageView *imageView;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ViewController</div><div class="line"></div><div class="line">- (void)viewDidLoad</div><div class="line">&#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    </div><div class="line">    //create mask layer</div><div class="line">    CALayer *maskLayer = [CALayer layer];</div><div class="line">    maskLayer.frame = self.layerView.bounds;</div><div class="line">    UIImage *maskImage = [UIImage imageNamed:@&quot;Cone.png&quot;];</div><div class="line">    maskLayer.contents = (__bridge id)maskImage.CGImage;</div><div class="line">    </div><div class="line">    //apply mask to image layer￼</div><div class="line">    self.imageView.layer.mask = maskLayer;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-260195fb443dc625.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.13.png"><br>CALayer蒙板图层真正厉害的地方在于蒙板图不局限于静态图。任何有图层构成的都可以作为mask属性，这意味着你的蒙板可以通过代码甚至是动画实时生成。</p>
<ul>
<li>####<strong>拉伸过滤</strong></li>
</ul>
<p>最后我们再来谈谈minificationFilter和magnificationFilter<br>属性。总得来讲，当我们视图显示一个图片的时候，都应该正确地显示这个图片（意即：以正确的比例和正确的1：1像素显示在屏幕上）。原因如下：</p>
<ul>
<li>能够显示最好的画质，像素既没有被压缩也没有被拉伸。</li>
<li>能更好的使用内存，因为这就是所有你要存储的东西。</li>
<li>最好的性能表现，CPU不需要为此额外的计算。</li>
</ul>
<p>不过有时候，显示一个非真实大小的图片确实是我们需要的效果。比如说一个头像或是图片的缩略图，再比如说一个可以被拖拽和伸缩的大图。这些情况下，为同一图片的不同大小存储不同的图片显得又不切实际。<br>当图片需要显示不同的大小的时候，有一种叫做拉伸过滤的<a href="http://lib.csdn.net/base/31" target="_blank" rel="noopener">算法</a>就起到作用了。它作用于原图的像素上并根据需要生成新的像素显示在屏幕上。<br>事实上，重绘图片大小也没有一个统一的通用算法。这取决于需要拉伸的内容，放大或是缩小的需求等这些因素。CALayer为此提供了三种拉伸过滤方法，他们是：</p>
<ul>
<li>kCAFilterLinear</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear</li>
</ul>
<p>minification（缩小图片）和magnification（放大图片）默认的过滤器都是kCAFilterLinear，这个过滤器采用双线性滤波算法，它在大多数情况下都表现良好。双线性滤波算法通过对多个像素取样最终生成新的值，得到一个平滑的表现不错的拉伸。但是当放大倍数比较大的时候图片就模糊不清了。<br>kCAFilterTrilinear和kCAFilterLinear非常相似，大部分情况下二者都看不出来有什么差别。但是，较双线性滤波算法而言，三线性滤波算法存储了多个大小情况下的图片（也叫多重贴图），并三维取样，同时结合大图和小图的存储进而得到最后的结果。</p>
<p>这个方法的好处在于算法能够从一系列已经接近于最终大小的图片中得到想要的结果，也就是说不要对很多像素同步取样。这不仅提高了性能，也避免了小概率因舍入错误引起的取样失灵的问题</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-627fcecfb98c98cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.14.png"></p>
<p>kCAFilterNearest是一种比较武断的方法。从名字不难看出，这个算法（也叫最近过滤）就是取样最近的单像素点而不管其他的颜色。这样做非常快，也不会使图片模糊。但是，最明显的效果就是，会使得压缩图片更糟，图片放大之后也显得块状或是马赛克严重<br><img src="http://upload-images.jianshu.io/upload_images/1694376-14ccad89e4e169b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.15.png"></p>
<pre><code>图4.15 对于没有斜线的小图来说，最近过滤算法要好很多
</code></pre><p> 总的来说，对于比较小的图或者是差异特别明显，极少斜线的大图，最近过滤算法会保留这种差异明显的特质以呈现更好的结果。但是对于大多数的图尤其是有很多斜线或是曲线轮廓的图片来说，最近过滤算法会导致更差的结果。换句话说，线性过滤保留了形状，最近过滤则保留了像素的差异。</p>
<p>让我们来实验一下。我们对第三章的时钟项目改动一下，用LCD风格的数字方式显示。我们用简单的像素字体（一种用像素构成字符的字体，而非矢量图形）创造数字显示方式，用图片存储起来，而且用第二章介绍过的拼合技术来显示（如图4.16）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-abd590ea7cc36114.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.16.png"></p>
<p>我们在Interface Builder中放置了六个视图，小时、分钟、秒钟各两个，图4.17显示了这六个视图是如何在Interface Builder中放置的。如果每个都用一个淡出的outlets对象就会显得太多了，所以我们就用了一个IBOutletCollection对象把他们和控制器联系起来，这样我们就可以以数组的方式访问视图了。清单4.6是代码实现。</p>
<p>####清单4.6 显示一个LCD风格的时钟<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">@interface ViewController ()</div><div class="line">   </div><div class="line">   @property (nonatomic, strong) IBOutletCollection(UIView) NSArray *digitViews;</div><div class="line">   @property (nonatomic, weak) NSTimer *timer;</div><div class="line">   ￼￼</div><div class="line">   @end</div><div class="line">   </div><div class="line">   @implementation ViewController</div><div class="line">   </div><div class="line">   - (void)viewDidLoad</div><div class="line">   &#123;</div><div class="line">       [super viewDidLoad]; //get spritesheet image</div><div class="line">       UIImage *digits = [UIImage imageNamed:@&quot;Digits.png&quot;];</div><div class="line">       </div><div class="line">       //set up digit views</div><div class="line">       for (UIView *view in self.digitViews) &#123;</div><div class="line">           //set contents</div><div class="line">           view.layer.contents = (__bridge id)digits.CGImage;</div><div class="line">           view.layer.contentsRect = CGRectMake(0, 0, 0.1, 1.0);</div><div class="line">           view.layer.contentsGravity = kCAGravityResizeAspect;</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       //start timer</div><div class="line">       self.timer = [NSTimer scheduledTimerWithTimeInterval:1.0 target:self selector:@selector(tick) userInfo:nil repeats:YES];</div><div class="line">       </div><div class="line">       //set initial clock time</div><div class="line">       [self tick];</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)setDigit:(NSInteger)digit forView:(UIView *)view</div><div class="line">   &#123;</div><div class="line">       //adjust contentsRect to select correct digit</div><div class="line">       view.layer.contentsRect = CGRectMake(digit * 0.1, 0, 0.1, 1.0);</div><div class="line">   &#125;</div><div class="line">   </div><div class="line">   - (void)tick</div><div class="line">   &#123;</div><div class="line">       //convert time to hours, minutes and seconds</div><div class="line">       NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier: NSGregorianCalendar];</div><div class="line">       NSUInteger units = NSHourCalendarUnit | NSMinuteCalendarUnit | NSSecondCalendarUnit;</div><div class="line">       ￼</div><div class="line">       NSDateComponents *components = [calendar components:units fromDate:[NSDate date]];</div><div class="line">       </div><div class="line">       //set hours</div><div class="line">       [self setDigit:components.hour / 10 forView:self.digitViews[0]];</div><div class="line">       [self setDigit:components.hour % 10 forView:self.digitViews[1]];</div><div class="line">       </div><div class="line">       //set minutes</div><div class="line">       [self setDigit:components.minute / 10 forView:self.digitViews[2]];</div><div class="line">       [self setDigit:components.minute % 10 forView:self.digitViews[3]];</div><div class="line">       </div><div class="line">       //set seconds</div><div class="line">       [self setDigit:components.second / 10 forView:self.digitViews[4]];</div><div class="line">       [self setDigit:components.second % 10 forView:self.digitViews[5]];</div><div class="line">   &#125;</div><div class="line">   @end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-7dbef1a2760e625b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.18.png"></p>
<p>为了能像图4.19中那样，我们需要在for循环中加入如下代码：<br><code>view.layer.magnificationFilter = kCAFilterNearest;</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-43f21dbace80a1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.19.png"></p>
<ul>
<li>####<strong>组透明</strong></li>
</ul>
<p> UIView有一个叫做alpha的属性来确定视图的透明度。CALayer有一个等同的属性叫做opacity，这两个属性都是影响子层级的。也就是说，如果你给一个图层设置了opacity属性，那它的子图层都会受此影响。</p>
<p>iOS常见的做法是把一个空间的alpha值设置为0.5（50%）以使其看上去呈现为不可用状态。对于独立的视图来说还不错，但是当一个控件有子视图的时候就有点奇怪了，图4.20展示了一个内嵌了UILabel的自定义UIButton；左边是一个不透明的按钮，右边是50%透明度的相同按钮。我们可以注意到，里面的标签的轮廓跟按钮的背景很不搭调。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-8828828bb87444dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.20.png"></p>
<p> 这是由透明度的混合叠加造成的，当你显示一个50%透明度的图层时，图层的每个像素都会一般显示自己的颜色，另一半显示图层下面的颜色。这是正常的透明度的表现。但是如果图层包含一个同样显示50%透明的子图层时，你所看到的视图，50%来自子视图，25%来了图层本身的颜色，另外的25%则来自背景色。</p>
<p>在我们的示例中，按钮和表情都是白色背景。虽然他们都是50%的可见度，但是合起来的可见度是75%，所以标签所在的区域看上去就没有周围的部分那么透明。所以看上去子视图就高亮了，使得这个显示效果都糟透了。</p>
<p>理想状况下，当你设置了一个图层的透明度，你希望它包含的整个图层树像一个整体一样的透明效果。你可以通过设置Info.plist文件中的UIViewGroupOpacity为YES来达到这个效果，但是这个设置会影响到这个应用，整个app可能会受到不良影响。如果UIViewGroupOpacity并未设置，iOS 6和以前的版本会默认为NO（也许以后的版本会有一些改变）。</p>
<p>另一个方法就是，你可以设置CALayer的一个叫做shouldRasterize属性（见清单4.7）来实现组透明的效果，如果它被设置为YES，在应用透明度之前，图层及其子图层都会被整合成一个整体的图片，这样就没有透明度混合的问题了（如图4.21）。</p>
<p>为了启用shouldRasterize属性，我们设置了图层的rasterizationScale属性。默认情况下，所有图层拉伸都是1.0， 所以如果你使用了shouldRasterize属性，你就要确保你设置了rasterizationScale属性去匹配屏幕，以防止出现Retina屏幕像素化的问题。</p>
<p>当shouldRasterize和UIViewGroupOpacity一起的时候，性能问题就出现了（我们在第12章『速度』和第15章『图层性能』将做出介绍），但是性能碰撞都本地化了（译者注：这句话需要再翻译）。</p>
<p>#####清单4.7 使用shouldRasterize属性解决组透明问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"> </div><div class="line">    @interface ViewController ()</div><div class="line">    @property (nonatomic, weak) IBOutlet UIView *containerView;</div><div class="line">    @end</div><div class="line">    </div><div class="line">    @implementation ViewController</div><div class="line">    </div><div class="line">    - (UIButton *)customButton</div><div class="line">    &#123;</div><div class="line">        //create button</div><div class="line">        CGRect frame = CGRectMake(0, 0, 150, 50);</div><div class="line">        UIButton *button = [[UIButton alloc] initWithFrame:frame];</div><div class="line">        button.backgroundColor = [UIColor whiteColor];</div><div class="line">        button.layer.cornerRadius = 10;</div><div class="line">        </div><div class="line">        //add label</div><div class="line">        frame = CGRectMake(20, 10, 110, 30);</div><div class="line">        UILabel *label = [[UILabel alloc] initWithFrame:frame];</div><div class="line">        label.text = @&quot;Hello World&quot;;</div><div class="line">        label.textAlignment = NSTextAlignmentCenter;</div><div class="line">        [button addSubview:label];</div><div class="line">        return button;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    - (void)viewDidLoad</div><div class="line">    &#123;</div><div class="line">        [super viewDidLoad];</div><div class="line">        </div><div class="line">        //create opaque button</div><div class="line">        UIButton *button1 = [self customButton];</div><div class="line">        button1.center = CGPointMake(50, 150);</div><div class="line">        [self.containerView addSubview:button1];</div><div class="line">        </div><div class="line">        //create translucent button</div><div class="line">        UIButton *button2 = [self customButton];</div><div class="line">        ￼</div><div class="line">        button2.center = CGPointMake(250, 150);</div><div class="line">        button2.alpha = 0.5;</div><div class="line">        [self.containerView addSubview:button2];</div><div class="line">        </div><div class="line">        //enable rasterization for the translucent button</div><div class="line">        button2.layer.shouldRasterize = YES;</div><div class="line">        button2.layer.rasterizationScale = [UIScreen mainScreen].scale;</div><div class="line">    &#125;</div><div class="line">end</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1694376-006797526c30dcd0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="4.21.png"></p>
<p>#####总结<br> 这一章介绍了一些可以通过代码应用到图层上的视觉效果，比如圆角，阴影和蒙板。我们也了解了拉伸过滤器和组透明。</p>
<p>在第五章，『变换』中，我们将会研究图层变化和3D转换。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="liuxinixn.github.io/2016/05/03/CoreAnimation框架目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="雪晟">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="雪晟">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/03/CoreAnimation框架目录/" itemprop="url">CoreAnimation框架目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-03T20:19:35+08:00">
                2016-05-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="目录纵览"><a href="#目录纵览" class="headerlink" title="目录纵览"></a>目录纵览</h1><h4 id="第一章：图层树"><a href="#第一章：图层树" class="headerlink" title="第一章：图层树"></a>第一章：图层树</h4><ul>
<li>图层与视图</li>
<li>图层的能力</li>
<li>使用图层<br>总结 链接：<a href="http://www.jianshu.com/p/8447e0c24df1" target="_blank" rel="noopener">图层树</a><h4 id="第二章：寄宿图"><a href="#第二章：寄宿图" class="headerlink" title="第二章：寄宿图"></a>第二章：寄宿图</h4></li>
<li>contents属性</li>
<li>Custom Drawing （自定义绘制）<br>总结 链接：<a href="http://www.jianshu.com/p/fea670e92e9e" target="_blank" rel="noopener">寄宿图</a><h4 id="第三章：图层几何学"><a href="#第三章：图层几何学" class="headerlink" title="第三章：图层几何学"></a>第三章：图层几何学</h4></li>
<li>布局</li>
<li><a href="http://www.jianshu.com/p/52dfc061ff7f" target="_blank" rel="noopener">锚点</a></li>
<li>坐标系</li>
<li>Hit Testing</li>
<li>自动布局<br>总结 链接：<a href="http://www.jianshu.com/p/ffee86d98d58" target="_blank" rel="noopener">图层几何学</a><h4 id="第五章：视觉效果"><a href="#第五章：视觉效果" class="headerlink" title="第五章：视觉效果"></a>第五章：视觉效果</h4></li>
<li>圆角</li>
<li>图层边框</li>
<li>阴影</li>
<li><a href="http://www.jianshu.com/p/26e7803f057b" target="_blank" rel="noopener">图层蒙版</a></li>
<li>拉伸过滤</li>
<li>组透明<br>总结 链接：<a href="http://www.jianshu.com/p/b556af4a3c7d" target="_blank" rel="noopener">视觉效果</a></li>
</ul>
<h4 id="第五章：变换"><a href="#第五章：变换" class="headerlink" title="第五章：变换"></a>第五章：变换</h4><ul>
<li>仿射变换</li>
<li>图层边框</li>
<li>3D对象</li>
<li>固体对象<br>总结 链接：<a href="http://www.jianshu.com/p/ff380a2658fa" target="_blank" rel="noopener">变换</a><h4 id="第六章：专用图层"><a href="#第六章：专用图层" class="headerlink" title="第六章：专用图层"></a>第六章：专用图层</h4></li>
<li><a href="http://www.jianshu.com/p/16fd028ee636" target="_blank" rel="noopener">CAShapeLayer</a></li>
<li>CATextLayer</li>
<li>CATransformLayer</li>
<li><a href="http://www.jianshu.com/p/0e0ff206f110" target="_blank" rel="noopener">CAReplicatorLayer</a></li>
<li>CAScrollLayer</li>
<li><a href="http://www.jianshu.com/p/03095391e301" target="_blank" rel="noopener">CAEmitterLayer</a></li>
<li>CAEAGLLayer</li>
<li>AVPlayerLayer<br>总结 链接：<a href="http://www.jianshu.com/p/826e593d82b6" target="_blank" rel="noopener">专用图层</a><h4 id="第七章：隐式动画"><a href="#第七章：隐式动画" class="headerlink" title="第七章：隐式动画"></a>第七章：隐式动画</h4></li>
<li>事务</li>
<li>完成块</li>
<li>图层行为</li>
<li>呈现与模型<br>总结 链接：<a href="http://www.jianshu.com/p/0e082382a612" target="_blank" rel="noopener">隐式动画</a><h4 id="第八章：显式动画"><a href="#第八章：显式动画" class="headerlink" title="第八章：显式动画"></a>第八章：显式动画</h4></li>
<li><a href="http://www.jianshu.com/p/73f87913c18d" target="_blank" rel="noopener">属性动画</a></li>
<li>动画组</li>
<li>过渡</li>
<li>在动画过程中取消动画<br>总结 链接：<a href="http://www.jianshu.com/p/1e1364839b20" target="_blank" rel="noopener">显式动画</a><h4 id="第九章：图层时间"><a href="#第九章：图层时间" class="headerlink" title="第九章：图层时间"></a>第九章：图层时间</h4></li>
<li>CAMediaTiming 协议</li>
<li>层级关系时间</li>
<li>手动动画<br>总结 链接：<a href="http://www.jianshu.com/p/7bfe1ef1fb5b" target="_blank" rel="noopener">图层时间</a><h4 id="第十章：缓冲"><a href="#第十章：缓冲" class="headerlink" title="第十章：缓冲"></a>第十章：缓冲</h4></li>
<li>动画速度</li>
<li>自定义缓冲函数<br>总结 链接：<a href="http://www.jianshu.com/p/39d1f739e2c9" target="_blank" rel="noopener">缓冲</a><h4 id="第十一章：基于定时器的动画"><a href="#第十一章：基于定时器的动画" class="headerlink" title="第十一章：基于定时器的动画"></a>第十一章：基于定时器的动画</h4></li>
<li>定时帧</li>
<li>物理模拟<br>总结 链接：<a href="http://www.jianshu.com/p/761bece1c5a6" target="_blank" rel="noopener">基于定时器的动画</a><h4 id="第十二章：性能调优"><a href="#第十二章：性能调优" class="headerlink" title="第十二章：性能调优"></a>第十二章：性能调优</h4></li>
<li>CPU VS GPU</li>
<li>测量，而不是猜测</li>
<li>Instruments<br>总结 链接：<a href="http://www.jianshu.com/p/8874ec25c302" target="_blank" rel="noopener">性能调优</a><h4 id="第十三章：高效绘图"><a href="#第十三章：高效绘图" class="headerlink" title="第十三章：高效绘图"></a>第十三章：高效绘图</h4></li>
<li>软件绘图</li>
<li>矢量图形</li>
<li>脏矩形</li>
<li>异步绘制<br>总结 链接：<a href="http://www.jianshu.com/p/974eb333020a" target="_blank" rel="noopener">高效绘图</a><h4 id="第十四章：图像IO"><a href="#第十四章：图像IO" class="headerlink" title="第十四章：图像IO"></a>第十四章：图像IO</h4></li>
<li>加载和潜伏</li>
<li>缓存</li>
<li>文件格式<br>总结 链接：<a href="http://www.jianshu.com/p/1cb402c1bbba" target="_blank" rel="noopener">图像IO</a><h4 id="第十五章：图层性能"><a href="#第十五章：图层性能" class="headerlink" title="第十五章：图层性能"></a>第十五章：图层性能</h4></li>
<li>隐式绘制</li>
<li>离屏渲染</li>
<li>混合和过渡绘制</li>
<li>减少和过渡绘制<br>总结</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          
            <img class="site-author-image" itemprop="image"
              src="http://upload.jianshu.io/users/upload_avatars/1694376/4b7e25bd43ee.jpg"
              alt="雪晟" />
          
            <p class="site-author-name" itemprop="name">雪晟</p>
            <p class="site-description motion-element" itemprop="description">多去尝试你从未尝试的。</p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">112</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/liuxinixn" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/3d7c50f31b88" target="_blank" title="Jianshu">
                  
                    <i class="fa fa-fw fa-flag"></i>Jianshu</a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">雪晟</span>

  
</div>

<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv">
  本站访客数:<span id="busuanzi_value_site_uv"></span>
</span>
</div>

  <div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div>

  <span class="post-meta-divider">|</span>

  <div class="theme-info">主题 &mdash; <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.2</div>


        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  









  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/three/three.min.js"></script>

  
  <script type="text/javascript" src="/lib/three/three-waves.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>


  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
